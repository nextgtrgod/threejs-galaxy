var of=Object.defineProperty;var Ul=Object.getOwnPropertySymbols;var af=Object.prototype.hasOwnProperty,lf=Object.prototype.propertyIsEnumerable;var Hl=(o,t,e)=>t in o?of(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,Gl=(o,t)=>{for(var e in t||(t={}))af.call(t,e)&&Hl(o,e,t[e]);if(Ul)for(var e of Ul(t))lf.call(t,e)&&Hl(o,e,t[e]);return o};/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Wl="133",bi={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},yi={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},cf=0,ql=1,hf=2,jl=1,uf=2,br=3,yr=0,de=1,wi=2,Xl=1,An=0,wr=1,Yl=2,Zl=3,$l=4,df=5,Mi=100,pf=101,ff=102,Kl=103,Jl=104,mf=200,gf=201,vf=202,_f=203,Ql=204,tc=205,xf=206,bf=207,yf=208,wf=209,Mf=210,Sf=0,Ef=1,Tf=2,ko=3,Cf=4,Af=5,Pf=6,Lf=7,cs=0,Rf=1,Df=2,ii=0,If=1,Nf=2,kf=3,Ff=4,Bf=5,ec=300,hs=301,us=302,Fo=303,Bo=304,ds=306,Vo=307,Oo=1e3,Ue=1001,zo=1002,fe=1003,nc=1004,ic=1005,je=1006,Vf=1007,ps=1008,Pn=1009,Of=1010,zf=1011,fs=1012,Uf=1013,ms=1014,Ln=1015,Si=1016,Hf=1017,Gf=1018,Wf=1019,Mr=1020,qf=1021,Ei=1022,Pe=1023,jf=1024,Xf=1025,Yf=Pe,Ti=1026,Sr=1027,Zf=1028,$f=1029,Kf=1030,Jf=1031,Qf=1032,tm=1033,rc=33776,sc=33777,oc=33778,ac=33779,lc=35840,cc=35841,hc=35842,uc=35843,em=36196,dc=37492,pc=37496,nm=37808,im=37809,rm=37810,sm=37811,om=37812,am=37813,lm=37814,cm=37815,hm=37816,um=37817,dm=37818,pm=37819,fm=37820,mm=37821,gm=36492,vm=37840,_m=37841,xm=37842,bm=37843,ym=37844,wm=37845,Mm=37846,Sm=37847,Em=37848,Tm=37849,Cm=37850,Am=37851,Pm=37852,Lm=37853,Rm=2200,Dm=2201,Im=2202,gs=2300,vs=2301,Uo=2302,Ci=2400,Ai=2401,_s=2402,Ho=2500,fc=2501,Nm=0,we=3e3,ri=3001,Go=3007,Wo=3002,km=3003,mc=3004,gc=3005,vc=3006,Fm=3200,Bm=3201,Pi=0,Vm=1,qo=7680,Om=519,Er=35044,xs=35048,_c="300 es";class Rn{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const s=i.indexOf(e);s!==-1&&i.splice(s,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const i=n.slice(0);for(let s=0,l=i.length;s<l;s++)i[s].call(this,t);t.target=null}}}const jo=Math.PI/180,Xo=180/Math.PI,ve=[];for(let o=0;o<256;o++)ve[o]=(o<16?"0":"")+o.toString(16);const zm=typeof crypto!="undefined"&&"randomUUID"in crypto;function on(){if(zm)return crypto.randomUUID().toUpperCase();const o=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(ve[o&255]+ve[o>>8&255]+ve[o>>16&255]+ve[o>>24&255]+"-"+ve[t&255]+ve[t>>8&255]+"-"+ve[t>>16&15|64]+ve[t>>24&255]+"-"+ve[e&63|128]+ve[e>>8&255]+"-"+ve[e>>16&255]+ve[e>>24&255]+ve[n&255]+ve[n>>8&255]+ve[n>>16&255]+ve[n>>24&255]).toUpperCase()}function ke(o,t,e){return Math.max(t,Math.min(e,o))}function Um(o,t){return(o%t+t)%t}function Yo(o,t,e){return(1-e)*o+e*t}function xc(o){return(o&o-1)==0&&o!==0}function Hm(o){return Math.pow(2,Math.floor(Math.log(o)/Math.LN2))}class tt{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),s=this.x-t.x,l=this.y-t.y;return this.x=s*n-l*i+t.x,this.y=s*i+l*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}tt.prototype.isVector2=!0;class _e{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,s,l,h,u,d){const f=this.elements;return f[0]=t,f[1]=i,f[2]=h,f[3]=e,f[4]=s,f[5]=u,f[6]=n,f[7]=l,f[8]=d,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,l=n[0],h=n[3],u=n[6],d=n[1],f=n[4],g=n[7],m=n[2],v=n[5],b=n[8],w=i[0],M=i[3],x=i[6],_=i[1],R=i[4],C=i[7],P=i[2],N=i[5],T=i[8];return s[0]=l*w+h*_+u*P,s[3]=l*M+h*R+u*N,s[6]=l*x+h*C+u*T,s[1]=d*w+f*_+g*P,s[4]=d*M+f*R+g*N,s[7]=d*x+f*C+g*T,s[2]=m*w+v*_+b*P,s[5]=m*M+v*R+b*N,s[8]=m*x+v*C+b*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],l=t[4],h=t[5],u=t[6],d=t[7],f=t[8];return e*l*f-e*h*d-n*s*f+n*h*u+i*s*d-i*l*u}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],l=t[4],h=t[5],u=t[6],d=t[7],f=t[8],g=f*l-h*d,m=h*u-f*s,v=d*s-l*u,b=e*g+n*m+i*v;if(b===0)return this.set(0,0,0,0,0,0,0,0,0);const w=1/b;return t[0]=g*w,t[1]=(i*d-f*n)*w,t[2]=(h*n-i*l)*w,t[3]=m*w,t[4]=(f*e-i*u)*w,t[5]=(i*s-h*e)*w,t[6]=v*w,t[7]=(n*u-d*e)*w,t[8]=(l*e-n*s)*w,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,s,l,h){const u=Math.cos(s),d=Math.sin(s);return this.set(n*u,n*d,-n*(u*l+d*h)+l+t,-i*d,i*u,-i*(-d*l+u*h)+h+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,s=i[0],l=i[3],h=i[6],u=i[1],d=i[4],f=i[7];return i[0]=e*s+n*u,i[3]=e*l+n*d,i[6]=e*h+n*f,i[1]=-n*s+e*u,i[4]=-n*l+e*d,i[7]=-n*h+e*f,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}_e.prototype.isMatrix3=!0;function bc(o){if(o.length===0)return-1/0;let t=o[0];for(let e=1,n=o.length;e<n;++e)o[e]>t&&(t=o[e]);return t}function bs(o){return document.createElementNS("http://www.w3.org/1999/xhtml",o)}let Li;class Ri{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement=="undefined")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{Li===void 0&&(Li=bs("canvas")),Li.width=t.width,Li.height=t.height;const n=Li.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=Li}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let Gm=0;class xe extends Rn{constructor(t=xe.DEFAULT_IMAGE,e=xe.DEFAULT_MAPPING,n=Ue,i=Ue,s=je,l=ps,h=Pe,u=Pn,d=1,f=we){super();Object.defineProperty(this,"id",{value:Gm++}),this.uuid=on(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=s,this.minFilter=l,this.anisotropy=d,this.format=h,this.internalFormat=null,this.type=u,this.offset=new tt(0,0),this.repeat=new tt(1,1),this.center=new tt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new _e,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=f,this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=on()),!e&&t.images[i.uuid]===void 0){let s;if(Array.isArray(i)){s=[];for(let l=0,h=i.length;l<h;l++)i[l].isDataTexture?s.push(Zo(i[l].image)):s.push(Zo(i[l]))}else s=Zo(i);t.images[i.uuid]={uuid:i.uuid,url:s}}n.image=i.uuid}return e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==ec)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case Oo:t.x=t.x-Math.floor(t.x);break;case Ue:t.x=t.x<0?0:1;break;case zo:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case Oo:t.y=t.y-Math.floor(t.y);break;case Ue:t.y=t.y<0?0:1;break;case zo:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}xe.DEFAULT_IMAGE=void 0;xe.DEFAULT_MAPPING=ec;xe.prototype.isTexture=!0;function Zo(o){return typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&o instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&o instanceof ImageBitmap?Ri.getDataURL(o):o.data?{data:Array.prototype.slice.call(o.data),width:o.width,height:o.height,type:o.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class Qt{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=this.w,l=t.elements;return this.x=l[0]*e+l[4]*n+l[8]*i+l[12]*s,this.y=l[1]*e+l[5]*n+l[9]*i+l[13]*s,this.z=l[2]*e+l[6]*n+l[10]*i+l[14]*s,this.w=l[3]*e+l[7]*n+l[11]*i+l[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,s;const l=.01,h=.1,u=t.elements,d=u[0],f=u[4],g=u[8],m=u[1],v=u[5],b=u[9],w=u[2],M=u[6],x=u[10];if(Math.abs(f-m)<l&&Math.abs(g-w)<l&&Math.abs(b-M)<l){if(Math.abs(f+m)<h&&Math.abs(g+w)<h&&Math.abs(b+M)<h&&Math.abs(d+v+x-3)<h)return this.set(1,0,0,0),this;e=Math.PI;const R=(d+1)/2,C=(v+1)/2,P=(x+1)/2,N=(f+m)/4,T=(g+w)/4,H=(b+M)/4;return R>C&&R>P?R<l?(n=0,i=.707106781,s=.707106781):(n=Math.sqrt(R),i=N/n,s=T/n):C>P?C<l?(n=.707106781,i=0,s=.707106781):(i=Math.sqrt(C),n=N/i,s=H/i):P<l?(n=.707106781,i=.707106781,s=0):(s=Math.sqrt(P),n=T/s,i=H/s),this.set(n,i,s,e),this}let _=Math.sqrt((M-b)*(M-b)+(g-w)*(g-w)+(m-f)*(m-f));return Math.abs(_)<.001&&(_=1),this.x=(M-b)/_,this.y=(g-w)/_,this.z=(m-f)/_,this.w=Math.acos((d+v+x-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}Qt.prototype.isVector4=!0;class an extends Rn{constructor(t,e,n={}){super();this.width=t,this.height=e,this.depth=1,this.scissor=new Qt(0,0,t,e),this.scissorTest=!1,this.viewport=new Qt(0,0,t,e),this.texture=new xe(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:je,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){(this.width!==t||this.height!==e||this.depth!==n)&&(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image=Gl({},this.texture.image),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}an.prototype.isWebGLRenderTarget=!0;class Wm extends an{constructor(t,e,n){super(t,e);const i=this.texture;this.texture=[];for(let s=0;s<n;s++)this.texture[s]=i.clone()}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,s=this.texture.length;i<s;i++)this.texture[i].image.width=t,this.texture[i].image.height=e,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone();return this}}Wm.prototype.isWebGLMultipleRenderTargets=!0;class yc extends an{constructor(t,e,n){super(t,e,n);this.samples=4}copy(t){return super.copy.call(this,t),this.samples=t.samples,this}}yc.prototype.isWebGLMultisampleRenderTarget=!0;class Me{constructor(t=0,e=0,n=0,i=1){this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,i)}static slerpFlat(t,e,n,i,s,l,h){let u=n[i+0],d=n[i+1],f=n[i+2],g=n[i+3];const m=s[l+0],v=s[l+1],b=s[l+2],w=s[l+3];if(h===0){t[e+0]=u,t[e+1]=d,t[e+2]=f,t[e+3]=g;return}if(h===1){t[e+0]=m,t[e+1]=v,t[e+2]=b,t[e+3]=w;return}if(g!==w||u!==m||d!==v||f!==b){let M=1-h;const x=u*m+d*v+f*b+g*w,_=x>=0?1:-1,R=1-x*x;if(R>Number.EPSILON){const P=Math.sqrt(R),N=Math.atan2(P,x*_);M=Math.sin(M*N)/P,h=Math.sin(h*N)/P}const C=h*_;if(u=u*M+m*C,d=d*M+v*C,f=f*M+b*C,g=g*M+w*C,M===1-h){const P=1/Math.sqrt(u*u+d*d+f*f+g*g);u*=P,d*=P,f*=P,g*=P}}t[e]=u,t[e+1]=d,t[e+2]=f,t[e+3]=g}static multiplyQuaternionsFlat(t,e,n,i,s,l){const h=n[i],u=n[i+1],d=n[i+2],f=n[i+3],g=s[l],m=s[l+1],v=s[l+2],b=s[l+3];return t[e]=h*b+f*g+u*v-d*m,t[e+1]=u*b+f*m+d*g-h*v,t[e+2]=d*b+f*v+h*m-u*g,t[e+3]=f*b-h*g-u*m-d*v,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,s=t._z,l=t._order,h=Math.cos,u=Math.sin,d=h(n/2),f=h(i/2),g=h(s/2),m=u(n/2),v=u(i/2),b=u(s/2);switch(l){case"XYZ":this._x=m*f*g+d*v*b,this._y=d*v*g-m*f*b,this._z=d*f*b+m*v*g,this._w=d*f*g-m*v*b;break;case"YXZ":this._x=m*f*g+d*v*b,this._y=d*v*g-m*f*b,this._z=d*f*b-m*v*g,this._w=d*f*g+m*v*b;break;case"ZXY":this._x=m*f*g-d*v*b,this._y=d*v*g+m*f*b,this._z=d*f*b+m*v*g,this._w=d*f*g-m*v*b;break;case"ZYX":this._x=m*f*g-d*v*b,this._y=d*v*g+m*f*b,this._z=d*f*b-m*v*g,this._w=d*f*g+m*v*b;break;case"YZX":this._x=m*f*g+d*v*b,this._y=d*v*g+m*f*b,this._z=d*f*b-m*v*g,this._w=d*f*g-m*v*b;break;case"XZY":this._x=m*f*g-d*v*b,this._y=d*v*g-m*f*b,this._z=d*f*b+m*v*g,this._w=d*f*g+m*v*b;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+l)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],s=e[8],l=e[1],h=e[5],u=e[9],d=e[2],f=e[6],g=e[10],m=n+h+g;if(m>0){const v=.5/Math.sqrt(m+1);this._w=.25/v,this._x=(f-u)*v,this._y=(s-d)*v,this._z=(l-i)*v}else if(n>h&&n>g){const v=2*Math.sqrt(1+n-h-g);this._w=(f-u)/v,this._x=.25*v,this._y=(i+l)/v,this._z=(s+d)/v}else if(h>g){const v=2*Math.sqrt(1+h-n-g);this._w=(s-d)/v,this._x=(i+l)/v,this._y=.25*v,this._z=(u+f)/v}else{const v=2*Math.sqrt(1+g-n-h);this._w=(l-i)/v,this._x=(s+d)/v,this._y=(u+f)/v,this._z=.25*v}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(ke(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,s=t._z,l=t._w,h=e._x,u=e._y,d=e._z,f=e._w;return this._x=n*f+l*h+i*d-s*u,this._y=i*f+l*u+s*h-n*d,this._z=s*f+l*d+n*u-i*h,this._w=l*f-n*h-i*u-s*d,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,i=this._y,s=this._z,l=this._w;let h=l*t._w+n*t._x+i*t._y+s*t._z;if(h<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,h=-h):this.copy(t),h>=1)return this._w=l,this._x=n,this._y=i,this._z=s,this;const u=1-h*h;if(u<=Number.EPSILON){const v=1-e;return this._w=v*l+e*this._w,this._x=v*n+e*this._x,this._y=v*i+e*this._y,this._z=v*s+e*this._z,this.normalize(),this._onChangeCallback(),this}const d=Math.sqrt(u),f=Math.atan2(d,h),g=Math.sin((1-e)*f)/d,m=Math.sin(e*f)/d;return this._w=l*g+this._w*m,this._x=n*g+this._x*m,this._y=i*g+this._y*m,this._z=s*g+this._z*m,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),i=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(e*Math.cos(i),n*Math.sin(s),n*Math.cos(s),e*Math.sin(i))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Me.prototype.isQuaternion=!0;class L{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(wc.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(wc.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*i,this.y=s[1]*e+s[4]*n+s[7]*i,this.z=s[2]*e+s[5]*n+s[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,s=t.elements,l=1/(s[3]*e+s[7]*n+s[11]*i+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*i+s[12])*l,this.y=(s[1]*e+s[5]*n+s[9]*i+s[13])*l,this.z=(s[2]*e+s[6]*n+s[10]*i+s[14])*l,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,s=t.x,l=t.y,h=t.z,u=t.w,d=u*e+l*i-h*n,f=u*n+h*e-s*i,g=u*i+s*n-l*e,m=-s*e-l*n-h*i;return this.x=d*u+m*-s+f*-h-g*-l,this.y=f*u+m*-l+g*-s-d*-h,this.z=g*u+m*-h+d*-l-f*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i,this.y=s[1]*e+s[5]*n+s[9]*i,this.z=s[2]*e+s[6]*n+s[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,s=t.z,l=e.x,h=e.y,u=e.z;return this.x=i*u-s*h,this.y=s*l-n*u,this.z=n*h-i*l,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return $o.copy(this).projectOnVector(t),this.sub($o)}reflect(t){return this.sub($o.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(ke(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}L.prototype.isVector3=!0;const $o=new L,wc=new Me;class Ke{constructor(t=new L(1/0,1/0,1/0),e=new L(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,s=-1/0,l=-1/0,h=-1/0;for(let u=0,d=t.length;u<d;u+=3){const f=t[u],g=t[u+1],m=t[u+2];f<e&&(e=f),g<n&&(n=g),m<i&&(i=m),f>s&&(s=f),g>l&&(l=g),m>h&&(h=m)}return this.min.set(e,n,i),this.max.set(s,l,h),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,s=-1/0,l=-1/0,h=-1/0;for(let u=0,d=t.count;u<d;u++){const f=t.getX(u),g=t.getY(u),m=t.getZ(u);f<e&&(e=f),g<n&&(n=g),m<i&&(i=m),f>s&&(s=f),g>l&&(l=g),m>h&&(h=m)}return this.min.set(e,n,i),this.max.set(s,l,h),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Tr.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),Ko.copy(e.boundingBox),Ko.applyMatrix4(t.matrixWorld),this.union(Ko));const n=t.children;for(let i=0,s=n.length;i<s;i++)this.expandByObject(n[i]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,Tr),Tr.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Cr),ys.subVectors(this.max,Cr),Di.subVectors(t.a,Cr),Ii.subVectors(t.b,Cr),Ni.subVectors(t.c,Cr),Dn.subVectors(Ii,Di),In.subVectors(Ni,Ii),si.subVectors(Di,Ni);let e=[0,-Dn.z,Dn.y,0,-In.z,In.y,0,-si.z,si.y,Dn.z,0,-Dn.x,In.z,0,-In.x,si.z,0,-si.x,-Dn.y,Dn.x,0,-In.y,In.x,0,-si.y,si.x,0];return!Jo(e,Di,Ii,Ni,ys)||(e=[1,0,0,0,1,0,0,0,1],!Jo(e,Di,Ii,Ni,ys))?!1:(ws.crossVectors(Dn,In),e=[ws.x,ws.y,ws.z],Jo(e,Di,Ii,Ni,ys))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Tr.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(Tr).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(mn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),mn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),mn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),mn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),mn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),mn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),mn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),mn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(mn),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}Ke.prototype.isBox3=!0;const mn=[new L,new L,new L,new L,new L,new L,new L,new L],Tr=new L,Ko=new Ke,Di=new L,Ii=new L,Ni=new L,Dn=new L,In=new L,si=new L,Cr=new L,ys=new L,ws=new L,oi=new L;function Jo(o,t,e,n,i){for(let s=0,l=o.length-3;s<=l;s+=3){oi.fromArray(o,s);const h=i.x*Math.abs(oi.x)+i.y*Math.abs(oi.y)+i.z*Math.abs(oi.z),u=t.dot(oi),d=e.dot(oi),f=n.dot(oi);if(Math.max(-Math.max(u,d,f),Math.min(u,d,f))>h)return!1}return!0}const qm=new Ke,Mc=new L,Qo=new L,ta=new L;class ki{constructor(t=new L,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):qm.setFromPoints(t).getCenter(n);let i=0;for(let s=0,l=t.length;s<l;s++)i=Math.max(i,n.distanceToSquared(t[s]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){ta.subVectors(t,this.center);const e=ta.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),i=(n-this.radius)*.5;this.center.add(ta.multiplyScalar(i/n)),this.radius+=i}return this}union(t){return Qo.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Mc.copy(t.center).add(Qo)),this.expandByPoint(Mc.copy(t.center).sub(Qo)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const gn=new L,ea=new L,Ms=new L,Nn=new L,na=new L,Ss=new L,ia=new L;class Fi{constructor(t=new L,e=new L(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,gn)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=gn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(gn.copy(this.direction).multiplyScalar(e).add(this.origin),gn.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){ea.copy(t).add(e).multiplyScalar(.5),Ms.copy(e).sub(t).normalize(),Nn.copy(this.origin).sub(ea);const s=t.distanceTo(e)*.5,l=-this.direction.dot(Ms),h=Nn.dot(this.direction),u=-Nn.dot(Ms),d=Nn.lengthSq(),f=Math.abs(1-l*l);let g,m,v,b;if(f>0)if(g=l*u-h,m=l*h-u,b=s*f,g>=0)if(m>=-b)if(m<=b){const w=1/f;g*=w,m*=w,v=g*(g+l*m+2*h)+m*(l*g+m+2*u)+d}else m=s,g=Math.max(0,-(l*m+h)),v=-g*g+m*(m+2*u)+d;else m=-s,g=Math.max(0,-(l*m+h)),v=-g*g+m*(m+2*u)+d;else m<=-b?(g=Math.max(0,-(-l*s+h)),m=g>0?-s:Math.min(Math.max(-s,-u),s),v=-g*g+m*(m+2*u)+d):m<=b?(g=0,m=Math.min(Math.max(-s,-u),s),v=m*(m+2*u)+d):(g=Math.max(0,-(l*s+h)),m=g>0?s:Math.min(Math.max(-s,-u),s),v=-g*g+m*(m+2*u)+d);else m=l>0?-s:s,g=Math.max(0,-(l*m+h)),v=-g*g+m*(m+2*u)+d;return n&&n.copy(this.direction).multiplyScalar(g).add(this.origin),i&&i.copy(Ms).multiplyScalar(m).add(ea),v}intersectSphere(t,e){gn.subVectors(t.center,this.origin);const n=gn.dot(this.direction),i=gn.dot(gn)-n*n,s=t.radius*t.radius;if(i>s)return null;const l=Math.sqrt(s-i),h=n-l,u=n+l;return h<0&&u<0?null:h<0?this.at(u,e):this.at(h,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,s,l,h,u;const d=1/this.direction.x,f=1/this.direction.y,g=1/this.direction.z,m=this.origin;return d>=0?(n=(t.min.x-m.x)*d,i=(t.max.x-m.x)*d):(n=(t.max.x-m.x)*d,i=(t.min.x-m.x)*d),f>=0?(s=(t.min.y-m.y)*f,l=(t.max.y-m.y)*f):(s=(t.max.y-m.y)*f,l=(t.min.y-m.y)*f),n>l||s>i||((s>n||n!==n)&&(n=s),(l<i||i!==i)&&(i=l),g>=0?(h=(t.min.z-m.z)*g,u=(t.max.z-m.z)*g):(h=(t.max.z-m.z)*g,u=(t.min.z-m.z)*g),n>u||h>i)||((h>n||n!==n)&&(n=h),(u<i||i!==i)&&(i=u),i<0)?null:this.at(n>=0?n:i,e)}intersectsBox(t){return this.intersectBox(t,gn)!==null}intersectTriangle(t,e,n,i,s){na.subVectors(e,t),Ss.subVectors(n,t),ia.crossVectors(na,Ss);let l=this.direction.dot(ia),h;if(l>0){if(i)return null;h=1}else if(l<0)h=-1,l=-l;else return null;Nn.subVectors(this.origin,t);const u=h*this.direction.dot(Ss.crossVectors(Nn,Ss));if(u<0)return null;const d=h*this.direction.dot(na.cross(Nn));if(d<0||u+d>l)return null;const f=-h*Nn.dot(ia);return f<0?null:this.at(f/l,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class It{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,s,l,h,u,d,f,g,m,v,b,w,M){const x=this.elements;return x[0]=t,x[4]=e,x[8]=n,x[12]=i,x[1]=s,x[5]=l,x[9]=h,x[13]=u,x[2]=d,x[6]=f,x[10]=g,x[14]=m,x[3]=v,x[7]=b,x[11]=w,x[15]=M,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new It().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/Bi.setFromMatrixColumn(t,0).length(),s=1/Bi.setFromMatrixColumn(t,1).length(),l=1/Bi.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*l,e[9]=n[9]*l,e[10]=n[10]*l,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,s=t.z,l=Math.cos(n),h=Math.sin(n),u=Math.cos(i),d=Math.sin(i),f=Math.cos(s),g=Math.sin(s);if(t.order==="XYZ"){const m=l*f,v=l*g,b=h*f,w=h*g;e[0]=u*f,e[4]=-u*g,e[8]=d,e[1]=v+b*d,e[5]=m-w*d,e[9]=-h*u,e[2]=w-m*d,e[6]=b+v*d,e[10]=l*u}else if(t.order==="YXZ"){const m=u*f,v=u*g,b=d*f,w=d*g;e[0]=m+w*h,e[4]=b*h-v,e[8]=l*d,e[1]=l*g,e[5]=l*f,e[9]=-h,e[2]=v*h-b,e[6]=w+m*h,e[10]=l*u}else if(t.order==="ZXY"){const m=u*f,v=u*g,b=d*f,w=d*g;e[0]=m-w*h,e[4]=-l*g,e[8]=b+v*h,e[1]=v+b*h,e[5]=l*f,e[9]=w-m*h,e[2]=-l*d,e[6]=h,e[10]=l*u}else if(t.order==="ZYX"){const m=l*f,v=l*g,b=h*f,w=h*g;e[0]=u*f,e[4]=b*d-v,e[8]=m*d+w,e[1]=u*g,e[5]=w*d+m,e[9]=v*d-b,e[2]=-d,e[6]=h*u,e[10]=l*u}else if(t.order==="YZX"){const m=l*u,v=l*d,b=h*u,w=h*d;e[0]=u*f,e[4]=w-m*g,e[8]=b*g+v,e[1]=g,e[5]=l*f,e[9]=-h*f,e[2]=-d*f,e[6]=v*g+b,e[10]=m-w*g}else if(t.order==="XZY"){const m=l*u,v=l*d,b=h*u,w=h*d;e[0]=u*f,e[4]=-g,e[8]=d*f,e[1]=m*g+w,e[5]=l*f,e[9]=v*g-b,e[2]=b*g-v,e[6]=h*f,e[10]=w*g+m}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(jm,t,Xm)}lookAt(t,e,n){const i=this.elements;return He.subVectors(t,e),He.lengthSq()===0&&(He.z=1),He.normalize(),kn.crossVectors(n,He),kn.lengthSq()===0&&(Math.abs(n.z)===1?He.x+=1e-4:He.z+=1e-4,He.normalize(),kn.crossVectors(n,He)),kn.normalize(),Es.crossVectors(He,kn),i[0]=kn.x,i[4]=Es.x,i[8]=He.x,i[1]=kn.y,i[5]=Es.y,i[9]=He.y,i[2]=kn.z,i[6]=Es.z,i[10]=He.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,s=this.elements,l=n[0],h=n[4],u=n[8],d=n[12],f=n[1],g=n[5],m=n[9],v=n[13],b=n[2],w=n[6],M=n[10],x=n[14],_=n[3],R=n[7],C=n[11],P=n[15],N=i[0],T=i[4],H=i[8],nt=i[12],Y=i[1],k=i[5],ht=i[9],G=i[13],j=i[2],W=i[6],B=i[10],X=i[14],at=i[3],yt=i[7],bt=i[11],mt=i[15];return s[0]=l*N+h*Y+u*j+d*at,s[4]=l*T+h*k+u*W+d*yt,s[8]=l*H+h*ht+u*B+d*bt,s[12]=l*nt+h*G+u*X+d*mt,s[1]=f*N+g*Y+m*j+v*at,s[5]=f*T+g*k+m*W+v*yt,s[9]=f*H+g*ht+m*B+v*bt,s[13]=f*nt+g*G+m*X+v*mt,s[2]=b*N+w*Y+M*j+x*at,s[6]=b*T+w*k+M*W+x*yt,s[10]=b*H+w*ht+M*B+x*bt,s[14]=b*nt+w*G+M*X+x*mt,s[3]=_*N+R*Y+C*j+P*at,s[7]=_*T+R*k+C*W+P*yt,s[11]=_*H+R*ht+C*B+P*bt,s[15]=_*nt+R*G+C*X+P*mt,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],s=t[12],l=t[1],h=t[5],u=t[9],d=t[13],f=t[2],g=t[6],m=t[10],v=t[14],b=t[3],w=t[7],M=t[11],x=t[15];return b*(+s*u*g-i*d*g-s*h*m+n*d*m+i*h*v-n*u*v)+w*(+e*u*v-e*d*m+s*l*m-i*l*v+i*d*f-s*u*f)+M*(+e*d*g-e*h*v-s*l*g+n*l*v+s*h*f-n*d*f)+x*(-i*h*f-e*u*g+e*h*m+i*l*g-n*l*m+n*u*f)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],s=t[3],l=t[4],h=t[5],u=t[6],d=t[7],f=t[8],g=t[9],m=t[10],v=t[11],b=t[12],w=t[13],M=t[14],x=t[15],_=g*M*d-w*m*d+w*u*v-h*M*v-g*u*x+h*m*x,R=b*m*d-f*M*d-b*u*v+l*M*v+f*u*x-l*m*x,C=f*w*d-b*g*d+b*h*v-l*w*v-f*h*x+l*g*x,P=b*g*u-f*w*u-b*h*m+l*w*m+f*h*M-l*g*M,N=e*_+n*R+i*C+s*P;if(N===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/N;return t[0]=_*T,t[1]=(w*m*s-g*M*s-w*i*v+n*M*v+g*i*x-n*m*x)*T,t[2]=(h*M*s-w*u*s+w*i*d-n*M*d-h*i*x+n*u*x)*T,t[3]=(g*u*s-h*m*s-g*i*d+n*m*d+h*i*v-n*u*v)*T,t[4]=R*T,t[5]=(f*M*s-b*m*s+b*i*v-e*M*v-f*i*x+e*m*x)*T,t[6]=(b*u*s-l*M*s-b*i*d+e*M*d+l*i*x-e*u*x)*T,t[7]=(l*m*s-f*u*s+f*i*d-e*m*d-l*i*v+e*u*v)*T,t[8]=C*T,t[9]=(b*g*s-f*w*s-b*n*v+e*w*v+f*n*x-e*g*x)*T,t[10]=(l*w*s-b*h*s+b*n*d-e*w*d-l*n*x+e*h*x)*T,t[11]=(f*h*s-l*g*s-f*n*d+e*g*d+l*n*v-e*h*v)*T,t[12]=P*T,t[13]=(f*w*i-b*g*i+b*n*m-e*w*m-f*n*M+e*g*M)*T,t[14]=(b*h*i-l*w*i-b*n*u+e*w*u+l*n*M-e*h*M)*T,t[15]=(l*g*i-f*h*i+f*n*u-e*g*u-l*n*m+e*h*m)*T,this}scale(t){const e=this.elements,n=t.x,i=t.y,s=t.z;return e[0]*=n,e[4]*=i,e[8]*=s,e[1]*=n,e[5]*=i,e[9]*=s,e[2]*=n,e[6]*=i,e[10]*=s,e[3]*=n,e[7]*=i,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),s=1-n,l=t.x,h=t.y,u=t.z,d=s*l,f=s*h;return this.set(d*l+n,d*h-i*u,d*u+i*h,0,d*h+i*u,f*h+n,f*u-i*l,0,d*u-i*h,f*u+i*l,s*u*u+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,s,l){return this.set(1,n,s,0,t,1,l,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,s=e._x,l=e._y,h=e._z,u=e._w,d=s+s,f=l+l,g=h+h,m=s*d,v=s*f,b=s*g,w=l*f,M=l*g,x=h*g,_=u*d,R=u*f,C=u*g,P=n.x,N=n.y,T=n.z;return i[0]=(1-(w+x))*P,i[1]=(v+C)*P,i[2]=(b-R)*P,i[3]=0,i[4]=(v-C)*N,i[5]=(1-(m+x))*N,i[6]=(M+_)*N,i[7]=0,i[8]=(b+R)*T,i[9]=(M-_)*T,i[10]=(1-(m+w))*T,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let s=Bi.set(i[0],i[1],i[2]).length();const l=Bi.set(i[4],i[5],i[6]).length(),h=Bi.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),t.x=i[12],t.y=i[13],t.z=i[14],Je.copy(this);const d=1/s,f=1/l,g=1/h;return Je.elements[0]*=d,Je.elements[1]*=d,Je.elements[2]*=d,Je.elements[4]*=f,Je.elements[5]*=f,Je.elements[6]*=f,Je.elements[8]*=g,Je.elements[9]*=g,Je.elements[10]*=g,e.setFromRotationMatrix(Je),n.x=s,n.y=l,n.z=h,this}makePerspective(t,e,n,i,s,l){l===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const h=this.elements,u=2*s/(e-t),d=2*s/(n-i),f=(e+t)/(e-t),g=(n+i)/(n-i),m=-(l+s)/(l-s),v=-2*l*s/(l-s);return h[0]=u,h[4]=0,h[8]=f,h[12]=0,h[1]=0,h[5]=d,h[9]=g,h[13]=0,h[2]=0,h[6]=0,h[10]=m,h[14]=v,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,e,n,i,s,l){const h=this.elements,u=1/(e-t),d=1/(n-i),f=1/(l-s),g=(e+t)*u,m=(n+i)*d,v=(l+s)*f;return h[0]=2*u,h[4]=0,h[8]=0,h[12]=-g,h[1]=0,h[5]=2*d,h[9]=0,h[13]=-m,h[2]=0,h[6]=0,h[10]=-2*f,h[14]=-v,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}It.prototype.isMatrix4=!0;const Bi=new L,Je=new It,jm=new L(0,0,0),Xm=new L(1,1,1),kn=new L,Es=new L,He=new L,Sc=new It,Ec=new Me;class Vi{constructor(t=0,e=0,n=0,i=Vi.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,s=i[0],l=i[4],h=i[8],u=i[1],d=i[5],f=i[9],g=i[2],m=i[6],v=i[10];switch(e){case"XYZ":this._y=Math.asin(ke(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(-f,v),this._z=Math.atan2(-l,s)):(this._x=Math.atan2(m,d),this._z=0);break;case"YXZ":this._x=Math.asin(-ke(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(h,v),this._z=Math.atan2(u,d)):(this._y=Math.atan2(-g,s),this._z=0);break;case"ZXY":this._x=Math.asin(ke(m,-1,1)),Math.abs(m)<.9999999?(this._y=Math.atan2(-g,v),this._z=Math.atan2(-l,d)):(this._y=0,this._z=Math.atan2(u,s));break;case"ZYX":this._y=Math.asin(-ke(g,-1,1)),Math.abs(g)<.9999999?(this._x=Math.atan2(m,v),this._z=Math.atan2(u,s)):(this._x=0,this._z=Math.atan2(-l,d));break;case"YZX":this._z=Math.asin(ke(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(-f,d),this._y=Math.atan2(-g,s)):(this._x=0,this._y=Math.atan2(h,v));break;case"XZY":this._z=Math.asin(-ke(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(m,d),this._y=Math.atan2(h,s)):(this._x=Math.atan2(-f,v),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Sc.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Sc,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Ec.setFromEuler(this),this.setFromQuaternion(Ec,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new L(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Vi.prototype.isEuler=!0;Vi.DefaultOrder="XYZ";Vi.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Ym{constructor(){this.mask=1|0}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=4294967295|0}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}}let Zm=0;const Tc=new L,Oi=new Me,vn=new It,Ts=new L,Ar=new L,$m=new L,Km=new Me,Cc=new L(1,0,0),Ac=new L(0,1,0),Pc=new L(0,0,1),Jm={type:"added"},Lc={type:"removed"};class $t extends Rn{constructor(){super();Object.defineProperty(this,"id",{value:Zm++}),this.uuid=on(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=$t.DefaultUp.clone();const t=new L,e=new Vi,n=new Me,i=new L(1,1,1);function s(){n.setFromEuler(e,!1)}function l(){e.setFromQuaternion(n,void 0,!1)}e._onChange(s),n._onChange(l),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new It},normalMatrix:{value:new _e}}),this.matrix=new It,this.matrixWorld=new It,this.matrixAutoUpdate=$t.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Ym,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Oi.setFromAxisAngle(t,e),this.quaternion.multiply(Oi),this}rotateOnWorldAxis(t,e){return Oi.setFromAxisAngle(t,e),this.quaternion.premultiply(Oi),this}rotateX(t){return this.rotateOnAxis(Cc,t)}rotateY(t){return this.rotateOnAxis(Ac,t)}rotateZ(t){return this.rotateOnAxis(Pc,t)}translateOnAxis(t,e){return Tc.copy(t).applyQuaternion(this.quaternion),this.position.add(Tc.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Cc,t)}translateY(t){return this.translateOnAxis(Ac,t)}translateZ(t){return this.translateOnAxis(Pc,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(vn.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?Ts.copy(t):Ts.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Ar.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?vn.lookAt(Ar,Ts,this.up):vn.lookAt(Ts,Ar,this.up),this.quaternion.setFromRotationMatrix(vn),i&&(vn.extractRotation(i.matrixWorld),Oi.setFromRotationMatrix(vn),this.quaternion.premultiply(Oi.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(Jm)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Lc)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(Lc)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),vn.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),vn.multiply(t.parent.matrixWorld)),t.applyMatrix4(vn),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const l=this.children[n].getObjectByProperty(t,e);if(l!==void 0)return l}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ar,t,$m),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ar,Km,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const i=this.children;for(let s=0,l=i.length;s<l;s++)i[s].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function s(h,u){return h[u.uuid]===void 0&&(h[u.uuid]=u.toJSON(t)),u.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(t.geometries,this.geometry);const h=this.geometry.parameters;if(h!==void 0&&h.shapes!==void 0){const u=h.shapes;if(Array.isArray(u))for(let d=0,f=u.length;d<f;d++){const g=u[d];s(t.shapes,g)}else s(t.shapes,u)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const h=[];for(let u=0,d=this.material.length;u<d;u++)h.push(s(t.materials,this.material[u]));i.material=h}else i.material=s(t.materials,this.material);if(this.children.length>0){i.children=[];for(let h=0;h<this.children.length;h++)i.children.push(this.children[h].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let h=0;h<this.animations.length;h++){const u=this.animations[h];i.animations.push(s(t.animations,u))}}if(e){const h=l(t.geometries),u=l(t.materials),d=l(t.textures),f=l(t.images),g=l(t.shapes),m=l(t.skeletons),v=l(t.animations);h.length>0&&(n.geometries=h),u.length>0&&(n.materials=u),d.length>0&&(n.textures=d),f.length>0&&(n.images=f),g.length>0&&(n.shapes=g),m.length>0&&(n.skeletons=m),v.length>0&&(n.animations=v)}return n.object=i,n;function l(h){const u=[];for(const d in h){const f=h[d];delete f.metadata,u.push(f)}return u}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const i=t.children[n];this.add(i.clone())}return this}}$t.DefaultUp=new L(0,1,0);$t.DefaultMatrixAutoUpdate=!0;$t.prototype.isObject3D=!0;const Qe=new L,_n=new L,ra=new L,xn=new L,zi=new L,Ui=new L,Rc=new L,sa=new L,oa=new L,aa=new L;class ue{constructor(t=new L,e=new L,n=new L){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),Qe.subVectors(t,e),i.cross(Qe);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(t,e,n,i,s){Qe.subVectors(i,e),_n.subVectors(n,e),ra.subVectors(t,e);const l=Qe.dot(Qe),h=Qe.dot(_n),u=Qe.dot(ra),d=_n.dot(_n),f=_n.dot(ra),g=l*d-h*h;if(g===0)return s.set(-2,-1,-1);const m=1/g,v=(d*u-h*f)*m,b=(l*f-h*u)*m;return s.set(1-v-b,b,v)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,xn),xn.x>=0&&xn.y>=0&&xn.x+xn.y<=1}static getUV(t,e,n,i,s,l,h,u){return this.getBarycoord(t,e,n,i,xn),u.set(0,0),u.addScaledVector(s,xn.x),u.addScaledVector(l,xn.y),u.addScaledVector(h,xn.z),u}static isFrontFacing(t,e,n,i){return Qe.subVectors(n,e),_n.subVectors(t,e),Qe.cross(_n).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,n,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Qe.subVectors(this.c,this.b),_n.subVectors(this.a,this.b),Qe.cross(_n).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return ue.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return ue.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,s){return ue.getUV(t,this.a,this.b,this.c,e,n,i,s)}containsPoint(t){return ue.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return ue.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,s=this.c;let l,h;zi.subVectors(i,n),Ui.subVectors(s,n),sa.subVectors(t,n);const u=zi.dot(sa),d=Ui.dot(sa);if(u<=0&&d<=0)return e.copy(n);oa.subVectors(t,i);const f=zi.dot(oa),g=Ui.dot(oa);if(f>=0&&g<=f)return e.copy(i);const m=u*g-f*d;if(m<=0&&u>=0&&f<=0)return l=u/(u-f),e.copy(n).addScaledVector(zi,l);aa.subVectors(t,s);const v=zi.dot(aa),b=Ui.dot(aa);if(b>=0&&v<=b)return e.copy(s);const w=v*d-u*b;if(w<=0&&d>=0&&b<=0)return h=d/(d-b),e.copy(n).addScaledVector(Ui,h);const M=f*b-v*g;if(M<=0&&g-f>=0&&v-b>=0)return Rc.subVectors(s,i),h=(g-f)/(g-f+(v-b)),e.copy(i).addScaledVector(Rc,h);const x=1/(M+w+m);return l=w*x,h=m*x,e.copy(n).addScaledVector(zi,l).addScaledVector(Ui,h)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let Qm=0;class Se extends Rn{constructor(){super();Object.defineProperty(this,"id",{value:Qm++}),this.uuid=on(),this.name="",this.type="Material",this.fog=!0,this.blending=wr,this.side=yr,this.vertexColors=!1,this.opacity=1,this.format=Pe,this.transparent=!1,this.blendSrc=Ql,this.blendDst=tc,this.blendEquation=Mi,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=ko,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Om,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=qo,this.stencilZFail=qo,this.stencilZPass=qo,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===Xl;continue}const i=this[e];if(i===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenTint&&this.sheenTint.isColor&&(n.sheenTint=this.sheenTint.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularTint&&this.specularTint.isColor&&(n.specularTint=this.specularTint.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularTintMap&&this.specularTintMap.isTexture&&(n.specularTintMap=this.specularTintMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationTint!==void 0&&(n.attenuationTint=this.attenuationTint.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==wr&&(n.blending=this.blending),this.side!==yr&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==Pe&&(n.format=this.format),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function i(s){const l=[];for(const h in s){const u=s[h];delete u.metadata,l.push(u)}return l}if(e){const s=i(t.textures),l=i(t.images);s.length>0&&(n.textures=s),l.length>0&&(n.images=l)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.format=t.format,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const i=e.length;n=new Array(i);for(let s=0;s!==i;++s)n[s]=e[s].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}Se.prototype.isMaterial=!0;const Dc={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},tn={h:0,s:0,l:0},Cs={h:0,s:0,l:0};function la(o,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?o+(t-o)*6*e:e<1/2?t:e<2/3?o+(t-o)*6*(2/3-e):o}function ca(o){return o<.04045?o*.0773993808:Math.pow(o*.9478672986+.0521327014,2.4)}function ha(o){return o<.0031308?o*12.92:1.055*Math.pow(o,.41666)-.055}class Ct{constructor(t,e,n){return e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=Um(t,1),e=ke(e,0,1),n=ke(n,0,1),e===0)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,s=2*n-i;this.r=la(s,i,t+1/3),this.g=la(s,i,t),this.b=la(s,i,t-1/3)}return this}setStyle(t){function e(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let i;const s=n[1],l=n[2];switch(s){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,e(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,e(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l)){const h=parseFloat(i[1])/360,u=parseInt(i[2],10)/100,d=parseInt(i[3],10)/100;return e(i[4]),this.setHSL(h,u,d)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const i=n[1],s=i.length;if(s===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Dc[t.toLowerCase()];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=ca(t.r),this.g=ca(t.g),this.b=ca(t.b),this}copyLinearToSRGB(t){return this.r=ha(t.r),this.g=ha(t.g),this.b=ha(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,n=this.g,i=this.b,s=Math.max(e,n,i),l=Math.min(e,n,i);let h,u;const d=(l+s)/2;if(l===s)h=0,u=0;else{const f=s-l;switch(u=d<=.5?f/(s+l):f/(2-s-l),s){case e:h=(n-i)/f+(n<i?6:0);break;case n:h=(i-e)/f+2;break;case i:h=(e-n)/f+4;break}h/=6}return t.h=h,t.s=u,t.l=d,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,e,n){return this.getHSL(tn),tn.h+=t,tn.s+=e,tn.l+=n,this.setHSL(tn.h,tn.s,tn.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(tn),t.getHSL(Cs);const n=Yo(tn.h,Cs.h,e),i=Yo(tn.s,Cs.s,e),s=Yo(tn.l,Cs.l,e);return this.setHSL(n,i,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Ct.NAMES=Dc;Ct.prototype.isColor=!0;Ct.prototype.r=1;Ct.prototype.g=1;Ct.prototype.b=1;class ua extends Se{constructor(t){super();this.type="MeshBasicMaterial",this.color=new Ct(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=cs,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}ua.prototype.isMeshBasicMaterial=!0;const ee=new L,As=new tt;class pe{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n===!0,this.usage=Er,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let l=t[i];l===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),l=new Ct),e[n++]=l.r,e[n++]=l.g,e[n++]=l.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let l=t[i];l===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),l=new tt),e[n++]=l.x,e[n++]=l.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let l=t[i];l===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),l=new L),e[n++]=l.x,e[n++]=l.y,e[n++]=l.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let i=0,s=t.length;i<s;i++){let l=t[i];l===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),l=new Qt),e[n++]=l.x,e[n++]=l.y,e[n++]=l.z,e[n++]=l.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)As.fromBufferAttribute(this,e),As.applyMatrix3(t),this.setXY(e,As.x,As.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)ee.fromBufferAttribute(this,e),ee.applyMatrix3(t),this.setXYZ(e,ee.x,ee.y,ee.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)ee.x=this.getX(e),ee.y=this.getY(e),ee.z=this.getZ(e),ee.applyMatrix4(t),this.setXYZ(e,ee.x,ee.y,ee.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)ee.x=this.getX(e),ee.y=this.getY(e),ee.z=this.getZ(e),ee.applyNormalMatrix(t),this.setXYZ(e,ee.x,ee.y,ee.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)ee.x=this.getX(e),ee.y=this.getY(e),ee.z=this.getZ(e),ee.transformDirection(t),this.setXYZ(e,ee.x,ee.y,ee.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==Er&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}}pe.prototype.isBufferAttribute=!0;class Ic extends pe{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Nc extends pe{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class tg extends pe{constructor(t,e,n){super(new Uint16Array(t),e,n)}}tg.prototype.isFloat16BufferAttribute=!0;class me extends pe{constructor(t,e,n){super(new Float32Array(t),e,n)}}let eg=0;const Xe=new It,da=new $t,Hi=new L,Ge=new Ke,Pr=new Ke,ge=new L;class ae extends Rn{constructor(){super();Object.defineProperty(this,"id",{value:eg++}),this.uuid=on(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(bc(t)>65535?Nc:Ic)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new _e().getNormalMatrix(t);n.applyNormalMatrix(s),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return Xe.makeRotationFromQuaternion(t),this.applyMatrix4(Xe),this}rotateX(t){return Xe.makeRotationX(t),this.applyMatrix4(Xe),this}rotateY(t){return Xe.makeRotationY(t),this.applyMatrix4(Xe),this}rotateZ(t){return Xe.makeRotationZ(t),this.applyMatrix4(Xe),this}translate(t,e,n){return Xe.makeTranslation(t,e,n),this.applyMatrix4(Xe),this}scale(t,e,n){return Xe.makeScale(t,e,n),this.applyMatrix4(Xe),this}lookAt(t){return da.lookAt(t),da.updateMatrix(),this.applyMatrix4(da.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Hi).negate(),this.translate(Hi.x,Hi.y,Hi.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const s=t[n];e.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new me(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ke);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new L(-1/0,-1/0,-1/0),new L(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++){const s=e[n];Ge.setFromBufferAttribute(s),this.morphTargetsRelative?(ge.addVectors(this.boundingBox.min,Ge.min),this.boundingBox.expandByPoint(ge),ge.addVectors(this.boundingBox.max,Ge.max),this.boundingBox.expandByPoint(ge)):(this.boundingBox.expandByPoint(Ge.min),this.boundingBox.expandByPoint(Ge.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ki);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new L,1/0);return}if(t){const n=this.boundingSphere.center;if(Ge.setFromBufferAttribute(t),e)for(let s=0,l=e.length;s<l;s++){const h=e[s];Pr.setFromBufferAttribute(h),this.morphTargetsRelative?(ge.addVectors(Ge.min,Pr.min),Ge.expandByPoint(ge),ge.addVectors(Ge.max,Pr.max),Ge.expandByPoint(ge)):(Ge.expandByPoint(Pr.min),Ge.expandByPoint(Pr.max))}Ge.getCenter(n);let i=0;for(let s=0,l=t.count;s<l;s++)ge.fromBufferAttribute(t,s),i=Math.max(i,n.distanceToSquared(ge));if(e)for(let s=0,l=e.length;s<l;s++){const h=e[s],u=this.morphTargetsRelative;for(let d=0,f=h.count;d<f;d++)ge.fromBufferAttribute(h,d),u&&(Hi.fromBufferAttribute(t,d),ge.add(Hi)),i=Math.max(i,n.distanceToSquared(ge))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.array,i=e.position.array,s=e.normal.array,l=e.uv.array,h=i.length/3;e.tangent===void 0&&this.setAttribute("tangent",new pe(new Float32Array(4*h),4));const u=e.tangent.array,d=[],f=[];for(let Y=0;Y<h;Y++)d[Y]=new L,f[Y]=new L;const g=new L,m=new L,v=new L,b=new tt,w=new tt,M=new tt,x=new L,_=new L;function R(Y,k,ht){g.fromArray(i,Y*3),m.fromArray(i,k*3),v.fromArray(i,ht*3),b.fromArray(l,Y*2),w.fromArray(l,k*2),M.fromArray(l,ht*2),m.sub(g),v.sub(g),w.sub(b),M.sub(b);const G=1/(w.x*M.y-M.x*w.y);!isFinite(G)||(x.copy(m).multiplyScalar(M.y).addScaledVector(v,-w.y).multiplyScalar(G),_.copy(v).multiplyScalar(w.x).addScaledVector(m,-M.x).multiplyScalar(G),d[Y].add(x),d[k].add(x),d[ht].add(x),f[Y].add(_),f[k].add(_),f[ht].add(_))}let C=this.groups;C.length===0&&(C=[{start:0,count:n.length}]);for(let Y=0,k=C.length;Y<k;++Y){const ht=C[Y],G=ht.start,j=ht.count;for(let W=G,B=G+j;W<B;W+=3)R(n[W+0],n[W+1],n[W+2])}const P=new L,N=new L,T=new L,H=new L;function nt(Y){T.fromArray(s,Y*3),H.copy(T);const k=d[Y];P.copy(k),P.sub(T.multiplyScalar(T.dot(k))).normalize(),N.crossVectors(H,k);const G=N.dot(f[Y])<0?-1:1;u[Y*4]=P.x,u[Y*4+1]=P.y,u[Y*4+2]=P.z,u[Y*4+3]=G}for(let Y=0,k=C.length;Y<k;++Y){const ht=C[Y],G=ht.start,j=ht.count;for(let W=G,B=G+j;W<B;W+=3)nt(n[W+0]),nt(n[W+1]),nt(n[W+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new pe(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let m=0,v=n.count;m<v;m++)n.setXYZ(m,0,0,0);const i=new L,s=new L,l=new L,h=new L,u=new L,d=new L,f=new L,g=new L;if(t)for(let m=0,v=t.count;m<v;m+=3){const b=t.getX(m+0),w=t.getX(m+1),M=t.getX(m+2);i.fromBufferAttribute(e,b),s.fromBufferAttribute(e,w),l.fromBufferAttribute(e,M),f.subVectors(l,s),g.subVectors(i,s),f.cross(g),h.fromBufferAttribute(n,b),u.fromBufferAttribute(n,w),d.fromBufferAttribute(n,M),h.add(f),u.add(f),d.add(f),n.setXYZ(b,h.x,h.y,h.z),n.setXYZ(w,u.x,u.y,u.z),n.setXYZ(M,d.x,d.y,d.z)}else for(let m=0,v=e.count;m<v;m+=3)i.fromBufferAttribute(e,m+0),s.fromBufferAttribute(e,m+1),l.fromBufferAttribute(e,m+2),f.subVectors(l,s),g.subVectors(i,s),f.cross(g),n.setXYZ(m+0,f.x,f.y,f.z),n.setXYZ(m+1,f.x,f.y,f.z),n.setXYZ(m+2,f.x,f.y,f.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(t.attributes[i]===void 0)continue;const l=n[i].array,h=t.attributes[i],u=h.array,d=h.itemSize*e,f=Math.min(u.length,l.length-d);for(let g=0,m=d;g<f;g++,m++)l[m]=u[g]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)ge.fromBufferAttribute(t,e),ge.normalize(),t.setXYZ(e,ge.x,ge.y,ge.z)}toNonIndexed(){function t(h,u){const d=h.array,f=h.itemSize,g=h.normalized,m=new d.constructor(u.length*f);let v=0,b=0;for(let w=0,M=u.length;w<M;w++){h.isInterleavedBufferAttribute?v=u[w]*h.data.stride+h.offset:v=u[w]*f;for(let x=0;x<f;x++)m[b++]=d[v++]}return new pe(m,f,g)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new ae,n=this.index.array,i=this.attributes;for(const h in i){const u=i[h],d=t(u,n);e.setAttribute(h,d)}const s=this.morphAttributes;for(const h in s){const u=[],d=s[h];for(let f=0,g=d.length;f<g;f++){const m=d[f],v=t(m,n);u.push(v)}e.morphAttributes[h]=u}e.morphTargetsRelative=this.morphTargetsRelative;const l=this.groups;for(let h=0,u=l.length;h<u;h++){const d=l[h];e.addGroup(d.start,d.count,d.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const u=this.parameters;for(const d in u)u[d]!==void 0&&(t[d]=u[d]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const u in n){const d=n[u];t.data.attributes[u]=d.toJSON(t.data)}const i={};let s=!1;for(const u in this.morphAttributes){const d=this.morphAttributes[u],f=[];for(let g=0,m=d.length;g<m;g++){const v=d[g];f.push(v.toJSON(t.data))}f.length>0&&(i[u]=f,s=!0)}s&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const l=this.groups;l.length>0&&(t.data.groups=JSON.parse(JSON.stringify(l)));const h=this.boundingSphere;return h!==null&&(t.data.boundingSphere={center:h.center.toArray(),radius:h.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const i=t.attributes;for(const d in i){const f=i[d];this.setAttribute(d,f.clone(e))}const s=t.morphAttributes;for(const d in s){const f=[],g=s[d];for(let m=0,v=g.length;m<v;m++)f.push(g[m].clone(e));this.morphAttributes[d]=f}this.morphTargetsRelative=t.morphTargetsRelative;const l=t.groups;for(let d=0,f=l.length;d<f;d++){const g=l[d];this.addGroup(g.start,g.count,g.materialIndex)}const h=t.boundingBox;h!==null&&(this.boundingBox=h.clone());const u=t.boundingSphere;return u!==null&&(this.boundingSphere=u.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}ae.prototype.isBufferGeometry=!0;const kc=new It,Gi=new Fi,pa=new ki,Fn=new L,Bn=new L,Vn=new L,fa=new L,ma=new L,ga=new L,Ps=new L,Ls=new L,Rs=new L,Ds=new tt,Is=new tt,Ns=new tt,va=new L,ks=new L;class Fe extends $t{constructor(t=new ae,e=new ua){super();this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,l=i.length;s<l;s++){const h=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,i=this.material,s=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),pa.copy(n.boundingSphere),pa.applyMatrix4(s),t.ray.intersectsSphere(pa)===!1)||(kc.copy(s).invert(),Gi.copy(t.ray).applyMatrix4(kc),n.boundingBox!==null&&Gi.intersectsBox(n.boundingBox)===!1))return;let l;if(n.isBufferGeometry){const h=n.index,u=n.attributes.position,d=n.morphAttributes.position,f=n.morphTargetsRelative,g=n.attributes.uv,m=n.attributes.uv2,v=n.groups,b=n.drawRange;if(h!==null)if(Array.isArray(i))for(let w=0,M=v.length;w<M;w++){const x=v[w],_=i[x.materialIndex],R=Math.max(x.start,b.start),C=Math.min(h.count,Math.min(x.start+x.count,b.start+b.count));for(let P=R,N=C;P<N;P+=3){const T=h.getX(P),H=h.getX(P+1),nt=h.getX(P+2);l=Fs(this,_,t,Gi,u,d,f,g,m,T,H,nt),l&&(l.faceIndex=Math.floor(P/3),l.face.materialIndex=x.materialIndex,e.push(l))}}else{const w=Math.max(0,b.start),M=Math.min(h.count,b.start+b.count);for(let x=w,_=M;x<_;x+=3){const R=h.getX(x),C=h.getX(x+1),P=h.getX(x+2);l=Fs(this,i,t,Gi,u,d,f,g,m,R,C,P),l&&(l.faceIndex=Math.floor(x/3),e.push(l))}}else if(u!==void 0)if(Array.isArray(i))for(let w=0,M=v.length;w<M;w++){const x=v[w],_=i[x.materialIndex],R=Math.max(x.start,b.start),C=Math.min(u.count,Math.min(x.start+x.count,b.start+b.count));for(let P=R,N=C;P<N;P+=3){const T=P,H=P+1,nt=P+2;l=Fs(this,_,t,Gi,u,d,f,g,m,T,H,nt),l&&(l.faceIndex=Math.floor(P/3),l.face.materialIndex=x.materialIndex,e.push(l))}}else{const w=Math.max(0,b.start),M=Math.min(u.count,b.start+b.count);for(let x=w,_=M;x<_;x+=3){const R=x,C=x+1,P=x+2;l=Fs(this,i,t,Gi,u,d,f,g,m,R,C,P),l&&(l.faceIndex=Math.floor(x/3),e.push(l))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}Fe.prototype.isMesh=!0;function ng(o,t,e,n,i,s,l,h){let u;if(t.side===de?u=n.intersectTriangle(l,s,i,!0,h):u=n.intersectTriangle(i,s,l,t.side!==wi,h),u===null)return null;ks.copy(h),ks.applyMatrix4(o.matrixWorld);const d=e.ray.origin.distanceTo(ks);return d<e.near||d>e.far?null:{distance:d,point:ks.clone(),object:o}}function Fs(o,t,e,n,i,s,l,h,u,d,f,g){Fn.fromBufferAttribute(i,d),Bn.fromBufferAttribute(i,f),Vn.fromBufferAttribute(i,g);const m=o.morphTargetInfluences;if(s&&m){Ps.set(0,0,0),Ls.set(0,0,0),Rs.set(0,0,0);for(let b=0,w=s.length;b<w;b++){const M=m[b],x=s[b];M!==0&&(fa.fromBufferAttribute(x,d),ma.fromBufferAttribute(x,f),ga.fromBufferAttribute(x,g),l?(Ps.addScaledVector(fa,M),Ls.addScaledVector(ma,M),Rs.addScaledVector(ga,M)):(Ps.addScaledVector(fa.sub(Fn),M),Ls.addScaledVector(ma.sub(Bn),M),Rs.addScaledVector(ga.sub(Vn),M)))}Fn.add(Ps),Bn.add(Ls),Vn.add(Rs)}o.isSkinnedMesh&&(o.boneTransform(d,Fn),o.boneTransform(f,Bn),o.boneTransform(g,Vn));const v=ng(o,t,e,n,Fn,Bn,Vn,va);if(v){h&&(Ds.fromBufferAttribute(h,d),Is.fromBufferAttribute(h,f),Ns.fromBufferAttribute(h,g),v.uv=ue.getUV(va,Fn,Bn,Vn,Ds,Is,Ns,new tt)),u&&(Ds.fromBufferAttribute(u,d),Is.fromBufferAttribute(u,f),Ns.fromBufferAttribute(u,g),v.uv2=ue.getUV(va,Fn,Bn,Vn,Ds,Is,Ns,new tt));const b={a:d,b:f,c:g,normal:new L,materialIndex:0};ue.getNormal(Fn,Bn,Vn,b.normal),v.face=b}return v}class Lr extends ae{constructor(t=1,e=1,n=1,i=1,s=1,l=1){super();this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:s,depthSegments:l};const h=this;i=Math.floor(i),s=Math.floor(s),l=Math.floor(l);const u=[],d=[],f=[],g=[];let m=0,v=0;b("z","y","x",-1,-1,n,e,t,l,s,0),b("z","y","x",1,-1,n,e,-t,l,s,1),b("x","z","y",1,1,t,n,e,i,l,2),b("x","z","y",1,-1,t,n,-e,i,l,3),b("x","y","z",1,-1,t,e,n,i,s,4),b("x","y","z",-1,-1,t,e,-n,i,s,5),this.setIndex(u),this.setAttribute("position",new me(d,3)),this.setAttribute("normal",new me(f,3)),this.setAttribute("uv",new me(g,2));function b(w,M,x,_,R,C,P,N,T,H,nt){const Y=C/T,k=P/H,ht=C/2,G=P/2,j=N/2,W=T+1,B=H+1;let X=0,at=0;const yt=new L;for(let bt=0;bt<B;bt++){const mt=bt*k-G;for(let vt=0;vt<W;vt++){const K=vt*Y-ht;yt[w]=K*_,yt[M]=mt*R,yt[x]=j,d.push(yt.x,yt.y,yt.z),yt[w]=0,yt[M]=0,yt[x]=N>0?1:-1,f.push(yt.x,yt.y,yt.z),g.push(vt/T),g.push(1-bt/H),X+=1}}for(let bt=0;bt<H;bt++)for(let mt=0;mt<T;mt++){const vt=m+mt+W*bt,K=m+mt+W*(bt+1),st=m+(mt+1)+W*(bt+1),wt=m+(mt+1)+W*bt;u.push(vt,K,wt),u.push(K,st,wt),at+=6}h.addGroup(v,at,nt),v+=at,m+=X}}static fromJSON(t){return new Lr(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function Wi(o){const t={};for(const e in o){t[e]={};for(const n in o[e]){const i=o[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?t[e][n]=i.clone():Array.isArray(i)?t[e][n]=i.slice():t[e][n]=i}}return t}function Ee(o){const t={};for(let e=0;e<o.length;e++){const n=Wi(o[e]);for(const i in n)t[i]=n[i]}return t}const ig={clone:Wi,merge:Ee};var rg=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,sg=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ai extends Se{constructor(t){super();this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=rg,this.fragmentShader=sg,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Wi(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const l=this.uniforms[i].value;l&&l.isTexture?e.uniforms[i]={type:"t",value:l.toJSON(t).uuid}:l&&l.isColor?e.uniforms[i]={type:"c",value:l.getHex()}:l&&l.isVector2?e.uniforms[i]={type:"v2",value:l.toArray()}:l&&l.isVector3?e.uniforms[i]={type:"v3",value:l.toArray()}:l&&l.isVector4?e.uniforms[i]={type:"v4",value:l.toArray()}:l&&l.isMatrix3?e.uniforms[i]={type:"m3",value:l.toArray()}:l&&l.isMatrix4?e.uniforms[i]={type:"m4",value:l.toArray()}:e.uniforms[i]={value:l}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}ai.prototype.isShaderMaterial=!0;class _a extends $t{constructor(){super();this.type="Camera",this.matrixWorldInverse=new It,this.projectionMatrix=new It,this.projectionMatrixInverse=new It}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}_a.prototype.isCamera=!0;class Be extends _a{constructor(t=50,e=1,n=.1,i=2e3){super();this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=Xo*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(jo*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return Xo*2*Math.atan(Math.tan(jo*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,s,l){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=l,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(jo*.5*this.fov)/this.zoom,n=2*e,i=this.aspect*n,s=-.5*i;const l=this.view;if(this.view!==null&&this.view.enabled){const u=l.fullWidth,d=l.fullHeight;s+=l.offsetX*i/u,e-=l.offsetY*n/d,i*=l.width/u,n*=l.height/d}const h=this.filmOffset;h!==0&&(s+=t*h/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}Be.prototype.isPerspectiveCamera=!0;const qi=90,ji=1;class xa extends $t{constructor(t,e,n){super();if(this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const i=new Be(qi,ji,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new L(1,0,0)),this.add(i);const s=new Be(qi,ji,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new L(-1,0,0)),this.add(s);const l=new Be(qi,ji,t,e);l.layers=this.layers,l.up.set(0,0,1),l.lookAt(new L(0,1,0)),this.add(l);const h=new Be(qi,ji,t,e);h.layers=this.layers,h.up.set(0,0,-1),h.lookAt(new L(0,-1,0)),this.add(h);const u=new Be(qi,ji,t,e);u.layers=this.layers,u.up.set(0,-1,0),u.lookAt(new L(0,0,1)),this.add(u);const d=new Be(qi,ji,t,e);d.layers=this.layers,d.up.set(0,-1,0),d.lookAt(new L(0,0,-1)),this.add(d)}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,s,l,h,u,d]=this.children,f=t.xr.enabled,g=t.getRenderTarget();t.xr.enabled=!1;const m=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,s),t.setRenderTarget(n,2),t.render(e,l),t.setRenderTarget(n,3),t.render(e,h),t.setRenderTarget(n,4),t.render(e,u),n.texture.generateMipmaps=m,t.setRenderTarget(n,5),t.render(e,d),t.setRenderTarget(g),t.xr.enabled=f}}class Bs extends xe{constructor(t,e,n,i,s,l,h,u,d,f){t=t!==void 0?t:[],e=e!==void 0?e:hs;super(t,e,n,i,s,l,h,u,d,f);this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}Bs.prototype.isCubeTexture=!0;class Fc extends an{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n);super(t,t,e);e=e||{},this.texture=new Bs(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:je,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=Pe,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Lr(5,5,5),s=new ai({name:"CubemapFromEquirect",uniforms:Wi(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:de,blending:An});s.uniforms.tEquirect.value=e;const l=new Fe(i,s),h=e.minFilter;return e.minFilter===ps&&(e.minFilter=je),new xa(1,10,this).update(t,l),e.minFilter=h,l.geometry.dispose(),l.material.dispose(),this}clear(t,e,n,i){const s=t.getRenderTarget();for(let l=0;l<6;l++)t.setRenderTarget(this,l),t.clear(e,n,i);t.setRenderTarget(s)}}Fc.prototype.isWebGLCubeRenderTarget=!0;const ba=new L,og=new L,ag=new _e;class bn{constructor(t=new L(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=ba.subVectors(n,e).cross(og.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(ba),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:e.copy(n).multiplyScalar(s).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||ag.getNormalMatrix(t),i=this.coplanarPoint(ba).applyMatrix4(t),s=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}bn.prototype.isPlane=!0;const Xi=new ki,Vs=new L;class Os{constructor(t=new bn,e=new bn,n=new bn,i=new bn,s=new bn,l=new bn){this.planes=[t,e,n,i,s,l]}set(t,e,n,i,s,l){const h=this.planes;return h[0].copy(t),h[1].copy(e),h[2].copy(n),h[3].copy(i),h[4].copy(s),h[5].copy(l),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],s=n[1],l=n[2],h=n[3],u=n[4],d=n[5],f=n[6],g=n[7],m=n[8],v=n[9],b=n[10],w=n[11],M=n[12],x=n[13],_=n[14],R=n[15];return e[0].setComponents(h-i,g-u,w-m,R-M).normalize(),e[1].setComponents(h+i,g+u,w+m,R+M).normalize(),e[2].setComponents(h+s,g+d,w+v,R+x).normalize(),e[3].setComponents(h-s,g-d,w-v,R-x).normalize(),e[4].setComponents(h-l,g-f,w-b,R-_).normalize(),e[5].setComponents(h+l,g+f,w+b,R+_).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),Xi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Xi)}intersectsSprite(t){return Xi.center.set(0,0,0),Xi.radius=.7071067811865476,Xi.applyMatrix4(t.matrixWorld),this.intersectsSphere(Xi)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(Vs.x=i.normal.x>0?t.max.x:t.min.x,Vs.y=i.normal.y>0?t.max.y:t.min.y,Vs.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(Vs)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Bc(){let o=null,t=!1,e=null,n=null;function i(s,l){e(s,l),n=o.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(n=o.requestAnimationFrame(i),t=!0)},stop:function(){o.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(s){e=s},setContext:function(s){o=s}}}function lg(o,t){const e=t.isWebGL2,n=new WeakMap;function i(d,f){const g=d.array,m=d.usage,v=o.createBuffer();o.bindBuffer(f,v),o.bufferData(f,g,m),d.onUploadCallback();let b=5126;return g instanceof Float32Array?b=5126:g instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):g instanceof Uint16Array?d.isFloat16BufferAttribute?e?b=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):b=5123:g instanceof Int16Array?b=5122:g instanceof Uint32Array?b=5125:g instanceof Int32Array?b=5124:g instanceof Int8Array?b=5120:(g instanceof Uint8Array||g instanceof Uint8ClampedArray)&&(b=5121),{buffer:v,type:b,bytesPerElement:g.BYTES_PER_ELEMENT,version:d.version}}function s(d,f,g){const m=f.array,v=f.updateRange;o.bindBuffer(g,d),v.count===-1?o.bufferSubData(g,0,m):(e?o.bufferSubData(g,v.offset*m.BYTES_PER_ELEMENT,m,v.offset,v.count):o.bufferSubData(g,v.offset*m.BYTES_PER_ELEMENT,m.subarray(v.offset,v.offset+v.count)),v.count=-1)}function l(d){return d.isInterleavedBufferAttribute&&(d=d.data),n.get(d)}function h(d){d.isInterleavedBufferAttribute&&(d=d.data);const f=n.get(d);f&&(o.deleteBuffer(f.buffer),n.delete(d))}function u(d,f){if(d.isGLBufferAttribute){const m=n.get(d);(!m||m.version<d.version)&&n.set(d,{buffer:d.buffer,type:d.type,bytesPerElement:d.elementSize,version:d.version});return}d.isInterleavedBufferAttribute&&(d=d.data);const g=n.get(d);g===void 0?n.set(d,i(d,f)):g.version<d.version&&(s(g.buffer,d,f),g.version=d.version)}return{get:l,remove:h,update:u}}class ya extends ae{constructor(t=1,e=1,n=1,i=1){super();this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const s=t/2,l=e/2,h=Math.floor(n),u=Math.floor(i),d=h+1,f=u+1,g=t/h,m=e/u,v=[],b=[],w=[],M=[];for(let x=0;x<f;x++){const _=x*m-l;for(let R=0;R<d;R++){const C=R*g-s;b.push(C,-_,0),w.push(0,0,1),M.push(R/h),M.push(1-x/u)}}for(let x=0;x<u;x++)for(let _=0;_<h;_++){const R=_+d*x,C=_+d*(x+1),P=_+1+d*(x+1),N=_+1+d*x;v.push(R,C,N),v.push(C,P,N)}this.setIndex(v),this.setAttribute("position",new me(b,3)),this.setAttribute("normal",new me(w,3)),this.setAttribute("uv",new me(M,2))}static fromJSON(t){return new ya(t.width,t.height,t.widthSegments,t.heightSegments)}}var cg=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,hg=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,ug=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,dg=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,pg=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,fg=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,mg="vec3 transformed = vec3( position );",gg=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,vg=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenTint * ( D * V );
}
#endif`,_g=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,xg=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,bg=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,yg=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,wg=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Mg=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,Sg=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Eg=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Tg=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Cg=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,Ag=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Pg=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Lg=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Rg=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Dg=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Ig=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Ng="gl_FragColor = linearToOutputTexel( gl_FragColor );",kg=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,Fg=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Bg=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Vg=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Og=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,zg=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Ug=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,Hg=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Gg=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Wg=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,qg=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,jg=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,Xg=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Yg=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,Zg=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,$g=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,Kg=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Jg=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,Qg=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,tv=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,ev=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularTintFactor = specularTint;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARTINTMAP
			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularTintFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenTint = sheenTint;
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
#endif`,nv=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenTint;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,iv=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,rv=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,sv=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,ov=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,av=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,lv=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,cv=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,hv=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,uv=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,dv=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,pv=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,fv=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,mv=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,gv=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,vv=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,_v=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,xv=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,bv=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,yv=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,wv=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Mv=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Sv=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,Ev=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Tv=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,Cv=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Av=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Pv=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Lv=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Rv=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Dv=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Iv=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Nv=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,kv=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Fv=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,Bv=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Vv=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Ov=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,zv=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Uv=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,Hv=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Gv=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Wv=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,qv=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,jv=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Xv=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Yv=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationTint, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,Zv=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationTint;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,$v=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,Kv=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,Jv=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,Qv=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,t_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,e_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,n_=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const i_=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,r_=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,s_=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,o_=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,a_=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,l_=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,c_=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,h_=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,u_=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,d_=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,p_=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,f_=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,m_=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,g_=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,v_=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,__=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,x_=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,b_=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,y_=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,w_=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,M_=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,S_=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,E_=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,T_=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularTint;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARTINTMAP
		uniform sampler2D specularTintMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenTint;
	uniform float sheenRoughness;
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,C_=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,A_=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,P_=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,L_=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,R_=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,D_=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,I_=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,N_=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Ht={alphamap_fragment:cg,alphamap_pars_fragment:hg,alphatest_fragment:ug,alphatest_pars_fragment:dg,aomap_fragment:pg,aomap_pars_fragment:fg,begin_vertex:mg,beginnormal_vertex:gg,bsdfs:vg,bumpmap_pars_fragment:_g,clipping_planes_fragment:xg,clipping_planes_pars_fragment:bg,clipping_planes_pars_vertex:yg,clipping_planes_vertex:wg,color_fragment:Mg,color_pars_fragment:Sg,color_pars_vertex:Eg,color_vertex:Tg,common:Cg,cube_uv_reflection_fragment:Ag,defaultnormal_vertex:Pg,displacementmap_pars_vertex:Lg,displacementmap_vertex:Rg,emissivemap_fragment:Dg,emissivemap_pars_fragment:Ig,encodings_fragment:Ng,encodings_pars_fragment:kg,envmap_fragment:Fg,envmap_common_pars_fragment:Bg,envmap_pars_fragment:Vg,envmap_pars_vertex:Og,envmap_physical_pars_fragment:$g,envmap_vertex:zg,fog_vertex:Ug,fog_pars_vertex:Hg,fog_fragment:Gg,fog_pars_fragment:Wg,gradientmap_pars_fragment:qg,lightmap_fragment:jg,lightmap_pars_fragment:Xg,lights_lambert_vertex:Yg,lights_pars_begin:Zg,lights_toon_fragment:Kg,lights_toon_pars_fragment:Jg,lights_phong_fragment:Qg,lights_phong_pars_fragment:tv,lights_physical_fragment:ev,lights_physical_pars_fragment:nv,lights_fragment_begin:iv,lights_fragment_maps:rv,lights_fragment_end:sv,logdepthbuf_fragment:ov,logdepthbuf_pars_fragment:av,logdepthbuf_pars_vertex:lv,logdepthbuf_vertex:cv,map_fragment:hv,map_pars_fragment:uv,map_particle_fragment:dv,map_particle_pars_fragment:pv,metalnessmap_fragment:fv,metalnessmap_pars_fragment:mv,morphnormal_vertex:gv,morphtarget_pars_vertex:vv,morphtarget_vertex:_v,normal_fragment_begin:xv,normal_fragment_maps:bv,normal_pars_fragment:yv,normal_pars_vertex:wv,normal_vertex:Mv,normalmap_pars_fragment:Sv,clearcoat_normal_fragment_begin:Ev,clearcoat_normal_fragment_maps:Tv,clearcoat_pars_fragment:Cv,output_fragment:Av,packing:Pv,premultiplied_alpha_fragment:Lv,project_vertex:Rv,dithering_fragment:Dv,dithering_pars_fragment:Iv,roughnessmap_fragment:Nv,roughnessmap_pars_fragment:kv,shadowmap_pars_fragment:Fv,shadowmap_pars_vertex:Bv,shadowmap_vertex:Vv,shadowmask_pars_fragment:Ov,skinbase_vertex:zv,skinning_pars_vertex:Uv,skinning_vertex:Hv,skinnormal_vertex:Gv,specularmap_fragment:Wv,specularmap_pars_fragment:qv,tonemapping_fragment:jv,tonemapping_pars_fragment:Xv,transmission_fragment:Yv,transmission_pars_fragment:Zv,uv_pars_fragment:$v,uv_pars_vertex:Kv,uv_vertex:Jv,uv2_pars_fragment:Qv,uv2_pars_vertex:t_,uv2_vertex:e_,worldpos_vertex:n_,background_vert:i_,background_frag:r_,cube_vert:s_,cube_frag:o_,depth_vert:a_,depth_frag:l_,distanceRGBA_vert:c_,distanceRGBA_frag:h_,equirect_vert:u_,equirect_frag:d_,linedashed_vert:p_,linedashed_frag:f_,meshbasic_vert:m_,meshbasic_frag:g_,meshlambert_vert:v_,meshlambert_frag:__,meshmatcap_vert:x_,meshmatcap_frag:b_,meshnormal_vert:y_,meshnormal_frag:w_,meshphong_vert:M_,meshphong_frag:S_,meshphysical_vert:E_,meshphysical_frag:T_,meshtoon_vert:C_,meshtoon_frag:A_,points_vert:P_,points_frag:L_,shadow_vert:R_,shadow_frag:D_,sprite_vert:I_,sprite_frag:N_},ft={common:{diffuse:{value:new Ct(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new _e},uv2Transform:{value:new _e},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new tt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ct(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ct(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new _e}},sprite:{diffuse:{value:new Ct(16777215)},opacity:{value:1},center:{value:new tt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new _e}}},ln={basic:{uniforms:Ee([ft.common,ft.specularmap,ft.envmap,ft.aomap,ft.lightmap,ft.fog]),vertexShader:Ht.meshbasic_vert,fragmentShader:Ht.meshbasic_frag},lambert:{uniforms:Ee([ft.common,ft.specularmap,ft.envmap,ft.aomap,ft.lightmap,ft.emissivemap,ft.fog,ft.lights,{emissive:{value:new Ct(0)}}]),vertexShader:Ht.meshlambert_vert,fragmentShader:Ht.meshlambert_frag},phong:{uniforms:Ee([ft.common,ft.specularmap,ft.envmap,ft.aomap,ft.lightmap,ft.emissivemap,ft.bumpmap,ft.normalmap,ft.displacementmap,ft.fog,ft.lights,{emissive:{value:new Ct(0)},specular:{value:new Ct(1118481)},shininess:{value:30}}]),vertexShader:Ht.meshphong_vert,fragmentShader:Ht.meshphong_frag},standard:{uniforms:Ee([ft.common,ft.envmap,ft.aomap,ft.lightmap,ft.emissivemap,ft.bumpmap,ft.normalmap,ft.displacementmap,ft.roughnessmap,ft.metalnessmap,ft.fog,ft.lights,{emissive:{value:new Ct(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ht.meshphysical_vert,fragmentShader:Ht.meshphysical_frag},toon:{uniforms:Ee([ft.common,ft.aomap,ft.lightmap,ft.emissivemap,ft.bumpmap,ft.normalmap,ft.displacementmap,ft.gradientmap,ft.fog,ft.lights,{emissive:{value:new Ct(0)}}]),vertexShader:Ht.meshtoon_vert,fragmentShader:Ht.meshtoon_frag},matcap:{uniforms:Ee([ft.common,ft.bumpmap,ft.normalmap,ft.displacementmap,ft.fog,{matcap:{value:null}}]),vertexShader:Ht.meshmatcap_vert,fragmentShader:Ht.meshmatcap_frag},points:{uniforms:Ee([ft.points,ft.fog]),vertexShader:Ht.points_vert,fragmentShader:Ht.points_frag},dashed:{uniforms:Ee([ft.common,ft.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ht.linedashed_vert,fragmentShader:Ht.linedashed_frag},depth:{uniforms:Ee([ft.common,ft.displacementmap]),vertexShader:Ht.depth_vert,fragmentShader:Ht.depth_frag},normal:{uniforms:Ee([ft.common,ft.bumpmap,ft.normalmap,ft.displacementmap,{opacity:{value:1}}]),vertexShader:Ht.meshnormal_vert,fragmentShader:Ht.meshnormal_frag},sprite:{uniforms:Ee([ft.sprite,ft.fog]),vertexShader:Ht.sprite_vert,fragmentShader:Ht.sprite_frag},background:{uniforms:{uvTransform:{value:new _e},t2D:{value:null}},vertexShader:Ht.background_vert,fragmentShader:Ht.background_frag},cube:{uniforms:Ee([ft.envmap,{opacity:{value:1}}]),vertexShader:Ht.cube_vert,fragmentShader:Ht.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ht.equirect_vert,fragmentShader:Ht.equirect_frag},distanceRGBA:{uniforms:Ee([ft.common,ft.displacementmap,{referencePosition:{value:new L},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ht.distanceRGBA_vert,fragmentShader:Ht.distanceRGBA_frag},shadow:{uniforms:Ee([ft.lights,ft.fog,{color:{value:new Ct(0)},opacity:{value:1}}]),vertexShader:Ht.shadow_vert,fragmentShader:Ht.shadow_frag}};ln.physical={uniforms:Ee([ln.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new tt(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenTint:{value:new Ct(0)},sheenRoughness:{value:0},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new tt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationTint:{value:new Ct(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularTint:{value:new Ct(1,1,1)},specularTintMap:{value:null}}]),vertexShader:Ht.meshphysical_vert,fragmentShader:Ht.meshphysical_frag};function k_(o,t,e,n,i){const s=new Ct(0);let l=0,h,u,d=null,f=0,g=null;function m(b,w){let M=!1,x=w.isScene===!0?w.background:null;x&&x.isTexture&&(x=t.get(x));const _=o.xr,R=_.getSession&&_.getSession();R&&R.environmentBlendMode==="additive"&&(x=null),x===null?v(s,l):x&&x.isColor&&(v(x,1),M=!0),(o.autoClear||M)&&o.clear(o.autoClearColor,o.autoClearDepth,o.autoClearStencil),x&&(x.isCubeTexture||x.mapping===ds)?(u===void 0&&(u=new Fe(new Lr(1,1,1),new ai({name:"BackgroundCubeMaterial",uniforms:Wi(ln.cube.uniforms),vertexShader:ln.cube.vertexShader,fragmentShader:ln.cube.fragmentShader,side:de,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(C,P,N){this.matrixWorld.copyPosition(N.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(u)),u.material.uniforms.envMap.value=x,u.material.uniforms.flipEnvMap.value=x.isCubeTexture&&x.isRenderTargetTexture===!1?-1:1,(d!==x||f!==x.version||g!==o.toneMapping)&&(u.material.needsUpdate=!0,d=x,f=x.version,g=o.toneMapping),b.unshift(u,u.geometry,u.material,0,0,null)):x&&x.isTexture&&(h===void 0&&(h=new Fe(new ya(2,2),new ai({name:"BackgroundMaterial",uniforms:Wi(ln.background.uniforms),vertexShader:ln.background.vertexShader,fragmentShader:ln.background.fragmentShader,side:yr,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),Object.defineProperty(h.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(h)),h.material.uniforms.t2D.value=x,x.matrixAutoUpdate===!0&&x.updateMatrix(),h.material.uniforms.uvTransform.value.copy(x.matrix),(d!==x||f!==x.version||g!==o.toneMapping)&&(h.material.needsUpdate=!0,d=x,f=x.version,g=o.toneMapping),b.unshift(h,h.geometry,h.material,0,0,null))}function v(b,w){e.buffers.color.setClear(b.r,b.g,b.b,w,i)}return{getClearColor:function(){return s},setClearColor:function(b,w=1){s.set(b),l=w,v(s,l)},getClearAlpha:function(){return l},setClearAlpha:function(b){l=b,v(s,l)},render:m}}function F_(o,t,e,n){const i=o.getParameter(34921),s=n.isWebGL2?null:t.get("OES_vertex_array_object"),l=n.isWebGL2||s!==null,h={},u=w(null);let d=u;function f(G,j,W,B,X){let at=!1;if(l){const yt=b(B,W,j);d!==yt&&(d=yt,m(d.object)),at=M(B,X),at&&x(B,X)}else{const yt=j.wireframe===!0;(d.geometry!==B.id||d.program!==W.id||d.wireframe!==yt)&&(d.geometry=B.id,d.program=W.id,d.wireframe=yt,at=!0)}G.isInstancedMesh===!0&&(at=!0),X!==null&&e.update(X,34963),at&&(T(G,j,W,B),X!==null&&o.bindBuffer(34963,e.get(X).buffer))}function g(){return n.isWebGL2?o.createVertexArray():s.createVertexArrayOES()}function m(G){return n.isWebGL2?o.bindVertexArray(G):s.bindVertexArrayOES(G)}function v(G){return n.isWebGL2?o.deleteVertexArray(G):s.deleteVertexArrayOES(G)}function b(G,j,W){const B=W.wireframe===!0;let X=h[G.id];X===void 0&&(X={},h[G.id]=X);let at=X[j.id];at===void 0&&(at={},X[j.id]=at);let yt=at[B];return yt===void 0&&(yt=w(g()),at[B]=yt),yt}function w(G){const j=[],W=[],B=[];for(let X=0;X<i;X++)j[X]=0,W[X]=0,B[X]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:j,enabledAttributes:W,attributeDivisors:B,object:G,attributes:{},index:null}}function M(G,j){const W=d.attributes,B=G.attributes;let X=0;for(const at in B){const yt=W[at],bt=B[at];if(yt===void 0||yt.attribute!==bt||yt.data!==bt.data)return!0;X++}return d.attributesNum!==X||d.index!==j}function x(G,j){const W={},B=G.attributes;let X=0;for(const at in B){const yt=B[at],bt={};bt.attribute=yt,yt.data&&(bt.data=yt.data),W[at]=bt,X++}d.attributes=W,d.attributesNum=X,d.index=j}function _(){const G=d.newAttributes;for(let j=0,W=G.length;j<W;j++)G[j]=0}function R(G){C(G,0)}function C(G,j){const W=d.newAttributes,B=d.enabledAttributes,X=d.attributeDivisors;W[G]=1,B[G]===0&&(o.enableVertexAttribArray(G),B[G]=1),X[G]!==j&&((n.isWebGL2?o:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](G,j),X[G]=j)}function P(){const G=d.newAttributes,j=d.enabledAttributes;for(let W=0,B=j.length;W<B;W++)j[W]!==G[W]&&(o.disableVertexAttribArray(W),j[W]=0)}function N(G,j,W,B,X,at){n.isWebGL2===!0&&(W===5124||W===5125)?o.vertexAttribIPointer(G,j,W,X,at):o.vertexAttribPointer(G,j,W,B,X,at)}function T(G,j,W,B){if(n.isWebGL2===!1&&(G.isInstancedMesh||B.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;_();const X=B.attributes,at=W.getAttributes(),yt=j.defaultAttributeValues;for(const bt in at){const mt=at[bt];if(mt.location>=0){let vt=X[bt];if(vt===void 0&&(bt==="instanceMatrix"&&G.instanceMatrix&&(vt=G.instanceMatrix),bt==="instanceColor"&&G.instanceColor&&(vt=G.instanceColor)),vt!==void 0){const K=vt.normalized,st=vt.itemSize,wt=e.get(vt);if(wt===void 0)continue;const q=wt.buffer,Tt=wt.type,At=wt.bytesPerElement;if(vt.isInterleavedBufferAttribute){const ut=vt.data,xt=ut.stride,kt=vt.offset;if(ut&&ut.isInstancedInterleavedBuffer){for(let $=0;$<mt.locationSize;$++)C(mt.location+$,ut.meshPerAttribute);G.isInstancedMesh!==!0&&B._maxInstanceCount===void 0&&(B._maxInstanceCount=ut.meshPerAttribute*ut.count)}else for(let $=0;$<mt.locationSize;$++)R(mt.location+$);o.bindBuffer(34962,q);for(let $=0;$<mt.locationSize;$++)N(mt.location+$,st/mt.locationSize,Tt,K,xt*At,(kt+st/mt.locationSize*$)*At)}else{if(vt.isInstancedBufferAttribute){for(let ut=0;ut<mt.locationSize;ut++)C(mt.location+ut,vt.meshPerAttribute);G.isInstancedMesh!==!0&&B._maxInstanceCount===void 0&&(B._maxInstanceCount=vt.meshPerAttribute*vt.count)}else for(let ut=0;ut<mt.locationSize;ut++)R(mt.location+ut);o.bindBuffer(34962,q);for(let ut=0;ut<mt.locationSize;ut++)N(mt.location+ut,st/mt.locationSize,Tt,K,st*At,st/mt.locationSize*ut*At)}}else if(yt!==void 0){const K=yt[bt];if(K!==void 0)switch(K.length){case 2:o.vertexAttrib2fv(mt.location,K);break;case 3:o.vertexAttrib3fv(mt.location,K);break;case 4:o.vertexAttrib4fv(mt.location,K);break;default:o.vertexAttrib1fv(mt.location,K)}}}}P()}function H(){k();for(const G in h){const j=h[G];for(const W in j){const B=j[W];for(const X in B)v(B[X].object),delete B[X];delete j[W]}delete h[G]}}function nt(G){if(h[G.id]===void 0)return;const j=h[G.id];for(const W in j){const B=j[W];for(const X in B)v(B[X].object),delete B[X];delete j[W]}delete h[G.id]}function Y(G){for(const j in h){const W=h[j];if(W[G.id]===void 0)continue;const B=W[G.id];for(const X in B)v(B[X].object),delete B[X];delete W[G.id]}}function k(){ht(),d!==u&&(d=u,m(d.object))}function ht(){u.geometry=null,u.program=null,u.wireframe=!1}return{setup:f,reset:k,resetDefaultState:ht,dispose:H,releaseStatesOfGeometry:nt,releaseStatesOfProgram:Y,initAttributes:_,enableAttribute:R,disableUnusedAttributes:P}}function B_(o,t,e,n){const i=n.isWebGL2;let s;function l(d){s=d}function h(d,f){o.drawArrays(s,d,f),e.update(f,s,1)}function u(d,f,g){if(g===0)return;let m,v;if(i)m=o,v="drawArraysInstanced";else if(m=t.get("ANGLE_instanced_arrays"),v="drawArraysInstancedANGLE",m===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[v](s,d,f,g),e.update(f,s,g)}this.setMode=l,this.render=h,this.renderInstances=u}function V_(o,t,e){let n;function i(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const T=t.get("EXT_texture_filter_anisotropic");n=o.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(T){if(T==="highp"){if(o.getShaderPrecisionFormat(35633,36338).precision>0&&o.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";T="mediump"}return T==="mediump"&&o.getShaderPrecisionFormat(35633,36337).precision>0&&o.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const l=typeof WebGL2RenderingContext!="undefined"&&o instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&o instanceof WebGL2ComputeRenderingContext;let h=e.precision!==void 0?e.precision:"highp";const u=s(h);u!==h&&(console.warn("THREE.WebGLRenderer:",h,"not supported, using",u,"instead."),h=u);const d=l||t.has("WEBGL_draw_buffers"),f=e.logarithmicDepthBuffer===!0,g=o.getParameter(34930),m=o.getParameter(35660),v=o.getParameter(3379),b=o.getParameter(34076),w=o.getParameter(34921),M=o.getParameter(36347),x=o.getParameter(36348),_=o.getParameter(36349),R=m>0,C=l||t.has("OES_texture_float"),P=R&&C,N=l?o.getParameter(36183):0;return{isWebGL2:l,drawBuffers:d,getMaxAnisotropy:i,getMaxPrecision:s,precision:h,logarithmicDepthBuffer:f,maxTextures:g,maxVertexTextures:m,maxTextureSize:v,maxCubemapSize:b,maxAttributes:w,maxVertexUniforms:M,maxVaryings:x,maxFragmentUniforms:_,vertexTextures:R,floatFragmentTextures:C,floatVertexTextures:P,maxSamples:N}}function O_(o){const t=this;let e=null,n=0,i=!1,s=!1;const l=new bn,h=new _e,u={value:null,needsUpdate:!1};this.uniform=u,this.numPlanes=0,this.numIntersection=0,this.init=function(g,m,v){const b=g.length!==0||m||n!==0||i;return i=m,e=f(g,v,0),n=g.length,b},this.beginShadows=function(){s=!0,f(null)},this.endShadows=function(){s=!1,d()},this.setState=function(g,m,v){const b=g.clippingPlanes,w=g.clipIntersection,M=g.clipShadows,x=o.get(g);if(!i||b===null||b.length===0||s&&!M)s?f(null):d();else{const _=s?0:n,R=_*4;let C=x.clippingState||null;u.value=C,C=f(b,m,R,v);for(let P=0;P!==R;++P)C[P]=e[P];x.clippingState=C,this.numIntersection=w?this.numPlanes:0,this.numPlanes+=_}};function d(){u.value!==e&&(u.value=e,u.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function f(g,m,v,b){const w=g!==null?g.length:0;let M=null;if(w!==0){if(M=u.value,b!==!0||M===null){const x=v+w*4,_=m.matrixWorldInverse;h.getNormalMatrix(_),(M===null||M.length<x)&&(M=new Float32Array(x));for(let R=0,C=v;R!==w;++R,C+=4)l.copy(g[R]).applyMatrix4(_,h),l.normal.toArray(M,C),M[C+3]=l.constant}u.value=M,u.needsUpdate=!0}return t.numPlanes=w,t.numIntersection=0,M}}function z_(o){let t=new WeakMap;function e(l,h){return h===Fo?l.mapping=hs:h===Bo&&(l.mapping=us),l}function n(l){if(l&&l.isTexture&&l.isRenderTargetTexture===!1){const h=l.mapping;if(h===Fo||h===Bo)if(t.has(l)){const u=t.get(l).texture;return e(u,l.mapping)}else{const u=l.image;if(u&&u.height>0){const d=o.getRenderTarget(),f=new Fc(u.height/2);return f.fromEquirectangularTexture(o,l),t.set(l,f),o.setRenderTarget(d),l.addEventListener("dispose",i),e(f.texture,l.mapping)}else return null}}return l}function i(l){const h=l.target;h.removeEventListener("dispose",i);const u=t.get(h);u!==void 0&&(t.delete(h),u.dispose())}function s(){t=new WeakMap}return{get:n,dispose:s}}class wa extends _a{constructor(t=-1,e=1,n=1,i=-1,s=.1,l=2e3){super();this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=s,this.far=l,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,s,l){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=l,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=n-t,l=n+t,h=i+e,u=i-e;if(this.view!==null&&this.view.enabled){const d=(this.right-this.left)/this.view.fullWidth/this.zoom,f=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=d*this.view.offsetX,l=s+d*this.view.width,h-=f*this.view.offsetY,u=h-f*this.view.height}this.projectionMatrix.makeOrthographic(s,l,h,u,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}wa.prototype.isOrthographicCamera=!0;class zs extends ai{constructor(t){super(t);this.type="RawShaderMaterial"}}zs.prototype.isRawShaderMaterial=!0;const Yi=4,On=8,cn=Math.pow(2,On),Vc=[.125,.215,.35,.446,.526,.582],Oc=On-Yi+1+Vc.length,Zi=20,zn={[we]:0,[ri]:1,[Wo]:2,[mc]:3,[gc]:4,[vc]:5,[Go]:6},Ma=new wa,{_lodPlanes:Rr,_sizeLods:zc,_sigmas:Us}=G_(),Uc=new Ct;let Sa=null;const li=(1+Math.sqrt(5))/2,$i=1/li,Hc=[new L(1,1,1),new L(-1,1,1),new L(1,1,-1),new L(-1,1,-1),new L(0,li,$i),new L(0,li,-$i),new L($i,0,li),new L(-$i,0,li),new L(li,$i,0),new L(-li,$i,0)];class U_{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=W_(Zi),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){Sa=this._renderer.getRenderTarget();const s=this._allocateTargets();return this._sceneToCubeUV(t,n,i,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=qc(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=Wc(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let t=0;t<Rr.length;t++)Rr[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Sa),t.scissorTest=!1,Hs(t,0,0,t.width,t.height)}_fromTexture(t){Sa=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:fe,minFilter:fe,generateMipmaps:!1,type:Pn,format:Yf,encoding:H_(t)?t.encoding:Wo,depthBuffer:!1},n=Gc(e);return n.depthBuffer=!t,this._pingPongRenderTarget=Gc(e),n}_compileMaterial(t){const e=new Fe(Rr[0],t);this._renderer.compile(e,Ma)}_sceneToCubeUV(t,e,n,i){const s=90,l=1,h=new Be(s,l,e,n),u=[1,-1,1,1,1,1],d=[1,1,1,-1,-1,-1],f=this._renderer,g=f.autoClear,m=f.outputEncoding,v=f.toneMapping;f.getClearColor(Uc),f.toneMapping=ii,f.outputEncoding=we,f.autoClear=!1;const b=new ua({name:"PMREM.Background",side:de,depthWrite:!1,depthTest:!1}),w=new Fe(new Lr,b);let M=!1;const x=t.background;x?x.isColor&&(b.color.copy(x),t.background=null,M=!0):(b.color.copy(Uc),M=!0);for(let _=0;_<6;_++){const R=_%3;R==0?(h.up.set(0,u[_],0),h.lookAt(d[_],0,0)):R==1?(h.up.set(0,0,u[_]),h.lookAt(0,d[_],0)):(h.up.set(0,u[_],0),h.lookAt(0,0,d[_])),Hs(i,R*cn,_>2?cn:0,cn,cn),f.setRenderTarget(i),M&&f.render(w,h),f.render(t,h)}w.geometry.dispose(),w.material.dispose(),f.toneMapping=v,f.outputEncoding=m,f.autoClear=g,t.background=x}_setEncoding(t,e){this._renderer.capabilities.isWebGL2===!0&&e.format===Pe&&e.type===Pn&&e.encoding===ri?t.value=zn[we]:t.value=zn[e.encoding]}_textureToCubeUV(t,e){const n=this._renderer;t.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=qc()):this._equirectShader==null&&(this._equirectShader=Wc());const i=t.isCubeTexture?this._cubemapShader:this._equirectShader,s=new Fe(Rr[0],i),l=i.uniforms;l.envMap.value=t,t.isCubeTexture||l.texelSize.value.set(1/t.image.width,1/t.image.height),this._setEncoding(l.inputEncoding,t),this._setEncoding(l.outputEncoding,e.texture),Hs(e,0,0,3*cn,2*cn),n.setRenderTarget(e),n.render(s,Ma)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let i=1;i<Oc;i++){const s=Math.sqrt(Us[i]*Us[i]-Us[i-1]*Us[i-1]),l=Hc[(i-1)%Hc.length];this._blur(t,i-1,i,s,l)}e.autoClear=n}_blur(t,e,n,i,s){const l=this._pingPongRenderTarget;this._halfBlur(t,l,e,n,i,"latitudinal",s),this._halfBlur(l,t,n,n,i,"longitudinal",s)}_halfBlur(t,e,n,i,s,l,h){const u=this._renderer,d=this._blurMaterial;l!=="latitudinal"&&l!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const f=3,g=new Fe(Rr[i],d),m=d.uniforms,v=zc[n]-1,b=isFinite(s)?Math.PI/(2*v):2*Math.PI/(2*Zi-1),w=s/b,M=isFinite(s)?1+Math.floor(f*w):Zi;M>Zi&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${M} samples when the maximum is set to ${Zi}`);const x=[];let _=0;for(let N=0;N<Zi;++N){const T=N/w,H=Math.exp(-T*T/2);x.push(H),N==0?_+=H:N<M&&(_+=2*H)}for(let N=0;N<x.length;N++)x[N]=x[N]/_;m.envMap.value=t.texture,m.samples.value=M,m.weights.value=x,m.latitudinal.value=l==="latitudinal",h&&(m.poleAxis.value=h),m.dTheta.value=b,m.mipInt.value=On-n,this._setEncoding(m.inputEncoding,t.texture),this._setEncoding(m.outputEncoding,t.texture);const R=zc[i],C=3*Math.max(0,cn-2*R),P=(i===0?0:2*cn)+2*R*(i>On-Yi?i-On+Yi:0);Hs(e,C,P,3*R,2*R),u.setRenderTarget(e),u.render(g,Ma)}}function H_(o){return o===void 0||o.type!==Pn?!1:o.encoding===we||o.encoding===ri||o.encoding===Go}function G_(){const o=[],t=[],e=[];let n=On;for(let i=0;i<Oc;i++){const s=Math.pow(2,n);t.push(s);let l=1/s;i>On-Yi?l=Vc[i-On+Yi-1]:i==0&&(l=0),e.push(l);const h=1/(s-1),u=-h/2,d=1+h/2,f=[u,u,d,u,d,d,u,u,d,d,u,d],g=6,m=6,v=3,b=2,w=1,M=new Float32Array(v*m*g),x=new Float32Array(b*m*g),_=new Float32Array(w*m*g);for(let C=0;C<g;C++){const P=C%3*2/3-1,N=C>2?0:-1,T=[P,N,0,P+2/3,N,0,P+2/3,N+1,0,P,N,0,P+2/3,N+1,0,P,N+1,0];M.set(T,v*m*C),x.set(f,b*m*C);const H=[C,C,C,C,C,C];_.set(H,w*m*C)}const R=new ae;R.setAttribute("position",new pe(M,v)),R.setAttribute("uv",new pe(x,b)),R.setAttribute("faceIndex",new pe(_,w)),o.push(R),n>Yi&&n--}return{_lodPlanes:o,_sizeLods:t,_sigmas:e}}function Gc(o){const t=new an(3*cn,3*cn,o);return t.texture.mapping=ds,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function Hs(o,t,e,n,i){o.viewport.set(t,e,n,i),o.scissor.set(t,e,n,i)}function W_(o){const t=new Float32Array(o),e=new L(0,1,0);return new zs({name:"SphericalGaussianBlur",defines:{n:o},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:e},inputEncoding:{value:zn[we]},outputEncoding:{value:zn[we]}},vertexShader:Ea(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Ta()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:An,depthTest:!1,depthWrite:!1})}function Wc(){const o=new tt(1,1);return new zs({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:o},inputEncoding:{value:zn[we]},outputEncoding:{value:zn[we]}},vertexShader:Ea(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Ta()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:An,depthTest:!1,depthWrite:!1})}function qc(){return new zs({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:zn[we]},outputEncoding:{value:zn[we]}},vertexShader:Ea(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Ta()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:An,depthTest:!1,depthWrite:!1})}function Ea(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Ta(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function q_(o){let t=new WeakMap,e=null;function n(h){if(h&&h.isTexture&&h.isRenderTargetTexture===!1){const u=h.mapping,d=u===Fo||u===Bo,f=u===hs||u===us;if(d||f){if(t.has(h))return t.get(h).texture;{const g=h.image;if(d&&g&&g.height>0||f&&g&&i(g)){const m=o.getRenderTarget();e===null&&(e=new U_(o));const v=d?e.fromEquirectangular(h):e.fromCubemap(h);return t.set(h,v),o.setRenderTarget(m),h.addEventListener("dispose",s),v.texture}else return null}}}return h}function i(h){let u=0;const d=6;for(let f=0;f<d;f++)h[f]!==void 0&&u++;return u===d}function s(h){const u=h.target;u.removeEventListener("dispose",s);const d=t.get(u);d!==void 0&&(t.delete(u),d.dispose())}function l(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:l}}function j_(o){const t={};function e(n){if(t[n]!==void 0)return t[n];let i;switch(n){case"WEBGL_depth_texture":i=o.getExtension("WEBGL_depth_texture")||o.getExtension("MOZ_WEBGL_depth_texture")||o.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=o.getExtension("EXT_texture_filter_anisotropic")||o.getExtension("MOZ_EXT_texture_filter_anisotropic")||o.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=o.getExtension("WEBGL_compressed_texture_s3tc")||o.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||o.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=o.getExtension("WEBGL_compressed_texture_pvrtc")||o.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=o.getExtension(n)}return t[n]=i,i}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float")},get:function(n){const i=e(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function X_(o,t,e,n){const i={},s=new WeakMap;function l(g){const m=g.target;m.index!==null&&t.remove(m.index);for(const b in m.attributes)t.remove(m.attributes[b]);m.removeEventListener("dispose",l),delete i[m.id];const v=s.get(m);v&&(t.remove(v),s.delete(m)),n.releaseStatesOfGeometry(m),m.isInstancedBufferGeometry===!0&&delete m._maxInstanceCount,e.memory.geometries--}function h(g,m){return i[m.id]===!0||(m.addEventListener("dispose",l),i[m.id]=!0,e.memory.geometries++),m}function u(g){const m=g.attributes;for(const b in m)t.update(m[b],34962);const v=g.morphAttributes;for(const b in v){const w=v[b];for(let M=0,x=w.length;M<x;M++)t.update(w[M],34962)}}function d(g){const m=[],v=g.index,b=g.attributes.position;let w=0;if(v!==null){const _=v.array;w=v.version;for(let R=0,C=_.length;R<C;R+=3){const P=_[R+0],N=_[R+1],T=_[R+2];m.push(P,N,N,T,T,P)}}else{const _=b.array;w=b.version;for(let R=0,C=_.length/3-1;R<C;R+=3){const P=R+0,N=R+1,T=R+2;m.push(P,N,N,T,T,P)}}const M=new(bc(m)>65535?Nc:Ic)(m,1);M.version=w;const x=s.get(g);x&&t.remove(x),s.set(g,M)}function f(g){const m=s.get(g);if(m){const v=g.index;v!==null&&m.version<v.version&&d(g)}else d(g);return s.get(g)}return{get:h,update:u,getWireframeAttribute:f}}function Y_(o,t,e,n){const i=n.isWebGL2;let s;function l(m){s=m}let h,u;function d(m){h=m.type,u=m.bytesPerElement}function f(m,v){o.drawElements(s,v,h,m*u),e.update(v,s,1)}function g(m,v,b){if(b===0)return;let w,M;if(i)w=o,M="drawElementsInstanced";else if(w=t.get("ANGLE_instanced_arrays"),M="drawElementsInstancedANGLE",w===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}w[M](s,v,h,m*u,b),e.update(v,s,b)}this.setMode=l,this.setIndex=d,this.render=f,this.renderInstances=g}function Z_(o){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,l,h){switch(e.calls++,l){case 4:e.triangles+=h*(s/3);break;case 1:e.lines+=h*(s/2);break;case 3:e.lines+=h*(s-1);break;case 2:e.lines+=h*s;break;case 0:e.points+=h*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",l);break}}function i(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:i,update:n}}class Ca extends xe{constructor(t=null,e=1,n=1,i=1){super(null);this.image={data:t,width:e,height:n,depth:i},this.magFilter=fe,this.minFilter=fe,this.wrapR=Ue,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Ca.prototype.isDataTexture2DArray=!0;function $_(o,t){return o[0]-t[0]}function K_(o,t){return Math.abs(t[1])-Math.abs(o[1])}function jc(o,t){let e=1;const n=t.isInterleavedBufferAttribute?t.data.array:t.array;n instanceof Int8Array?e=127:n instanceof Int16Array?e=32767:n instanceof Int32Array?e=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",n),o.divideScalar(e)}function J_(o,t,e){const n={},i=new Float32Array(8),s=new WeakMap,l=new L,h=[];for(let d=0;d<8;d++)h[d]=[d,0];function u(d,f,g,m){const v=d.morphTargetInfluences;if(t.isWebGL2===!0){const b=f.morphAttributes.position.length;let w=s.get(f);if(w===void 0||w.count!==b){w!==void 0&&w.texture.dispose();const _=f.morphAttributes.normal!==void 0,R=f.morphAttributes.position,C=f.morphAttributes.normal||[],P=f.attributes.position.count,N=_===!0?2:1;let T=P*N,H=1;T>t.maxTextureSize&&(H=Math.ceil(T/t.maxTextureSize),T=t.maxTextureSize);const nt=new Float32Array(T*H*4*b),Y=new Ca(nt,T,H,b);Y.format=Pe,Y.type=Ln;const k=N*4;for(let ht=0;ht<b;ht++){const G=R[ht],j=C[ht],W=T*H*4*ht;for(let B=0;B<G.count;B++){l.fromBufferAttribute(G,B),G.normalized===!0&&jc(l,G);const X=B*k;nt[W+X+0]=l.x,nt[W+X+1]=l.y,nt[W+X+2]=l.z,nt[W+X+3]=0,_===!0&&(l.fromBufferAttribute(j,B),j.normalized===!0&&jc(l,j),nt[W+X+4]=l.x,nt[W+X+5]=l.y,nt[W+X+6]=l.z,nt[W+X+7]=0)}}w={count:b,texture:Y,size:new tt(T,H)},s.set(f,w)}let M=0;for(let _=0;_<v.length;_++)M+=v[_];const x=f.morphTargetsRelative?1:1-M;m.getUniforms().setValue(o,"morphTargetBaseInfluence",x),m.getUniforms().setValue(o,"morphTargetInfluences",v),m.getUniforms().setValue(o,"morphTargetsTexture",w.texture,e),m.getUniforms().setValue(o,"morphTargetsTextureSize",w.size)}else{const b=v===void 0?0:v.length;let w=n[f.id];if(w===void 0||w.length!==b){w=[];for(let C=0;C<b;C++)w[C]=[C,0];n[f.id]=w}for(let C=0;C<b;C++){const P=w[C];P[0]=C,P[1]=v[C]}w.sort(K_);for(let C=0;C<8;C++)C<b&&w[C][1]?(h[C][0]=w[C][0],h[C][1]=w[C][1]):(h[C][0]=Number.MAX_SAFE_INTEGER,h[C][1]=0);h.sort($_);const M=f.morphAttributes.position,x=f.morphAttributes.normal;let _=0;for(let C=0;C<8;C++){const P=h[C],N=P[0],T=P[1];N!==Number.MAX_SAFE_INTEGER&&T?(M&&f.getAttribute("morphTarget"+C)!==M[N]&&f.setAttribute("morphTarget"+C,M[N]),x&&f.getAttribute("morphNormal"+C)!==x[N]&&f.setAttribute("morphNormal"+C,x[N]),i[C]=T,_+=T):(M&&f.hasAttribute("morphTarget"+C)===!0&&f.deleteAttribute("morphTarget"+C),x&&f.hasAttribute("morphNormal"+C)===!0&&f.deleteAttribute("morphNormal"+C),i[C]=0)}const R=f.morphTargetsRelative?1:1-_;m.getUniforms().setValue(o,"morphTargetBaseInfluence",R),m.getUniforms().setValue(o,"morphTargetInfluences",i)}}return{update:u}}function Q_(o,t,e,n){let i=new WeakMap;function s(u){const d=n.render.frame,f=u.geometry,g=t.get(u,f);return i.get(g)!==d&&(t.update(g),i.set(g,d)),u.isInstancedMesh&&(u.hasEventListener("dispose",h)===!1&&u.addEventListener("dispose",h),e.update(u.instanceMatrix,34962),u.instanceColor!==null&&e.update(u.instanceColor,34962)),g}function l(){i=new WeakMap}function h(u){const d=u.target;d.removeEventListener("dispose",h),e.remove(d.instanceMatrix),d.instanceColor!==null&&e.remove(d.instanceColor)}return{update:s,dispose:l}}class Xc extends xe{constructor(t=null,e=1,n=1,i=1){super(null);this.image={data:t,width:e,height:n,depth:i},this.magFilter=fe,this.minFilter=fe,this.wrapR=Ue,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Xc.prototype.isDataTexture3D=!0;const Yc=new xe,tx=new Ca,ex=new Xc,Zc=new Bs,$c=[],Kc=[],Jc=new Float32Array(16),Qc=new Float32Array(9),th=new Float32Array(4);function Ki(o,t,e){const n=o[0];if(n<=0||n>0)return o;const i=t*e;let s=$c[i];if(s===void 0&&(s=new Float32Array(i),$c[i]=s),t!==0){n.toArray(s,0);for(let l=1,h=0;l!==t;++l)h+=e,o[l].toArray(s,h)}return s}function Le(o,t){if(o.length!==t.length)return!1;for(let e=0,n=o.length;e<n;e++)if(o[e]!==t[e])return!1;return!0}function Te(o,t){for(let e=0,n=t.length;e<n;e++)o[e]=t[e]}function eh(o,t){let e=Kc[t];e===void 0&&(e=new Int32Array(t),Kc[t]=e);for(let n=0;n!==t;++n)e[n]=o.allocateTextureUnit();return e}function nx(o,t){const e=this.cache;e[0]!==t&&(o.uniform1f(this.addr,t),e[0]=t)}function ix(o,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(o.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Le(e,t))return;o.uniform2fv(this.addr,t),Te(e,t)}}function rx(o,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(o.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(o.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(Le(e,t))return;o.uniform3fv(this.addr,t),Te(e,t)}}function sx(o,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(o.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Le(e,t))return;o.uniform4fv(this.addr,t),Te(e,t)}}function ox(o,t){const e=this.cache,n=t.elements;if(n===void 0){if(Le(e,t))return;o.uniformMatrix2fv(this.addr,!1,t),Te(e,t)}else{if(Le(e,n))return;th.set(n),o.uniformMatrix2fv(this.addr,!1,th),Te(e,n)}}function ax(o,t){const e=this.cache,n=t.elements;if(n===void 0){if(Le(e,t))return;o.uniformMatrix3fv(this.addr,!1,t),Te(e,t)}else{if(Le(e,n))return;Qc.set(n),o.uniformMatrix3fv(this.addr,!1,Qc),Te(e,n)}}function lx(o,t){const e=this.cache,n=t.elements;if(n===void 0){if(Le(e,t))return;o.uniformMatrix4fv(this.addr,!1,t),Te(e,t)}else{if(Le(e,n))return;Jc.set(n),o.uniformMatrix4fv(this.addr,!1,Jc),Te(e,n)}}function cx(o,t){const e=this.cache;e[0]!==t&&(o.uniform1i(this.addr,t),e[0]=t)}function hx(o,t){const e=this.cache;Le(e,t)||(o.uniform2iv(this.addr,t),Te(e,t))}function ux(o,t){const e=this.cache;Le(e,t)||(o.uniform3iv(this.addr,t),Te(e,t))}function dx(o,t){const e=this.cache;Le(e,t)||(o.uniform4iv(this.addr,t),Te(e,t))}function px(o,t){const e=this.cache;e[0]!==t&&(o.uniform1ui(this.addr,t),e[0]=t)}function fx(o,t){const e=this.cache;Le(e,t)||(o.uniform2uiv(this.addr,t),Te(e,t))}function mx(o,t){const e=this.cache;Le(e,t)||(o.uniform3uiv(this.addr,t),Te(e,t))}function gx(o,t){const e=this.cache;Le(e,t)||(o.uniform4uiv(this.addr,t),Te(e,t))}function vx(o,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(o.uniform1i(this.addr,i),n[0]=i),e.safeSetTexture2D(t||Yc,i)}function _x(o,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(o.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(t||ex,i)}function xx(o,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(o.uniform1i(this.addr,i),n[0]=i),e.safeSetTextureCube(t||Zc,i)}function bx(o,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(o.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(t||tx,i)}function yx(o){switch(o){case 5126:return nx;case 35664:return ix;case 35665:return rx;case 35666:return sx;case 35674:return ox;case 35675:return ax;case 35676:return lx;case 5124:case 35670:return cx;case 35667:case 35671:return hx;case 35668:case 35672:return ux;case 35669:case 35673:return dx;case 5125:return px;case 36294:return fx;case 36295:return mx;case 36296:return gx;case 35678:case 36198:case 36298:case 36306:case 35682:return vx;case 35679:case 36299:case 36307:return _x;case 35680:case 36300:case 36308:case 36293:return xx;case 36289:case 36303:case 36311:case 36292:return bx}}function wx(o,t){o.uniform1fv(this.addr,t)}function Mx(o,t){const e=Ki(t,this.size,2);o.uniform2fv(this.addr,e)}function Sx(o,t){const e=Ki(t,this.size,3);o.uniform3fv(this.addr,e)}function Ex(o,t){const e=Ki(t,this.size,4);o.uniform4fv(this.addr,e)}function Tx(o,t){const e=Ki(t,this.size,4);o.uniformMatrix2fv(this.addr,!1,e)}function Cx(o,t){const e=Ki(t,this.size,9);o.uniformMatrix3fv(this.addr,!1,e)}function Ax(o,t){const e=Ki(t,this.size,16);o.uniformMatrix4fv(this.addr,!1,e)}function Px(o,t){o.uniform1iv(this.addr,t)}function Lx(o,t){o.uniform2iv(this.addr,t)}function Rx(o,t){o.uniform3iv(this.addr,t)}function Dx(o,t){o.uniform4iv(this.addr,t)}function Ix(o,t){o.uniform1uiv(this.addr,t)}function Nx(o,t){o.uniform2uiv(this.addr,t)}function kx(o,t){o.uniform3uiv(this.addr,t)}function Fx(o,t){o.uniform4uiv(this.addr,t)}function Bx(o,t,e){const n=t.length,i=eh(e,n);o.uniform1iv(this.addr,i);for(let s=0;s!==n;++s)e.safeSetTexture2D(t[s]||Yc,i[s])}function Vx(o,t,e){const n=t.length,i=eh(e,n);o.uniform1iv(this.addr,i);for(let s=0;s!==n;++s)e.safeSetTextureCube(t[s]||Zc,i[s])}function Ox(o){switch(o){case 5126:return wx;case 35664:return Mx;case 35665:return Sx;case 35666:return Ex;case 35674:return Tx;case 35675:return Cx;case 35676:return Ax;case 5124:case 35670:return Px;case 35667:case 35671:return Lx;case 35668:case 35672:return Rx;case 35669:case 35673:return Dx;case 5125:return Ix;case 36294:return Nx;case 36295:return kx;case 36296:return Fx;case 35678:case 36198:case 36298:case 36306:case 35682:return Bx;case 35680:case 36300:case 36308:case 36293:return Vx}}function zx(o,t,e){this.id=o,this.addr=e,this.cache=[],this.setValue=yx(t.type)}function nh(o,t,e){this.id=o,this.addr=e,this.cache=[],this.size=t.size,this.setValue=Ox(t.type)}nh.prototype.updateCache=function(o){const t=this.cache;o instanceof Float32Array&&t.length!==o.length&&(this.cache=new Float32Array(o.length)),Te(t,o)};function ih(o){this.id=o,this.seq=[],this.map={}}ih.prototype.setValue=function(o,t,e){const n=this.seq;for(let i=0,s=n.length;i!==s;++i){const l=n[i];l.setValue(o,t[l.id],e)}};const Aa=/(\w+)(\])?(\[|\.)?/g;function rh(o,t){o.seq.push(t),o.map[t.id]=t}function Ux(o,t,e){const n=o.name,i=n.length;for(Aa.lastIndex=0;;){const s=Aa.exec(n),l=Aa.lastIndex;let h=s[1];const u=s[2]==="]",d=s[3];if(u&&(h=h|0),d===void 0||d==="["&&l+2===i){rh(e,d===void 0?new zx(h,o,t):new nh(h,o,t));break}else{let g=e.map[h];g===void 0&&(g=new ih(h),rh(e,g)),e=g}}}function Un(o,t){this.seq=[],this.map={};const e=o.getProgramParameter(t,35718);for(let n=0;n<e;++n){const i=o.getActiveUniform(t,n),s=o.getUniformLocation(t,i.name);Ux(i,s,this)}}Un.prototype.setValue=function(o,t,e,n){const i=this.map[t];i!==void 0&&i.setValue(o,e,n)};Un.prototype.setOptional=function(o,t,e){const n=t[e];n!==void 0&&this.setValue(o,e,n)};Un.upload=function(o,t,e,n){for(let i=0,s=t.length;i!==s;++i){const l=t[i],h=e[l.id];h.needsUpdate!==!1&&l.setValue(o,h.value,n)}};Un.seqWithValue=function(o,t){const e=[];for(let n=0,i=o.length;n!==i;++n){const s=o[n];s.id in t&&e.push(s)}return e};function sh(o,t,e){const n=o.createShader(t);return o.shaderSource(n,e),o.compileShader(n),n}let Hx=0;function Gx(o){const t=o.split(`
`);for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join(`
`)}function oh(o){switch(o){case we:return["Linear","( value )"];case ri:return["sRGB","( value )"];case Wo:return["RGBE","( value )"];case mc:return["RGBM","( value, 7.0 )"];case gc:return["RGBM","( value, 16.0 )"];case vc:return["RGBD","( value, 256.0 )"];case Go:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case km:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",o),["Linear","( value )"]}}function ah(o,t,e){const n=o.getShaderParameter(t,35713),i=o.getShaderInfoLog(t).trim();return n&&i===""?"":e.toUpperCase()+`

`+i+`

`+Gx(o.getShaderSource(t))}function Ji(o,t){const e=oh(t);return"vec4 "+o+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function Wx(o,t){const e=oh(t);return"vec4 "+o+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function qx(o,t){let e;switch(t){case If:e="Linear";break;case Nf:e="Reinhard";break;case kf:e="OptimizedCineon";break;case Ff:e="ACESFilmic";break;case Bf:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+o+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function jx(o){return[o.extensionDerivatives||o.envMapCubeUV||o.bumpMap||o.tangentSpaceNormalMap||o.clearcoatNormalMap||o.flatShading||o.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(o.extensionFragDepth||o.logarithmicDepthBuffer)&&o.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",o.extensionDrawBuffers&&o.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(o.extensionShaderTextureLOD||o.envMap||o.transmission)&&o.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Dr).join(`
`)}function Xx(o){const t=[];for(const e in o){const n=o[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function Yx(o,t){const e={},n=o.getProgramParameter(t,35721);for(let i=0;i<n;i++){const s=o.getActiveAttrib(t,i),l=s.name;let h=1;s.type===35674&&(h=2),s.type===35675&&(h=3),s.type===35676&&(h=4),e[l]={type:s.type,location:o.getAttribLocation(t,l),locationSize:h}}return e}function Dr(o){return o!==""}function lh(o,t){return o.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function ch(o,t){return o.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Zx=/^[ \t]*#include +<([\w\d./]+)>/gm;function Pa(o){return o.replace(Zx,$x)}function $x(o,t){const e=Ht[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return Pa(e)}const Kx=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Jx=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function hh(o){return o.replace(Jx,uh).replace(Kx,Qx)}function Qx(o,t,e,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),uh(o,t,e,n)}function uh(o,t,e,n){let i="";for(let s=parseInt(t);s<parseInt(e);s++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function dh(o){let t="precision "+o.precision+` float;
precision `+o.precision+" int;";return o.precision==="highp"?t+=`
#define HIGH_PRECISION`:o.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:o.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function t0(o){let t="SHADOWMAP_TYPE_BASIC";return o.shadowMapType===jl?t="SHADOWMAP_TYPE_PCF":o.shadowMapType===uf?t="SHADOWMAP_TYPE_PCF_SOFT":o.shadowMapType===br&&(t="SHADOWMAP_TYPE_VSM"),t}function e0(o){let t="ENVMAP_TYPE_CUBE";if(o.envMap)switch(o.envMapMode){case hs:case us:t="ENVMAP_TYPE_CUBE";break;case ds:case Vo:t="ENVMAP_TYPE_CUBE_UV";break}return t}function n0(o){let t="ENVMAP_MODE_REFLECTION";if(o.envMap)switch(o.envMapMode){case us:case Vo:t="ENVMAP_MODE_REFRACTION";break}return t}function i0(o){let t="ENVMAP_BLENDING_NONE";if(o.envMap)switch(o.combine){case cs:t="ENVMAP_BLENDING_MULTIPLY";break;case Rf:t="ENVMAP_BLENDING_MIX";break;case Df:t="ENVMAP_BLENDING_ADD";break}return t}function r0(o,t,e,n){const i=o.getContext(),s=e.defines;let l=e.vertexShader,h=e.fragmentShader;const u=t0(e),d=e0(e),f=n0(e),g=i0(e),m=o.gammaFactor>0?o.gammaFactor:1,v=e.isWebGL2?"":jx(e),b=Xx(s),w=i.createProgram();let M,x,_=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(M=[b].filter(Dr).join(`
`),M.length>0&&(M+=`
`),x=[v,b].filter(Dr).join(`
`),x.length>0&&(x+=`
`)):(M=[dh(e),"#define SHADER_NAME "+e.shaderName,b,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+m,"#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+f:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularTintMap?"#define USE_SPECULARTINTMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphTargets&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",e.morphTargets&&e.isWebGL2?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+u:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Dr).join(`
`),x=[v,dh(e),"#define SHADER_NAME "+e.shaderName,b,"#define GAMMA_FACTOR "+m,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+d:"",e.envMap?"#define "+f:"",e.envMap?"#define "+g:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularTintMap?"#define USE_SPECULARTINTMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheen?"#define USE_SHEEN":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+u:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==ii?"#define TONE_MAPPING":"",e.toneMapping!==ii?Ht.tonemapping_pars_fragment:"",e.toneMapping!==ii?qx("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.format===Ei?"#define OPAQUE":"",Ht.encodings_pars_fragment,e.map?Ji("mapTexelToLinear",e.mapEncoding):"",e.matcap?Ji("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?Ji("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?Ji("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.specularTintMap?Ji("specularTintMapTexelToLinear",e.specularTintMapEncoding):"",e.lightMap?Ji("lightMapTexelToLinear",e.lightMapEncoding):"",Wx("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Dr).join(`
`)),l=Pa(l),l=lh(l,e),l=ch(l,e),h=Pa(h),h=lh(h,e),h=ch(h,e),l=hh(l),h=hh(h),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(_=`#version 300 es
`,M=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+M,x=["#define varying in",e.glslVersion===_c?"":"out highp vec4 pc_fragColor;",e.glslVersion===_c?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+x);const R=_+M+l,C=_+x+h,P=sh(i,35633,R),N=sh(i,35632,C);if(i.attachShader(w,P),i.attachShader(w,N),e.index0AttributeName!==void 0?i.bindAttribLocation(w,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(w,0,"position"),i.linkProgram(w),o.debug.checkShaderErrors){const nt=i.getProgramInfoLog(w).trim(),Y=i.getShaderInfoLog(P).trim(),k=i.getShaderInfoLog(N).trim();let ht=!0,G=!0;if(i.getProgramParameter(w,35714)===!1){ht=!1;const j=ah(i,P,"vertex"),W=ah(i,N,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(w,35715)+`

Program Info Log: `+nt+`
`+j+`
`+W)}else nt!==""?console.warn("THREE.WebGLProgram: Program Info Log:",nt):(Y===""||k==="")&&(G=!1);G&&(this.diagnostics={runnable:ht,programLog:nt,vertexShader:{log:Y,prefix:M},fragmentShader:{log:k,prefix:x}})}i.deleteShader(P),i.deleteShader(N);let T;this.getUniforms=function(){return T===void 0&&(T=new Un(i,w)),T};let H;return this.getAttributes=function(){return H===void 0&&(H=Yx(i,w)),H},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(w),this.program=void 0},this.name=e.shaderName,this.id=Hx++,this.cacheKey=t,this.usedTimes=1,this.program=w,this.vertexShader=P,this.fragmentShader=N,this}function s0(o,t,e,n,i,s,l){const h=[],u=i.isWebGL2,d=i.logarithmicDepthBuffer,f=i.floatVertexTextures,g=i.maxVertexUniforms,m=i.vertexTextures;let v=i.precision;const b={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},w=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","specularIntensityMap","specularTintMap","specularTintMapEncoding","roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","morphTargetsCount","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","sheen","transmission","transmissionMap","thicknessMap"];function M(T){const nt=T.skeleton.bones;if(f)return 1024;{const k=Math.floor((g-20)/4),ht=Math.min(k,nt.length);return ht<nt.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+nt.length+" bones. This GPU supports "+ht+"."),0):ht}}function x(T){let H;return T&&T.isTexture?H=T.encoding:T&&T.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),H=T.texture.encoding):H=we,u&&T&&T.isTexture&&T.format===Pe&&T.type===Pn&&T.encoding===ri&&(H=we),H}function _(T,H,nt,Y,k){const ht=Y.fog,G=T.isMeshStandardMaterial?Y.environment:null,j=(T.isMeshStandardMaterial?e:t).get(T.envMap||G),W=b[T.type],B=k.isSkinnedMesh?M(k):0;T.precision!==null&&(v=i.getMaxPrecision(T.precision),v!==T.precision&&console.warn("THREE.WebGLProgram.getParameters:",T.precision,"not supported, using",v,"instead."));let X,at;if(W){const K=ln[W];X=K.vertexShader,at=K.fragmentShader}else X=T.vertexShader,at=T.fragmentShader;const yt=o.getRenderTarget(),bt=T.alphaTest>0,mt=T.clearcoat>0;return{isWebGL2:u,shaderID:W,shaderName:T.type,vertexShader:X,fragmentShader:at,defines:T.defines,isRawShaderMaterial:T.isRawShaderMaterial===!0,glslVersion:T.glslVersion,precision:v,instancing:k.isInstancedMesh===!0,instancingColor:k.isInstancedMesh===!0&&k.instanceColor!==null,supportsVertexTextures:m,outputEncoding:yt!==null?x(yt.texture):o.outputEncoding,map:!!T.map,mapEncoding:x(T.map),matcap:!!T.matcap,matcapEncoding:x(T.matcap),envMap:!!j,envMapMode:j&&j.mapping,envMapEncoding:x(j),envMapCubeUV:!!j&&(j.mapping===ds||j.mapping===Vo),lightMap:!!T.lightMap,lightMapEncoding:x(T.lightMap),aoMap:!!T.aoMap,emissiveMap:!!T.emissiveMap,emissiveMapEncoding:x(T.emissiveMap),bumpMap:!!T.bumpMap,normalMap:!!T.normalMap,objectSpaceNormalMap:T.normalMapType===Vm,tangentSpaceNormalMap:T.normalMapType===Pi,clearcoat:mt,clearcoatMap:mt&&!!T.clearcoatMap,clearcoatRoughnessMap:mt&&!!T.clearcoatRoughnessMap,clearcoatNormalMap:mt&&!!T.clearcoatNormalMap,displacementMap:!!T.displacementMap,roughnessMap:!!T.roughnessMap,metalnessMap:!!T.metalnessMap,specularMap:!!T.specularMap,specularIntensityMap:!!T.specularIntensityMap,specularTintMap:!!T.specularTintMap,specularTintMapEncoding:x(T.specularTintMap),alphaMap:!!T.alphaMap,alphaTest:bt,gradientMap:!!T.gradientMap,sheen:T.sheen>0,transmission:T.transmission>0,transmissionMap:!!T.transmissionMap,thicknessMap:!!T.thicknessMap,combine:T.combine,vertexTangents:!!T.normalMap&&!!k.geometry&&!!k.geometry.attributes.tangent,vertexColors:T.vertexColors,vertexAlphas:T.vertexColors===!0&&!!k.geometry&&!!k.geometry.attributes.color&&k.geometry.attributes.color.itemSize===4,vertexUvs:!!T.map||!!T.bumpMap||!!T.normalMap||!!T.specularMap||!!T.alphaMap||!!T.emissiveMap||!!T.roughnessMap||!!T.metalnessMap||!!T.clearcoatMap||!!T.clearcoatRoughnessMap||!!T.clearcoatNormalMap||!!T.displacementMap||!!T.transmissionMap||!!T.thicknessMap||!!T.specularIntensityMap||!!T.specularTintMap,uvsVertexOnly:!(!!T.map||!!T.bumpMap||!!T.normalMap||!!T.specularMap||!!T.alphaMap||!!T.emissiveMap||!!T.roughnessMap||!!T.metalnessMap||!!T.clearcoatNormalMap||T.transmission>0||!!T.transmissionMap||!!T.thicknessMap||!!T.specularIntensityMap||!!T.specularTintMap)&&!!T.displacementMap,fog:!!ht,useFog:T.fog,fogExp2:ht&&ht.isFogExp2,flatShading:!!T.flatShading,sizeAttenuation:T.sizeAttenuation,logarithmicDepthBuffer:d,skinning:k.isSkinnedMesh===!0&&B>0,maxBones:B,useVertexTexture:f,morphTargets:!!k.geometry&&!!k.geometry.morphAttributes.position,morphNormals:!!k.geometry&&!!k.geometry.morphAttributes.normal,morphTargetsCount:!!k.geometry&&!!k.geometry.morphAttributes.position?k.geometry.morphAttributes.position.length:0,numDirLights:H.directional.length,numPointLights:H.point.length,numSpotLights:H.spot.length,numRectAreaLights:H.rectArea.length,numHemiLights:H.hemi.length,numDirLightShadows:H.directionalShadowMap.length,numPointLightShadows:H.pointShadowMap.length,numSpotLightShadows:H.spotShadowMap.length,numClippingPlanes:l.numPlanes,numClipIntersection:l.numIntersection,format:T.format,dithering:T.dithering,shadowMapEnabled:o.shadowMap.enabled&&nt.length>0,shadowMapType:o.shadowMap.type,toneMapping:T.toneMapped?o.toneMapping:ii,physicallyCorrectLights:o.physicallyCorrectLights,premultipliedAlpha:T.premultipliedAlpha,doubleSided:T.side===wi,flipSided:T.side===de,depthPacking:T.depthPacking!==void 0?T.depthPacking:!1,index0AttributeName:T.index0AttributeName,extensionDerivatives:T.extensions&&T.extensions.derivatives,extensionFragDepth:T.extensions&&T.extensions.fragDepth,extensionDrawBuffers:T.extensions&&T.extensions.drawBuffers,extensionShaderTextureLOD:T.extensions&&T.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||n.has("EXT_shader_texture_lod"),customProgramCacheKey:T.customProgramCacheKey()}}function R(T){const H=[];if(T.shaderID?H.push(T.shaderID):(H.push(T.fragmentShader),H.push(T.vertexShader)),T.defines!==void 0)for(const nt in T.defines)H.push(nt),H.push(T.defines[nt]);if(T.isRawShaderMaterial===!1){for(let nt=0;nt<w.length;nt++)H.push(T[w[nt]]);H.push(o.outputEncoding),H.push(o.gammaFactor)}return H.push(T.customProgramCacheKey),H.join()}function C(T){const H=b[T.type];let nt;if(H){const Y=ln[H];nt=ig.clone(Y.uniforms)}else nt=T.uniforms;return nt}function P(T,H){let nt;for(let Y=0,k=h.length;Y<k;Y++){const ht=h[Y];if(ht.cacheKey===H){nt=ht,++nt.usedTimes;break}}return nt===void 0&&(nt=new r0(o,H,T,s),h.push(nt)),nt}function N(T){if(--T.usedTimes==0){const H=h.indexOf(T);h[H]=h[h.length-1],h.pop(),T.destroy()}}return{getParameters:_,getProgramCacheKey:R,getUniforms:C,acquireProgram:P,releaseProgram:N,programs:h}}function o0(){let o=new WeakMap;function t(s){let l=o.get(s);return l===void 0&&(l={},o.set(s,l)),l}function e(s){o.delete(s)}function n(s,l,h){o.get(s)[l]=h}function i(){o=new WeakMap}return{get:t,remove:e,update:n,dispose:i}}function a0(o,t){return o.groupOrder!==t.groupOrder?o.groupOrder-t.groupOrder:o.renderOrder!==t.renderOrder?o.renderOrder-t.renderOrder:o.program!==t.program?o.program.id-t.program.id:o.material.id!==t.material.id?o.material.id-t.material.id:o.z!==t.z?o.z-t.z:o.id-t.id}function ph(o,t){return o.groupOrder!==t.groupOrder?o.groupOrder-t.groupOrder:o.renderOrder!==t.renderOrder?o.renderOrder-t.renderOrder:o.z!==t.z?t.z-o.z:o.id-t.id}function fh(o){const t=[];let e=0;const n=[],i=[],s=[],l={id:-1};function h(){e=0,n.length=0,i.length=0,s.length=0}function u(v,b,w,M,x,_){let R=t[e];const C=o.get(w);return R===void 0?(R={id:v.id,object:v,geometry:b,material:w,program:C.program||l,groupOrder:M,renderOrder:v.renderOrder,z:x,group:_},t[e]=R):(R.id=v.id,R.object=v,R.geometry=b,R.material=w,R.program=C.program||l,R.groupOrder=M,R.renderOrder=v.renderOrder,R.z=x,R.group=_),e++,R}function d(v,b,w,M,x,_){const R=u(v,b,w,M,x,_);w.transmission>0?i.push(R):w.transparent===!0?s.push(R):n.push(R)}function f(v,b,w,M,x,_){const R=u(v,b,w,M,x,_);w.transmission>0?i.unshift(R):w.transparent===!0?s.unshift(R):n.unshift(R)}function g(v,b){n.length>1&&n.sort(v||a0),i.length>1&&i.sort(b||ph),s.length>1&&s.sort(b||ph)}function m(){for(let v=e,b=t.length;v<b;v++){const w=t[v];if(w.id===null)break;w.id=null,w.object=null,w.geometry=null,w.material=null,w.program=null,w.group=null}}return{opaque:n,transmissive:i,transparent:s,init:h,push:d,unshift:f,finish:m,sort:g}}function l0(o){let t=new WeakMap;function e(i,s){let l;return t.has(i)===!1?(l=new fh(o),t.set(i,[l])):s>=t.get(i).length?(l=new fh(o),t.get(i).push(l)):l=t.get(i)[s],l}function n(){t=new WeakMap}return{get:e,dispose:n}}function c0(){const o={};return{get:function(t){if(o[t.id]!==void 0)return o[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new L,color:new Ct};break;case"SpotLight":e={position:new L,direction:new L,color:new Ct,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new L,color:new Ct,distance:0,decay:0};break;case"HemisphereLight":e={direction:new L,skyColor:new Ct,groundColor:new Ct};break;case"RectAreaLight":e={color:new Ct,position:new L,halfWidth:new L,halfHeight:new L};break}return o[t.id]=e,e}}}function h0(){const o={};return{get:function(t){if(o[t.id]!==void 0)return o[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new tt};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new tt};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new tt,shadowCameraNear:1,shadowCameraFar:1e3};break}return o[t.id]=e,e}}}let u0=0;function d0(o,t){return(t.castShadow?1:0)-(o.castShadow?1:0)}function p0(o,t){const e=new c0,n=h0(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let f=0;f<9;f++)i.probe.push(new L);const s=new L,l=new It,h=new It;function u(f,g){let m=0,v=0,b=0;for(let nt=0;nt<9;nt++)i.probe[nt].set(0,0,0);let w=0,M=0,x=0,_=0,R=0,C=0,P=0,N=0;f.sort(d0);const T=g!==!0?Math.PI:1;for(let nt=0,Y=f.length;nt<Y;nt++){const k=f[nt],ht=k.color,G=k.intensity,j=k.distance,W=k.shadow&&k.shadow.map?k.shadow.map.texture:null;if(k.isAmbientLight)m+=ht.r*G*T,v+=ht.g*G*T,b+=ht.b*G*T;else if(k.isLightProbe)for(let B=0;B<9;B++)i.probe[B].addScaledVector(k.sh.coefficients[B],G);else if(k.isDirectionalLight){const B=e.get(k);if(B.color.copy(k.color).multiplyScalar(k.intensity*T),k.castShadow){const X=k.shadow,at=n.get(k);at.shadowBias=X.bias,at.shadowNormalBias=X.normalBias,at.shadowRadius=X.radius,at.shadowMapSize=X.mapSize,i.directionalShadow[w]=at,i.directionalShadowMap[w]=W,i.directionalShadowMatrix[w]=k.shadow.matrix,C++}i.directional[w]=B,w++}else if(k.isSpotLight){const B=e.get(k);if(B.position.setFromMatrixPosition(k.matrixWorld),B.color.copy(ht).multiplyScalar(G*T),B.distance=j,B.coneCos=Math.cos(k.angle),B.penumbraCos=Math.cos(k.angle*(1-k.penumbra)),B.decay=k.decay,k.castShadow){const X=k.shadow,at=n.get(k);at.shadowBias=X.bias,at.shadowNormalBias=X.normalBias,at.shadowRadius=X.radius,at.shadowMapSize=X.mapSize,i.spotShadow[x]=at,i.spotShadowMap[x]=W,i.spotShadowMatrix[x]=k.shadow.matrix,N++}i.spot[x]=B,x++}else if(k.isRectAreaLight){const B=e.get(k);B.color.copy(ht).multiplyScalar(G),B.halfWidth.set(k.width*.5,0,0),B.halfHeight.set(0,k.height*.5,0),i.rectArea[_]=B,_++}else if(k.isPointLight){const B=e.get(k);if(B.color.copy(k.color).multiplyScalar(k.intensity*T),B.distance=k.distance,B.decay=k.decay,k.castShadow){const X=k.shadow,at=n.get(k);at.shadowBias=X.bias,at.shadowNormalBias=X.normalBias,at.shadowRadius=X.radius,at.shadowMapSize=X.mapSize,at.shadowCameraNear=X.camera.near,at.shadowCameraFar=X.camera.far,i.pointShadow[M]=at,i.pointShadowMap[M]=W,i.pointShadowMatrix[M]=k.shadow.matrix,P++}i.point[M]=B,M++}else if(k.isHemisphereLight){const B=e.get(k);B.skyColor.copy(k.color).multiplyScalar(G*T),B.groundColor.copy(k.groundColor).multiplyScalar(G*T),i.hemi[R]=B,R++}}_>0&&(t.isWebGL2||o.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=ft.LTC_FLOAT_1,i.rectAreaLTC2=ft.LTC_FLOAT_2):o.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=ft.LTC_HALF_1,i.rectAreaLTC2=ft.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=m,i.ambient[1]=v,i.ambient[2]=b;const H=i.hash;(H.directionalLength!==w||H.pointLength!==M||H.spotLength!==x||H.rectAreaLength!==_||H.hemiLength!==R||H.numDirectionalShadows!==C||H.numPointShadows!==P||H.numSpotShadows!==N)&&(i.directional.length=w,i.spot.length=x,i.rectArea.length=_,i.point.length=M,i.hemi.length=R,i.directionalShadow.length=C,i.directionalShadowMap.length=C,i.pointShadow.length=P,i.pointShadowMap.length=P,i.spotShadow.length=N,i.spotShadowMap.length=N,i.directionalShadowMatrix.length=C,i.pointShadowMatrix.length=P,i.spotShadowMatrix.length=N,H.directionalLength=w,H.pointLength=M,H.spotLength=x,H.rectAreaLength=_,H.hemiLength=R,H.numDirectionalShadows=C,H.numPointShadows=P,H.numSpotShadows=N,i.version=u0++)}function d(f,g){let m=0,v=0,b=0,w=0,M=0;const x=g.matrixWorldInverse;for(let _=0,R=f.length;_<R;_++){const C=f[_];if(C.isDirectionalLight){const P=i.directional[m];P.direction.setFromMatrixPosition(C.matrixWorld),s.setFromMatrixPosition(C.target.matrixWorld),P.direction.sub(s),P.direction.transformDirection(x),m++}else if(C.isSpotLight){const P=i.spot[b];P.position.setFromMatrixPosition(C.matrixWorld),P.position.applyMatrix4(x),P.direction.setFromMatrixPosition(C.matrixWorld),s.setFromMatrixPosition(C.target.matrixWorld),P.direction.sub(s),P.direction.transformDirection(x),b++}else if(C.isRectAreaLight){const P=i.rectArea[w];P.position.setFromMatrixPosition(C.matrixWorld),P.position.applyMatrix4(x),h.identity(),l.copy(C.matrixWorld),l.premultiply(x),h.extractRotation(l),P.halfWidth.set(C.width*.5,0,0),P.halfHeight.set(0,C.height*.5,0),P.halfWidth.applyMatrix4(h),P.halfHeight.applyMatrix4(h),w++}else if(C.isPointLight){const P=i.point[v];P.position.setFromMatrixPosition(C.matrixWorld),P.position.applyMatrix4(x),v++}else if(C.isHemisphereLight){const P=i.hemi[M];P.direction.setFromMatrixPosition(C.matrixWorld),P.direction.transformDirection(x),P.direction.normalize(),M++}}}return{setup:u,setupView:d,state:i}}function mh(o,t){const e=new p0(o,t),n=[],i=[];function s(){n.length=0,i.length=0}function l(g){n.push(g)}function h(g){i.push(g)}function u(g){e.setup(n,g)}function d(g){e.setupView(n,g)}return{init:s,state:{lightsArray:n,shadowsArray:i,lights:e},setupLights:u,setupLightsView:d,pushLight:l,pushShadow:h}}function f0(o,t){let e=new WeakMap;function n(s,l=0){let h;return e.has(s)===!1?(h=new mh(o,t),e.set(s,[h])):l>=e.get(s).length?(h=new mh(o,t),e.get(s).push(h)):h=e.get(s)[l],h}function i(){e=new WeakMap}return{get:n,dispose:i}}class gh extends Se{constructor(t){super();this.type="MeshDepthMaterial",this.depthPacking=Fm,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}gh.prototype.isMeshDepthMaterial=!0;class vh extends Se{constructor(t){super();this.type="MeshDistanceMaterial",this.referencePosition=new L,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}vh.prototype.isMeshDistanceMaterial=!0;const m0=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,g0=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
uniform float samples;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function _h(o,t,e){let n=new Os;const i=new tt,s=new tt,l=new Qt,h=new gh({depthPacking:Bm}),u=new vh,d={},f=e.maxTextureSize,g={0:de,1:yr,2:wi},m=new ai({uniforms:{shadow_pass:{value:null},resolution:{value:new tt},radius:{value:4},samples:{value:8}},vertexShader:m0,fragmentShader:g0}),v=m.clone();v.defines.HORIZONTAL_PASS=1;const b=new ae;b.setAttribute("position",new pe(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const w=new Fe(b,m),M=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=jl,this.render=function(C,P,N){if(M.enabled===!1||M.autoUpdate===!1&&M.needsUpdate===!1||C.length===0)return;const T=o.getRenderTarget(),H=o.getActiveCubeFace(),nt=o.getActiveMipmapLevel(),Y=o.state;Y.setBlending(An),Y.buffers.color.setClear(1,1,1,1),Y.buffers.depth.setTest(!0),Y.setScissorTest(!1);for(let k=0,ht=C.length;k<ht;k++){const G=C[k],j=G.shadow;if(j===void 0){console.warn("THREE.WebGLShadowMap:",G,"has no shadow.");continue}if(j.autoUpdate===!1&&j.needsUpdate===!1)continue;i.copy(j.mapSize);const W=j.getFrameExtents();if(i.multiply(W),s.copy(j.mapSize),(i.x>f||i.y>f)&&(i.x>f&&(s.x=Math.floor(f/W.x),i.x=s.x*W.x,j.mapSize.x=s.x),i.y>f&&(s.y=Math.floor(f/W.y),i.y=s.y*W.y,j.mapSize.y=s.y)),j.map===null&&!j.isPointLightShadow&&this.type===br){const X={minFilter:je,magFilter:je,format:Pe};j.map=new an(i.x,i.y,X),j.map.texture.name=G.name+".shadowMap",j.mapPass=new an(i.x,i.y,X),j.camera.updateProjectionMatrix()}if(j.map===null){const X={minFilter:fe,magFilter:fe,format:Pe};j.map=new an(i.x,i.y,X),j.map.texture.name=G.name+".shadowMap",j.camera.updateProjectionMatrix()}o.setRenderTarget(j.map),o.clear();const B=j.getViewportCount();for(let X=0;X<B;X++){const at=j.getViewport(X);l.set(s.x*at.x,s.y*at.y,s.x*at.z,s.y*at.w),Y.viewport(l),j.updateMatrices(G,X),n=j.getFrustum(),R(P,N,j.camera,G,this.type)}!j.isPointLightShadow&&this.type===br&&x(j,N),j.needsUpdate=!1}M.needsUpdate=!1,o.setRenderTarget(T,H,nt)};function x(C,P){const N=t.update(w);m.uniforms.shadow_pass.value=C.map.texture,m.uniforms.resolution.value=C.mapSize,m.uniforms.radius.value=C.radius,m.uniforms.samples.value=C.blurSamples,o.setRenderTarget(C.mapPass),o.clear(),o.renderBufferDirect(P,null,N,m,w,null),v.uniforms.shadow_pass.value=C.mapPass.texture,v.uniforms.resolution.value=C.mapSize,v.uniforms.radius.value=C.radius,v.uniforms.samples.value=C.blurSamples,o.setRenderTarget(C.map),o.clear(),o.renderBufferDirect(P,null,N,v,w,null)}function _(C,P,N,T,H,nt,Y){let k=null;const ht=T.isPointLight===!0?C.customDistanceMaterial:C.customDepthMaterial;if(ht!==void 0?k=ht:k=T.isPointLight===!0?u:h,o.localClippingEnabled&&N.clipShadows===!0&&N.clippingPlanes.length!==0||N.displacementMap&&N.displacementScale!==0||N.alphaMap&&N.alphaTest>0){const G=k.uuid,j=N.uuid;let W=d[G];W===void 0&&(W={},d[G]=W);let B=W[j];B===void 0&&(B=k.clone(),W[j]=B),k=B}return k.visible=N.visible,k.wireframe=N.wireframe,Y===br?k.side=N.shadowSide!==null?N.shadowSide:N.side:k.side=N.shadowSide!==null?N.shadowSide:g[N.side],k.alphaMap=N.alphaMap,k.alphaTest=N.alphaTest,k.clipShadows=N.clipShadows,k.clippingPlanes=N.clippingPlanes,k.clipIntersection=N.clipIntersection,k.displacementMap=N.displacementMap,k.displacementScale=N.displacementScale,k.displacementBias=N.displacementBias,k.wireframeLinewidth=N.wireframeLinewidth,k.linewidth=N.linewidth,T.isPointLight===!0&&k.isMeshDistanceMaterial===!0&&(k.referencePosition.setFromMatrixPosition(T.matrixWorld),k.nearDistance=H,k.farDistance=nt),k}function R(C,P,N,T,H){if(C.visible===!1)return;if(C.layers.test(P.layers)&&(C.isMesh||C.isLine||C.isPoints)&&(C.castShadow||C.receiveShadow&&H===br)&&(!C.frustumCulled||n.intersectsObject(C))){C.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse,C.matrixWorld);const k=t.update(C),ht=C.material;if(Array.isArray(ht)){const G=k.groups;for(let j=0,W=G.length;j<W;j++){const B=G[j],X=ht[B.materialIndex];if(X&&X.visible){const at=_(C,k,X,T,N.near,N.far,H);o.renderBufferDirect(N,null,k,at,C,B)}}}else if(ht.visible){const G=_(C,k,ht,T,N.near,N.far,H);o.renderBufferDirect(N,null,k,G,C,null)}}const Y=C.children;for(let k=0,ht=Y.length;k<ht;k++)R(Y[k],P,N,T,H)}}function v0(o,t,e){const n=e.isWebGL2;function i(){let F=!1;const pt=new Qt;let J=null;const gt=new Qt(0,0,0,0);return{setMask:function(D){J!==D&&!F&&(o.colorMask(D,D,D,D),J=D)},setLocked:function(D){F=D},setClear:function(D,ot,Ot,zt,ie){ie===!0&&(D*=zt,ot*=zt,Ot*=zt),pt.set(D,ot,Ot,zt),gt.equals(pt)===!1&&(o.clearColor(D,ot,Ot,zt),gt.copy(pt))},reset:function(){F=!1,J=null,gt.set(-1,0,0,0)}}}function s(){let F=!1,pt=null,J=null,gt=null;return{setTest:function(D){D?st(2929):wt(2929)},setMask:function(D){pt!==D&&!F&&(o.depthMask(D),pt=D)},setFunc:function(D){if(J!==D){if(D)switch(D){case Sf:o.depthFunc(512);break;case Ef:o.depthFunc(519);break;case Tf:o.depthFunc(513);break;case ko:o.depthFunc(515);break;case Cf:o.depthFunc(514);break;case Af:o.depthFunc(518);break;case Pf:o.depthFunc(516);break;case Lf:o.depthFunc(517);break;default:o.depthFunc(515)}else o.depthFunc(515);J=D}},setLocked:function(D){F=D},setClear:function(D){gt!==D&&(o.clearDepth(D),gt=D)},reset:function(){F=!1,pt=null,J=null,gt=null}}}function l(){let F=!1,pt=null,J=null,gt=null,D=null,ot=null,Ot=null,zt=null,ie=null;return{setTest:function(Zt){F||(Zt?st(2960):wt(2960))},setMask:function(Zt){pt!==Zt&&!F&&(o.stencilMask(Zt),pt=Zt)},setFunc:function(Zt,be,Re){(J!==Zt||gt!==be||D!==Re)&&(o.stencilFunc(Zt,be,Re),J=Zt,gt=be,D=Re)},setOp:function(Zt,be,Re){(ot!==Zt||Ot!==be||zt!==Re)&&(o.stencilOp(Zt,be,Re),ot=Zt,Ot=be,zt=Re)},setLocked:function(Zt){F=Zt},setClear:function(Zt){ie!==Zt&&(o.clearStencil(Zt),ie=Zt)},reset:function(){F=!1,pt=null,J=null,gt=null,D=null,ot=null,Ot=null,zt=null,ie=null}}}const h=new i,u=new s,d=new l;let f={},g=null,m={},v=null,b=!1,w=null,M=null,x=null,_=null,R=null,C=null,P=null,N=!1,T=null,H=null,nt=null,Y=null,k=null;const ht=o.getParameter(35661);let G=!1,j=0;const W=o.getParameter(7938);W.indexOf("WebGL")!==-1?(j=parseFloat(/^WebGL (\d)/.exec(W)[1]),G=j>=1):W.indexOf("OpenGL ES")!==-1&&(j=parseFloat(/^OpenGL ES (\d)/.exec(W)[1]),G=j>=2);let B=null,X={};const at=o.getParameter(3088),yt=o.getParameter(2978),bt=new Qt().fromArray(at),mt=new Qt().fromArray(yt);function vt(F,pt,J){const gt=new Uint8Array(4),D=o.createTexture();o.bindTexture(F,D),o.texParameteri(F,10241,9728),o.texParameteri(F,10240,9728);for(let ot=0;ot<J;ot++)o.texImage2D(pt+ot,0,6408,1,1,0,6408,5121,gt);return D}const K={};K[3553]=vt(3553,3553,1),K[34067]=vt(34067,34069,6),h.setClear(0,0,0,1),u.setClear(1),d.setClear(0),st(2929),u.setFunc(ko),et(!1),lt(ql),st(2884),kt(An);function st(F){f[F]!==!0&&(o.enable(F),f[F]=!0)}function wt(F){f[F]!==!1&&(o.disable(F),f[F]=!1)}function q(F){F!==g&&(o.bindFramebuffer(36160,F),g=F)}function Tt(F,pt){return pt===null&&g!==null&&(pt=g),m[F]!==pt?(o.bindFramebuffer(F,pt),m[F]=pt,n&&(F===36009&&(m[36160]=pt),F===36160&&(m[36009]=pt)),!0):!1}function At(F){return v!==F?(o.useProgram(F),v=F,!0):!1}const ut={[Mi]:32774,[pf]:32778,[ff]:32779};if(n)ut[Kl]=32775,ut[Jl]=32776;else{const F=t.get("EXT_blend_minmax");F!==null&&(ut[Kl]=F.MIN_EXT,ut[Jl]=F.MAX_EXT)}const xt={[mf]:0,[gf]:1,[vf]:768,[Ql]:770,[Mf]:776,[yf]:774,[xf]:772,[_f]:769,[tc]:771,[wf]:775,[bf]:773};function kt(F,pt,J,gt,D,ot,Ot,zt){if(F===An){b===!0&&(wt(3042),b=!1);return}if(b===!1&&(st(3042),b=!0),F!==df){if(F!==w||zt!==N){if((M!==Mi||R!==Mi)&&(o.blendEquation(32774),M=Mi,R=Mi),zt)switch(F){case wr:o.blendFuncSeparate(1,771,1,771);break;case Yl:o.blendFunc(1,1);break;case Zl:o.blendFuncSeparate(0,0,769,771);break;case $l:o.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",F);break}else switch(F){case wr:o.blendFuncSeparate(770,771,1,771);break;case Yl:o.blendFunc(770,1);break;case Zl:o.blendFunc(0,769);break;case $l:o.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",F);break}x=null,_=null,C=null,P=null,w=F,N=zt}return}D=D||pt,ot=ot||J,Ot=Ot||gt,(pt!==M||D!==R)&&(o.blendEquationSeparate(ut[pt],ut[D]),M=pt,R=D),(J!==x||gt!==_||ot!==C||Ot!==P)&&(o.blendFuncSeparate(xt[J],xt[gt],xt[ot],xt[Ot]),x=J,_=gt,C=ot,P=Ot),w=F,N=null}function $(F,pt){F.side===wi?wt(2884):st(2884);let J=F.side===de;pt&&(J=!J),et(J),F.blending===wr&&F.transparent===!1?kt(An):kt(F.blending,F.blendEquation,F.blendSrc,F.blendDst,F.blendEquationAlpha,F.blendSrcAlpha,F.blendDstAlpha,F.premultipliedAlpha),u.setFunc(F.depthFunc),u.setTest(F.depthTest),u.setMask(F.depthWrite),h.setMask(F.colorWrite);const gt=F.stencilWrite;d.setTest(gt),gt&&(d.setMask(F.stencilWriteMask),d.setFunc(F.stencilFunc,F.stencilRef,F.stencilFuncMask),d.setOp(F.stencilFail,F.stencilZFail,F.stencilZPass)),dt(F.polygonOffset,F.polygonOffsetFactor,F.polygonOffsetUnits),F.alphaToCoverage===!0?st(32926):wt(32926)}function et(F){T!==F&&(F?o.frontFace(2304):o.frontFace(2305),T=F)}function lt(F){F!==cf?(st(2884),F!==H&&(F===ql?o.cullFace(1029):F===hf?o.cullFace(1028):o.cullFace(1032))):wt(2884),H=F}function Mt(F){F!==nt&&(G&&o.lineWidth(F),nt=F)}function dt(F,pt,J){F?(st(32823),(Y!==pt||k!==J)&&(o.polygonOffset(pt,J),Y=pt,k=J)):wt(32823)}function A(F){F?st(3089):wt(3089)}function E(F){F===void 0&&(F=33984+ht-1),B!==F&&(o.activeTexture(F),B=F)}function Z(F,pt){B===null&&E();let J=X[B];J===void 0&&(J={type:void 0,texture:void 0},X[B]=J),(J.type!==F||J.texture!==pt)&&(o.bindTexture(F,pt||K[F]),J.type=F,J.texture=pt)}function rt(){const F=X[B];F!==void 0&&F.type!==void 0&&(o.bindTexture(F.type,null),F.type=void 0,F.texture=void 0)}function it(){try{o.compressedTexImage2D.apply(o,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function _t(){try{o.texImage2D.apply(o,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function Lt(){try{o.texImage3D.apply(o,arguments)}catch(F){console.error("THREE.WebGLState:",F)}}function St(F){bt.equals(F)===!1&&(o.scissor(F.x,F.y,F.z,F.w),bt.copy(F))}function Nt(F){mt.equals(F)===!1&&(o.viewport(F.x,F.y,F.z,F.w),mt.copy(F))}function Et(){o.disable(3042),o.disable(2884),o.disable(2929),o.disable(32823),o.disable(3089),o.disable(2960),o.disable(32926),o.blendEquation(32774),o.blendFunc(1,0),o.blendFuncSeparate(1,0,1,0),o.colorMask(!0,!0,!0,!0),o.clearColor(0,0,0,0),o.depthMask(!0),o.depthFunc(513),o.clearDepth(1),o.stencilMask(4294967295),o.stencilFunc(519,0,4294967295),o.stencilOp(7680,7680,7680),o.clearStencil(0),o.cullFace(1029),o.frontFace(2305),o.polygonOffset(0,0),o.activeTexture(33984),o.bindFramebuffer(36160,null),n===!0&&(o.bindFramebuffer(36009,null),o.bindFramebuffer(36008,null)),o.useProgram(null),o.lineWidth(1),o.scissor(0,0,o.canvas.width,o.canvas.height),o.viewport(0,0,o.canvas.width,o.canvas.height),f={},B=null,X={},g=null,m={},v=null,b=!1,w=null,M=null,x=null,_=null,R=null,C=null,P=null,N=!1,T=null,H=null,nt=null,Y=null,k=null,bt.set(0,0,o.canvas.width,o.canvas.height),mt.set(0,0,o.canvas.width,o.canvas.height),h.reset(),u.reset(),d.reset()}return{buffers:{color:h,depth:u,stencil:d},enable:st,disable:wt,bindFramebuffer:Tt,bindXRFramebuffer:q,useProgram:At,setBlending:kt,setMaterial:$,setFlipSided:et,setCullFace:lt,setLineWidth:Mt,setPolygonOffset:dt,setScissorTest:A,activeTexture:E,bindTexture:Z,unbindTexture:rt,compressedTexImage2D:it,texImage2D:_t,texImage3D:Lt,scissor:St,viewport:Nt,reset:Et}}function _0(o,t,e,n,i,s,l){const h=i.isWebGL2,u=i.maxTextures,d=i.maxCubemapSize,f=i.maxTextureSize,g=i.maxSamples,m=new WeakMap;let v,b=!1;try{b=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function w(A,E){return b?new OffscreenCanvas(A,E):bs("canvas")}function M(A,E,Z,rt){let it=1;if((A.width>rt||A.height>rt)&&(it=rt/Math.max(A.width,A.height)),it<1||E===!0)if(typeof HTMLImageElement!="undefined"&&A instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&A instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&A instanceof ImageBitmap){const _t=E?Hm:Math.floor,Lt=_t(it*A.width),St=_t(it*A.height);v===void 0&&(v=w(Lt,St));const Nt=Z?w(Lt,St):v;return Nt.width=Lt,Nt.height=St,Nt.getContext("2d").drawImage(A,0,0,Lt,St),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+A.width+"x"+A.height+") to ("+Lt+"x"+St+")."),Nt}else return"data"in A&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+A.width+"x"+A.height+")."),A;return A}function x(A){return xc(A.width)&&xc(A.height)}function _(A){return h?!1:A.wrapS!==Ue||A.wrapT!==Ue||A.minFilter!==fe&&A.minFilter!==je}function R(A,E){return A.generateMipmaps&&E&&A.minFilter!==fe&&A.minFilter!==je}function C(A,E,Z,rt,it=1){o.generateMipmap(A);const _t=n.get(E);_t.__maxMipLevel=Math.log2(Math.max(Z,rt,it))}function P(A,E,Z,rt){if(h===!1)return E;if(A!==null){if(o[A]!==void 0)return o[A];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+A+"'")}let it=E;return E===6403&&(Z===5126&&(it=33326),Z===5131&&(it=33325),Z===5121&&(it=33321)),E===6407&&(Z===5126&&(it=34837),Z===5131&&(it=34843),Z===5121&&(it=32849)),E===6408&&(Z===5126&&(it=34836),Z===5131&&(it=34842),Z===5121&&(it=rt===ri?35907:32856)),(it===33325||it===33326||it===34842||it===34836)&&t.get("EXT_color_buffer_float"),it}function N(A){return A===fe||A===nc||A===ic?9728:9729}function T(A){const E=A.target;E.removeEventListener("dispose",T),nt(E),E.isVideoTexture&&m.delete(E),l.memory.textures--}function H(A){const E=A.target;E.removeEventListener("dispose",H),Y(E)}function nt(A){const E=n.get(A);E.__webglInit!==void 0&&(o.deleteTexture(E.__webglTexture),n.remove(A))}function Y(A){const E=A.texture,Z=n.get(A),rt=n.get(E);if(!!A){if(rt.__webglTexture!==void 0&&(o.deleteTexture(rt.__webglTexture),l.memory.textures--),A.depthTexture&&A.depthTexture.dispose(),A.isWebGLCubeRenderTarget)for(let it=0;it<6;it++)o.deleteFramebuffer(Z.__webglFramebuffer[it]),Z.__webglDepthbuffer&&o.deleteRenderbuffer(Z.__webglDepthbuffer[it]);else o.deleteFramebuffer(Z.__webglFramebuffer),Z.__webglDepthbuffer&&o.deleteRenderbuffer(Z.__webglDepthbuffer),Z.__webglMultisampledFramebuffer&&o.deleteFramebuffer(Z.__webglMultisampledFramebuffer),Z.__webglColorRenderbuffer&&o.deleteRenderbuffer(Z.__webglColorRenderbuffer),Z.__webglDepthRenderbuffer&&o.deleteRenderbuffer(Z.__webglDepthRenderbuffer);if(A.isWebGLMultipleRenderTargets)for(let it=0,_t=E.length;it<_t;it++){const Lt=n.get(E[it]);Lt.__webglTexture&&(o.deleteTexture(Lt.__webglTexture),l.memory.textures--),n.remove(E[it])}n.remove(E),n.remove(A)}}let k=0;function ht(){k=0}function G(){const A=k;return A>=u&&console.warn("THREE.WebGLTextures: Trying to use "+A+" texture units while this GPU supports only "+u),k+=1,A}function j(A,E){const Z=n.get(A);if(A.isVideoTexture&&$(A),A.version>0&&Z.__version!==A.version){const rt=A.image;if(rt===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(rt.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{vt(Z,A,E);return}}e.activeTexture(33984+E),e.bindTexture(3553,Z.__webglTexture)}function W(A,E){const Z=n.get(A);if(A.version>0&&Z.__version!==A.version){vt(Z,A,E);return}e.activeTexture(33984+E),e.bindTexture(35866,Z.__webglTexture)}function B(A,E){const Z=n.get(A);if(A.version>0&&Z.__version!==A.version){vt(Z,A,E);return}e.activeTexture(33984+E),e.bindTexture(32879,Z.__webglTexture)}function X(A,E){const Z=n.get(A);if(A.version>0&&Z.__version!==A.version){K(Z,A,E);return}e.activeTexture(33984+E),e.bindTexture(34067,Z.__webglTexture)}const at={[Oo]:10497,[Ue]:33071,[zo]:33648},yt={[fe]:9728,[nc]:9984,[ic]:9986,[je]:9729,[Vf]:9985,[ps]:9987};function bt(A,E,Z){if(Z?(o.texParameteri(A,10242,at[E.wrapS]),o.texParameteri(A,10243,at[E.wrapT]),(A===32879||A===35866)&&o.texParameteri(A,32882,at[E.wrapR]),o.texParameteri(A,10240,yt[E.magFilter]),o.texParameteri(A,10241,yt[E.minFilter])):(o.texParameteri(A,10242,33071),o.texParameteri(A,10243,33071),(A===32879||A===35866)&&o.texParameteri(A,32882,33071),(E.wrapS!==Ue||E.wrapT!==Ue)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),o.texParameteri(A,10240,N(E.magFilter)),o.texParameteri(A,10241,N(E.minFilter)),E.minFilter!==fe&&E.minFilter!==je&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const rt=t.get("EXT_texture_filter_anisotropic");if(E.type===Ln&&t.has("OES_texture_float_linear")===!1||h===!1&&E.type===Si&&t.has("OES_texture_half_float_linear")===!1)return;(E.anisotropy>1||n.get(E).__currentAnisotropy)&&(o.texParameterf(A,rt.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(E.anisotropy,i.getMaxAnisotropy())),n.get(E).__currentAnisotropy=E.anisotropy)}}function mt(A,E){A.__webglInit===void 0&&(A.__webglInit=!0,E.addEventListener("dispose",T),A.__webglTexture=o.createTexture(),l.memory.textures++)}function vt(A,E,Z){let rt=3553;E.isDataTexture2DArray&&(rt=35866),E.isDataTexture3D&&(rt=32879),mt(A,E),e.activeTexture(33984+Z),e.bindTexture(rt,A.__webglTexture),o.pixelStorei(37440,E.flipY),o.pixelStorei(37441,E.premultiplyAlpha),o.pixelStorei(3317,E.unpackAlignment),o.pixelStorei(37443,0);const it=_(E)&&x(E.image)===!1,_t=M(E.image,it,!1,f),Lt=x(_t)||h,St=s.convert(E.format);let Nt=s.convert(E.type),Et=P(E.internalFormat,St,Nt,E.encoding);bt(rt,E,Lt);let F;const pt=E.mipmaps;if(E.isDepthTexture)Et=6402,h?E.type===Ln?Et=36012:E.type===ms?Et=33190:E.type===Mr?Et=35056:Et=33189:E.type===Ln&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),E.format===Ti&&Et===6402&&E.type!==fs&&E.type!==ms&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),E.type=fs,Nt=s.convert(E.type)),E.format===Sr&&Et===6402&&(Et=34041,E.type!==Mr&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),E.type=Mr,Nt=s.convert(E.type))),e.texImage2D(3553,0,Et,_t.width,_t.height,0,St,Nt,null);else if(E.isDataTexture)if(pt.length>0&&Lt){for(let J=0,gt=pt.length;J<gt;J++)F=pt[J],e.texImage2D(3553,J,Et,F.width,F.height,0,St,Nt,F.data);E.generateMipmaps=!1,A.__maxMipLevel=pt.length-1}else e.texImage2D(3553,0,Et,_t.width,_t.height,0,St,Nt,_t.data),A.__maxMipLevel=0;else if(E.isCompressedTexture){for(let J=0,gt=pt.length;J<gt;J++)F=pt[J],E.format!==Pe&&E.format!==Ei?St!==null?e.compressedTexImage2D(3553,J,Et,F.width,F.height,0,F.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):e.texImage2D(3553,J,Et,F.width,F.height,0,St,Nt,F.data);A.__maxMipLevel=pt.length-1}else if(E.isDataTexture2DArray)e.texImage3D(35866,0,Et,_t.width,_t.height,_t.depth,0,St,Nt,_t.data),A.__maxMipLevel=0;else if(E.isDataTexture3D)e.texImage3D(32879,0,Et,_t.width,_t.height,_t.depth,0,St,Nt,_t.data),A.__maxMipLevel=0;else if(pt.length>0&&Lt){for(let J=0,gt=pt.length;J<gt;J++)F=pt[J],e.texImage2D(3553,J,Et,St,Nt,F);E.generateMipmaps=!1,A.__maxMipLevel=pt.length-1}else e.texImage2D(3553,0,Et,St,Nt,_t),A.__maxMipLevel=0;R(E,Lt)&&C(rt,E,_t.width,_t.height),A.__version=E.version,E.onUpdate&&E.onUpdate(E)}function K(A,E,Z){if(E.image.length!==6)return;mt(A,E),e.activeTexture(33984+Z),e.bindTexture(34067,A.__webglTexture),o.pixelStorei(37440,E.flipY),o.pixelStorei(37441,E.premultiplyAlpha),o.pixelStorei(3317,E.unpackAlignment),o.pixelStorei(37443,0);const rt=E&&(E.isCompressedTexture||E.image[0].isCompressedTexture),it=E.image[0]&&E.image[0].isDataTexture,_t=[];for(let J=0;J<6;J++)!rt&&!it?_t[J]=M(E.image[J],!1,!0,d):_t[J]=it?E.image[J].image:E.image[J];const Lt=_t[0],St=x(Lt)||h,Nt=s.convert(E.format),Et=s.convert(E.type),F=P(E.internalFormat,Nt,Et,E.encoding);bt(34067,E,St);let pt;if(rt){for(let J=0;J<6;J++){pt=_t[J].mipmaps;for(let gt=0;gt<pt.length;gt++){const D=pt[gt];E.format!==Pe&&E.format!==Ei?Nt!==null?e.compressedTexImage2D(34069+J,gt,F,D.width,D.height,0,D.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):e.texImage2D(34069+J,gt,F,D.width,D.height,0,Nt,Et,D.data)}}A.__maxMipLevel=pt.length-1}else{pt=E.mipmaps;for(let J=0;J<6;J++)if(it){e.texImage2D(34069+J,0,F,_t[J].width,_t[J].height,0,Nt,Et,_t[J].data);for(let gt=0;gt<pt.length;gt++){const ot=pt[gt].image[J].image;e.texImage2D(34069+J,gt+1,F,ot.width,ot.height,0,Nt,Et,ot.data)}}else{e.texImage2D(34069+J,0,F,Nt,Et,_t[J]);for(let gt=0;gt<pt.length;gt++){const D=pt[gt];e.texImage2D(34069+J,gt+1,F,Nt,Et,D.image[J])}}A.__maxMipLevel=pt.length}R(E,St)&&C(34067,E,Lt.width,Lt.height),A.__version=E.version,E.onUpdate&&E.onUpdate(E)}function st(A,E,Z,rt,it){const _t=s.convert(Z.format),Lt=s.convert(Z.type),St=P(Z.internalFormat,_t,Lt,Z.encoding);it===32879||it===35866?e.texImage3D(it,0,St,E.width,E.height,E.depth,0,_t,Lt,null):e.texImage2D(it,0,St,E.width,E.height,0,_t,Lt,null),e.bindFramebuffer(36160,A),o.framebufferTexture2D(36160,rt,it,n.get(Z).__webglTexture,0),e.bindFramebuffer(36160,null)}function wt(A,E,Z){if(o.bindRenderbuffer(36161,A),E.depthBuffer&&!E.stencilBuffer){let rt=33189;if(Z){const it=E.depthTexture;it&&it.isDepthTexture&&(it.type===Ln?rt=36012:it.type===ms&&(rt=33190));const _t=kt(E);o.renderbufferStorageMultisample(36161,_t,rt,E.width,E.height)}else o.renderbufferStorage(36161,rt,E.width,E.height);o.framebufferRenderbuffer(36160,36096,36161,A)}else if(E.depthBuffer&&E.stencilBuffer){if(Z){const rt=kt(E);o.renderbufferStorageMultisample(36161,rt,35056,E.width,E.height)}else o.renderbufferStorage(36161,34041,E.width,E.height);o.framebufferRenderbuffer(36160,33306,36161,A)}else{const rt=E.isWebGLMultipleRenderTargets===!0?E.texture[0]:E.texture,it=s.convert(rt.format),_t=s.convert(rt.type),Lt=P(rt.internalFormat,it,_t,rt.encoding);if(Z){const St=kt(E);o.renderbufferStorageMultisample(36161,St,Lt,E.width,E.height)}else o.renderbufferStorage(36161,Lt,E.width,E.height)}o.bindRenderbuffer(36161,null)}function q(A,E){if(E&&E.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,A),!(E.depthTexture&&E.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(E.depthTexture).__webglTexture||E.depthTexture.image.width!==E.width||E.depthTexture.image.height!==E.height)&&(E.depthTexture.image.width=E.width,E.depthTexture.image.height=E.height,E.depthTexture.needsUpdate=!0),j(E.depthTexture,0);const rt=n.get(E.depthTexture).__webglTexture;if(E.depthTexture.format===Ti)o.framebufferTexture2D(36160,36096,3553,rt,0);else if(E.depthTexture.format===Sr)o.framebufferTexture2D(36160,33306,3553,rt,0);else throw new Error("Unknown depthTexture format")}function Tt(A){const E=n.get(A),Z=A.isWebGLCubeRenderTarget===!0;if(A.depthTexture){if(Z)throw new Error("target.depthTexture not supported in Cube render targets");q(E.__webglFramebuffer,A)}else if(Z){E.__webglDepthbuffer=[];for(let rt=0;rt<6;rt++)e.bindFramebuffer(36160,E.__webglFramebuffer[rt]),E.__webglDepthbuffer[rt]=o.createRenderbuffer(),wt(E.__webglDepthbuffer[rt],A,!1)}else e.bindFramebuffer(36160,E.__webglFramebuffer),E.__webglDepthbuffer=o.createRenderbuffer(),wt(E.__webglDepthbuffer,A,!1);e.bindFramebuffer(36160,null)}function At(A){const E=A.texture,Z=n.get(A),rt=n.get(E);A.addEventListener("dispose",H),A.isWebGLMultipleRenderTargets!==!0&&(rt.__webglTexture=o.createTexture(),rt.__version=E.version,l.memory.textures++);const it=A.isWebGLCubeRenderTarget===!0,_t=A.isWebGLMultipleRenderTargets===!0,Lt=A.isWebGLMultisampleRenderTarget===!0,St=E.isDataTexture3D||E.isDataTexture2DArray,Nt=x(A)||h;if(h&&E.format===Ei&&(E.type===Ln||E.type===Si)&&(E.format=Pe,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),it){Z.__webglFramebuffer=[];for(let Et=0;Et<6;Et++)Z.__webglFramebuffer[Et]=o.createFramebuffer()}else if(Z.__webglFramebuffer=o.createFramebuffer(),_t)if(i.drawBuffers){const Et=A.texture;for(let F=0,pt=Et.length;F<pt;F++){const J=n.get(Et[F]);J.__webglTexture===void 0&&(J.__webglTexture=o.createTexture(),l.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(Lt)if(h){Z.__webglMultisampledFramebuffer=o.createFramebuffer(),Z.__webglColorRenderbuffer=o.createRenderbuffer(),o.bindRenderbuffer(36161,Z.__webglColorRenderbuffer);const Et=s.convert(E.format),F=s.convert(E.type),pt=P(E.internalFormat,Et,F,E.encoding),J=kt(A);o.renderbufferStorageMultisample(36161,J,pt,A.width,A.height),e.bindFramebuffer(36160,Z.__webglMultisampledFramebuffer),o.framebufferRenderbuffer(36160,36064,36161,Z.__webglColorRenderbuffer),o.bindRenderbuffer(36161,null),A.depthBuffer&&(Z.__webglDepthRenderbuffer=o.createRenderbuffer(),wt(Z.__webglDepthRenderbuffer,A,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(it){e.bindTexture(34067,rt.__webglTexture),bt(34067,E,Nt);for(let Et=0;Et<6;Et++)st(Z.__webglFramebuffer[Et],A,E,36064,34069+Et);R(E,Nt)&&C(34067,E,A.width,A.height),e.unbindTexture()}else if(_t){const Et=A.texture;for(let F=0,pt=Et.length;F<pt;F++){const J=Et[F],gt=n.get(J);e.bindTexture(3553,gt.__webglTexture),bt(3553,J,Nt),st(Z.__webglFramebuffer,A,J,36064+F,3553),R(J,Nt)&&C(3553,J,A.width,A.height)}e.unbindTexture()}else{let Et=3553;St&&(h?Et=E.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(Et,rt.__webglTexture),bt(Et,E,Nt),st(Z.__webglFramebuffer,A,E,36064,Et),R(E,Nt)&&C(Et,E,A.width,A.height,A.depth),e.unbindTexture()}A.depthBuffer&&Tt(A)}function ut(A){const E=x(A)||h,Z=A.isWebGLMultipleRenderTargets===!0?A.texture:[A.texture];for(let rt=0,it=Z.length;rt<it;rt++){const _t=Z[rt];if(R(_t,E)){const Lt=A.isWebGLCubeRenderTarget?34067:3553,St=n.get(_t).__webglTexture;e.bindTexture(Lt,St),C(Lt,_t,A.width,A.height),e.unbindTexture()}}}function xt(A){if(A.isWebGLMultisampleRenderTarget)if(h){const E=A.width,Z=A.height;let rt=16384;A.depthBuffer&&(rt|=256),A.stencilBuffer&&(rt|=1024);const it=n.get(A);e.bindFramebuffer(36008,it.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,it.__webglFramebuffer),o.blitFramebuffer(0,0,E,Z,0,0,E,Z,rt,9728),e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,it.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function kt(A){return h&&A.isWebGLMultisampleRenderTarget?Math.min(g,A.samples):0}function $(A){const E=l.render.frame;m.get(A)!==E&&(m.set(A,E),A.update())}let et=!1,lt=!1;function Mt(A,E){A&&A.isWebGLRenderTarget&&(et===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),et=!0),A=A.texture),j(A,E)}function dt(A,E){A&&A.isWebGLCubeRenderTarget&&(lt===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),lt=!0),A=A.texture),X(A,E)}this.allocateTextureUnit=G,this.resetTextureUnits=ht,this.setTexture2D=j,this.setTexture2DArray=W,this.setTexture3D=B,this.setTextureCube=X,this.setupRenderTarget=At,this.updateRenderTargetMipmap=ut,this.updateMultisampleRenderTarget=xt,this.safeSetTexture2D=Mt,this.safeSetTextureCube=dt}function x0(o,t,e){const n=e.isWebGL2;function i(s){let l;if(s===Pn)return 5121;if(s===Hf)return 32819;if(s===Gf)return 32820;if(s===Wf)return 33635;if(s===Of)return 5120;if(s===zf)return 5122;if(s===fs)return 5123;if(s===Uf)return 5124;if(s===ms)return 5125;if(s===Ln)return 5126;if(s===Si)return n?5131:(l=t.get("OES_texture_half_float"),l!==null?l.HALF_FLOAT_OES:null);if(s===qf)return 6406;if(s===Ei)return 6407;if(s===Pe)return 6408;if(s===jf)return 6409;if(s===Xf)return 6410;if(s===Ti)return 6402;if(s===Sr)return 34041;if(s===Zf)return 6403;if(s===$f)return 36244;if(s===Kf)return 33319;if(s===Jf)return 33320;if(s===Qf)return 36248;if(s===tm)return 36249;if(s===rc||s===sc||s===oc||s===ac)if(l=t.get("WEBGL_compressed_texture_s3tc"),l!==null){if(s===rc)return l.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===sc)return l.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===oc)return l.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===ac)return l.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===lc||s===cc||s===hc||s===uc)if(l=t.get("WEBGL_compressed_texture_pvrtc"),l!==null){if(s===lc)return l.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===cc)return l.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===hc)return l.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===uc)return l.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===em)return l=t.get("WEBGL_compressed_texture_etc1"),l!==null?l.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===dc||s===pc)&&(l=t.get("WEBGL_compressed_texture_etc"),l!==null)){if(s===dc)return l.COMPRESSED_RGB8_ETC2;if(s===pc)return l.COMPRESSED_RGBA8_ETC2_EAC}if(s===nm||s===im||s===rm||s===sm||s===om||s===am||s===lm||s===cm||s===hm||s===um||s===dm||s===pm||s===fm||s===mm||s===vm||s===_m||s===xm||s===bm||s===ym||s===wm||s===Mm||s===Sm||s===Em||s===Tm||s===Cm||s===Am||s===Pm||s===Lm)return l=t.get("WEBGL_compressed_texture_astc"),l!==null?s:null;if(s===gm)return l=t.get("EXT_texture_compression_bptc"),l!==null?s:null;if(s===Mr)return n?34042:(l=t.get("WEBGL_depth_texture"),l!==null?l.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:i}}class xh extends Be{constructor(t=[]){super();this.cameras=t}}xh.prototype.isArrayCamera=!0;class Ir extends $t{constructor(){super();this.type="Group"}}Ir.prototype.isGroup=!0;const b0={type:"move"};class La{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Ir,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Ir,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new L,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new L),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Ir,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new L,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new L),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let i=null,s=null,l=null;const h=this._targetRay,u=this._grip,d=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(h!==null&&(i=e.getPose(t.targetRaySpace,n),i!==null&&(h.matrix.fromArray(i.transform.matrix),h.matrix.decompose(h.position,h.rotation,h.scale),i.linearVelocity?(h.hasLinearVelocity=!0,h.linearVelocity.copy(i.linearVelocity)):h.hasLinearVelocity=!1,i.angularVelocity?(h.hasAngularVelocity=!0,h.angularVelocity.copy(i.angularVelocity)):h.hasAngularVelocity=!1,this.dispatchEvent(b0))),d&&t.hand){l=!0;for(const w of t.hand.values()){const M=e.getJointPose(w,n);if(d.joints[w.jointName]===void 0){const _=new Ir;_.matrixAutoUpdate=!1,_.visible=!1,d.joints[w.jointName]=_,d.add(_)}const x=d.joints[w.jointName];M!==null&&(x.matrix.fromArray(M.transform.matrix),x.matrix.decompose(x.position,x.rotation,x.scale),x.jointRadius=M.radius),x.visible=M!==null}const f=d.joints["index-finger-tip"],g=d.joints["thumb-tip"],m=f.position.distanceTo(g.position),v=.02,b=.005;d.inputState.pinching&&m>v+b?(d.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!d.inputState.pinching&&m<=v-b&&(d.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else u!==null&&t.gripSpace&&(s=e.getPose(t.gripSpace,n),s!==null&&(u.matrix.fromArray(s.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),s.linearVelocity?(u.hasLinearVelocity=!0,u.linearVelocity.copy(s.linearVelocity)):u.hasLinearVelocity=!1,s.angularVelocity?(u.hasAngularVelocity=!0,u.angularVelocity.copy(s.angularVelocity)):u.hasAngularVelocity=!1));return h!==null&&(h.visible=i!==null),u!==null&&(u.visible=s!==null),d!==null&&(d.visible=l!==null),this}}class y0 extends Rn{constructor(t,e){super();const n=this,i=t.state;let s=null,l=1,h=null,u="local-floor",d=null,f=null,g=null,m=null,v=null,b=!1,w=null,M=null,x=null,_=null,R=null,C=null;const P=[],N=new Map,T=new Be;T.layers.enable(1),T.viewport=new Qt;const H=new Be;H.layers.enable(2),H.viewport=new Qt;const nt=[T,H],Y=new xh;Y.layers.enable(1),Y.layers.enable(2);let k=null,ht=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(K){let st=P[K];return st===void 0&&(st=new La,P[K]=st),st.getTargetRaySpace()},this.getControllerGrip=function(K){let st=P[K];return st===void 0&&(st=new La,P[K]=st),st.getGripSpace()},this.getHand=function(K){let st=P[K];return st===void 0&&(st=new La,P[K]=st),st.getHandSpace()};function G(K){const st=N.get(K.inputSource);st&&st.dispatchEvent({type:K.type,data:K.inputSource})}function j(){N.forEach(function(K,st){K.disconnect(st)}),N.clear(),k=null,ht=null,i.bindXRFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),g&&e.deleteFramebuffer(g),w&&e.deleteFramebuffer(w),M&&e.deleteRenderbuffer(M),x&&e.deleteRenderbuffer(x),g=null,w=null,M=null,x=null,v=null,m=null,f=null,s=null,vt.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(K){l=K,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(K){u=K,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return h},this.getBaseLayer=function(){return m!==null?m:v},this.getBinding=function(){return f},this.getFrame=function(){return _},this.getSession=function(){return s},this.setSession=async function(K){if(s=K,s!==null){s.addEventListener("select",G),s.addEventListener("selectstart",G),s.addEventListener("selectend",G),s.addEventListener("squeeze",G),s.addEventListener("squeezestart",G),s.addEventListener("squeezeend",G),s.addEventListener("end",j),s.addEventListener("inputsourceschange",W);const st=e.getContextAttributes();if(st.xrCompatible!==!0&&await e.makeXRCompatible(),s.renderState.layers===void 0){const wt={antialias:st.antialias,alpha:st.alpha,depth:st.depth,stencil:st.stencil,framebufferScaleFactor:l};v=new XRWebGLLayer(s,e,wt),s.updateRenderState({baseLayer:v})}else if(e instanceof WebGLRenderingContext){const wt={antialias:!0,alpha:st.alpha,depth:st.depth,stencil:st.stencil,framebufferScaleFactor:l};v=new XRWebGLLayer(s,e,wt),s.updateRenderState({layers:[v]})}else{b=st.antialias;let wt=null;st.depth&&(C=256,st.stencil&&(C|=1024),R=st.stencil?33306:36096,wt=st.stencil?35056:33190);const q={colorFormat:st.alpha?32856:32849,depthFormat:wt,scaleFactor:l};f=new XRWebGLBinding(s,e),m=f.createProjectionLayer(q),g=e.createFramebuffer(),s.updateRenderState({layers:[m]}),b&&(w=e.createFramebuffer(),M=e.createRenderbuffer(),e.bindRenderbuffer(36161,M),e.renderbufferStorageMultisample(36161,4,32856,m.textureWidth,m.textureHeight),i.bindFramebuffer(36160,w),e.framebufferRenderbuffer(36160,36064,36161,M),e.bindRenderbuffer(36161,null),wt!==null&&(x=e.createRenderbuffer(),e.bindRenderbuffer(36161,x),e.renderbufferStorageMultisample(36161,4,wt,m.textureWidth,m.textureHeight),e.framebufferRenderbuffer(36160,R,36161,x),e.bindRenderbuffer(36161,null)),i.bindFramebuffer(36160,null))}h=await s.requestReferenceSpace(u),vt.setContext(s),vt.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function W(K){const st=s.inputSources;for(let wt=0;wt<P.length;wt++)N.set(st[wt],P[wt]);for(let wt=0;wt<K.removed.length;wt++){const q=K.removed[wt],Tt=N.get(q);Tt&&(Tt.dispatchEvent({type:"disconnected",data:q}),N.delete(q))}for(let wt=0;wt<K.added.length;wt++){const q=K.added[wt],Tt=N.get(q);Tt&&Tt.dispatchEvent({type:"connected",data:q})}}const B=new L,X=new L;function at(K,st,wt){B.setFromMatrixPosition(st.matrixWorld),X.setFromMatrixPosition(wt.matrixWorld);const q=B.distanceTo(X),Tt=st.projectionMatrix.elements,At=wt.projectionMatrix.elements,ut=Tt[14]/(Tt[10]-1),xt=Tt[14]/(Tt[10]+1),kt=(Tt[9]+1)/Tt[5],$=(Tt[9]-1)/Tt[5],et=(Tt[8]-1)/Tt[0],lt=(At[8]+1)/At[0],Mt=ut*et,dt=ut*lt,A=q/(-et+lt),E=A*-et;st.matrixWorld.decompose(K.position,K.quaternion,K.scale),K.translateX(E),K.translateZ(A),K.matrixWorld.compose(K.position,K.quaternion,K.scale),K.matrixWorldInverse.copy(K.matrixWorld).invert();const Z=ut+A,rt=xt+A,it=Mt-E,_t=dt+(q-E),Lt=kt*xt/rt*Z,St=$*xt/rt*Z;K.projectionMatrix.makePerspective(it,_t,Lt,St,Z,rt)}function yt(K,st){st===null?K.matrixWorld.copy(K.matrix):K.matrixWorld.multiplyMatrices(st.matrixWorld,K.matrix),K.matrixWorldInverse.copy(K.matrixWorld).invert()}this.updateCamera=function(K){if(s===null)return;Y.near=H.near=T.near=K.near,Y.far=H.far=T.far=K.far,(k!==Y.near||ht!==Y.far)&&(s.updateRenderState({depthNear:Y.near,depthFar:Y.far}),k=Y.near,ht=Y.far);const st=K.parent,wt=Y.cameras;yt(Y,st);for(let Tt=0;Tt<wt.length;Tt++)yt(wt[Tt],st);Y.matrixWorld.decompose(Y.position,Y.quaternion,Y.scale),K.position.copy(Y.position),K.quaternion.copy(Y.quaternion),K.scale.copy(Y.scale),K.matrix.copy(Y.matrix),K.matrixWorld.copy(Y.matrixWorld);const q=K.children;for(let Tt=0,At=q.length;Tt<At;Tt++)q[Tt].updateMatrixWorld(!0);wt.length===2?at(Y,T,H):Y.projectionMatrix.copy(T.projectionMatrix)},this.getCamera=function(){return Y},this.getFoveation=function(){if(m!==null)return m.fixedFoveation;if(v!==null)return v.fixedFoveation},this.setFoveation=function(K){m!==null&&(m.fixedFoveation=K),v!==null&&v.fixedFoveation!==void 0&&(v.fixedFoveation=K)};let bt=null;function mt(K,st){if(d=st.getViewerPose(h),_=st,d!==null){const q=d.views;v!==null&&i.bindXRFramebuffer(v.framebuffer);let Tt=!1;q.length!==Y.cameras.length&&(Y.cameras.length=0,Tt=!0);for(let At=0;At<q.length;At++){const ut=q[At];let xt=null;if(v!==null)xt=v.getViewport(ut);else{const $=f.getViewSubImage(m,ut);i.bindXRFramebuffer(g),$.depthStencilTexture!==void 0&&e.framebufferTexture2D(36160,R,3553,$.depthStencilTexture,0),e.framebufferTexture2D(36160,36064,3553,$.colorTexture,0),xt=$.viewport}const kt=nt[At];kt.matrix.fromArray(ut.transform.matrix),kt.projectionMatrix.fromArray(ut.projectionMatrix),kt.viewport.set(xt.x,xt.y,xt.width,xt.height),At===0&&Y.matrix.copy(kt.matrix),Tt===!0&&Y.cameras.push(kt)}b&&(i.bindXRFramebuffer(w),C!==null&&e.clear(C))}const wt=s.inputSources;for(let q=0;q<P.length;q++){const Tt=P[q],At=wt[q];Tt.update(At,st,h)}if(bt&&bt(K,st),b){const q=m.textureWidth,Tt=m.textureHeight;i.bindFramebuffer(36008,w),i.bindFramebuffer(36009,g),e.invalidateFramebuffer(36008,[R]),e.invalidateFramebuffer(36009,[R]),e.blitFramebuffer(0,0,q,Tt,0,0,q,Tt,16384,9728),e.invalidateFramebuffer(36008,[36064]),i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,null),i.bindFramebuffer(36160,w)}_=null}const vt=new Bc;vt.setAnimationLoop(mt),this.setAnimationLoop=function(K){bt=K},this.dispose=function(){}}}function w0(o){function t(x,_){x.fogColor.value.copy(_.color),_.isFog?(x.fogNear.value=_.near,x.fogFar.value=_.far):_.isFogExp2&&(x.fogDensity.value=_.density)}function e(x,_,R,C,P){_.isMeshBasicMaterial?n(x,_):_.isMeshLambertMaterial?(n(x,_),u(x,_)):_.isMeshToonMaterial?(n(x,_),f(x,_)):_.isMeshPhongMaterial?(n(x,_),d(x,_)):_.isMeshStandardMaterial?(n(x,_),_.isMeshPhysicalMaterial?m(x,_,P):g(x,_)):_.isMeshMatcapMaterial?(n(x,_),v(x,_)):_.isMeshDepthMaterial?(n(x,_),b(x,_)):_.isMeshDistanceMaterial?(n(x,_),w(x,_)):_.isMeshNormalMaterial?(n(x,_),M(x,_)):_.isLineBasicMaterial?(i(x,_),_.isLineDashedMaterial&&s(x,_)):_.isPointsMaterial?l(x,_,R,C):_.isSpriteMaterial?h(x,_):_.isShadowMaterial?(x.color.value.copy(_.color),x.opacity.value=_.opacity):_.isShaderMaterial&&(_.uniformsNeedUpdate=!1)}function n(x,_){x.opacity.value=_.opacity,_.color&&x.diffuse.value.copy(_.color),_.emissive&&x.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity),_.map&&(x.map.value=_.map),_.alphaMap&&(x.alphaMap.value=_.alphaMap),_.specularMap&&(x.specularMap.value=_.specularMap),_.alphaTest>0&&(x.alphaTest.value=_.alphaTest);const R=o.get(_).envMap;if(R){x.envMap.value=R,x.flipEnvMap.value=R.isCubeTexture&&R.isRenderTargetTexture===!1?-1:1,x.reflectivity.value=_.reflectivity,x.ior.value=_.ior,x.refractionRatio.value=_.refractionRatio;const N=o.get(R).__maxMipLevel;N!==void 0&&(x.maxMipLevel.value=N)}_.lightMap&&(x.lightMap.value=_.lightMap,x.lightMapIntensity.value=_.lightMapIntensity),_.aoMap&&(x.aoMap.value=_.aoMap,x.aoMapIntensity.value=_.aoMapIntensity);let C;_.map?C=_.map:_.specularMap?C=_.specularMap:_.displacementMap?C=_.displacementMap:_.normalMap?C=_.normalMap:_.bumpMap?C=_.bumpMap:_.roughnessMap?C=_.roughnessMap:_.metalnessMap?C=_.metalnessMap:_.alphaMap?C=_.alphaMap:_.emissiveMap?C=_.emissiveMap:_.clearcoatMap?C=_.clearcoatMap:_.clearcoatNormalMap?C=_.clearcoatNormalMap:_.clearcoatRoughnessMap?C=_.clearcoatRoughnessMap:_.specularIntensityMap?C=_.specularIntensityMap:_.specularTintMap?C=_.specularTintMap:_.transmissionMap?C=_.transmissionMap:_.thicknessMap&&(C=_.thicknessMap),C!==void 0&&(C.isWebGLRenderTarget&&(C=C.texture),C.matrixAutoUpdate===!0&&C.updateMatrix(),x.uvTransform.value.copy(C.matrix));let P;_.aoMap?P=_.aoMap:_.lightMap&&(P=_.lightMap),P!==void 0&&(P.isWebGLRenderTarget&&(P=P.texture),P.matrixAutoUpdate===!0&&P.updateMatrix(),x.uv2Transform.value.copy(P.matrix))}function i(x,_){x.diffuse.value.copy(_.color),x.opacity.value=_.opacity}function s(x,_){x.dashSize.value=_.dashSize,x.totalSize.value=_.dashSize+_.gapSize,x.scale.value=_.scale}function l(x,_,R,C){x.diffuse.value.copy(_.color),x.opacity.value=_.opacity,x.size.value=_.size*R,x.scale.value=C*.5,_.map&&(x.map.value=_.map),_.alphaMap&&(x.alphaMap.value=_.alphaMap),_.alphaTest>0&&(x.alphaTest.value=_.alphaTest);let P;_.map?P=_.map:_.alphaMap&&(P=_.alphaMap),P!==void 0&&(P.matrixAutoUpdate===!0&&P.updateMatrix(),x.uvTransform.value.copy(P.matrix))}function h(x,_){x.diffuse.value.copy(_.color),x.opacity.value=_.opacity,x.rotation.value=_.rotation,_.map&&(x.map.value=_.map),_.alphaMap&&(x.alphaMap.value=_.alphaMap),_.alphaTest>0&&(x.alphaTest.value=_.alphaTest);let R;_.map?R=_.map:_.alphaMap&&(R=_.alphaMap),R!==void 0&&(R.matrixAutoUpdate===!0&&R.updateMatrix(),x.uvTransform.value.copy(R.matrix))}function u(x,_){_.emissiveMap&&(x.emissiveMap.value=_.emissiveMap)}function d(x,_){x.specular.value.copy(_.specular),x.shininess.value=Math.max(_.shininess,1e-4),_.emissiveMap&&(x.emissiveMap.value=_.emissiveMap),_.bumpMap&&(x.bumpMap.value=_.bumpMap,x.bumpScale.value=_.bumpScale,_.side===de&&(x.bumpScale.value*=-1)),_.normalMap&&(x.normalMap.value=_.normalMap,x.normalScale.value.copy(_.normalScale),_.side===de&&x.normalScale.value.negate()),_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias)}function f(x,_){_.gradientMap&&(x.gradientMap.value=_.gradientMap),_.emissiveMap&&(x.emissiveMap.value=_.emissiveMap),_.bumpMap&&(x.bumpMap.value=_.bumpMap,x.bumpScale.value=_.bumpScale,_.side===de&&(x.bumpScale.value*=-1)),_.normalMap&&(x.normalMap.value=_.normalMap,x.normalScale.value.copy(_.normalScale),_.side===de&&x.normalScale.value.negate()),_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias)}function g(x,_){x.roughness.value=_.roughness,x.metalness.value=_.metalness,_.roughnessMap&&(x.roughnessMap.value=_.roughnessMap),_.metalnessMap&&(x.metalnessMap.value=_.metalnessMap),_.emissiveMap&&(x.emissiveMap.value=_.emissiveMap),_.bumpMap&&(x.bumpMap.value=_.bumpMap,x.bumpScale.value=_.bumpScale,_.side===de&&(x.bumpScale.value*=-1)),_.normalMap&&(x.normalMap.value=_.normalMap,x.normalScale.value.copy(_.normalScale),_.side===de&&x.normalScale.value.negate()),_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias),o.get(_).envMap&&(x.envMapIntensity.value=_.envMapIntensity)}function m(x,_,R){g(x,_),x.ior.value=_.ior,_.sheen>0&&(x.sheenTint.value.copy(_.sheenTint).multiplyScalar(_.sheen),x.sheenRoughness.value=_.sheenRoughness),_.clearcoat>0&&(x.clearcoat.value=_.clearcoat,x.clearcoatRoughness.value=_.clearcoatRoughness,_.clearcoatMap&&(x.clearcoatMap.value=_.clearcoatMap),_.clearcoatRoughnessMap&&(x.clearcoatRoughnessMap.value=_.clearcoatRoughnessMap),_.clearcoatNormalMap&&(x.clearcoatNormalScale.value.copy(_.clearcoatNormalScale),x.clearcoatNormalMap.value=_.clearcoatNormalMap,_.side===de&&x.clearcoatNormalScale.value.negate())),_.transmission>0&&(x.transmission.value=_.transmission,x.transmissionSamplerMap.value=R.texture,x.transmissionSamplerSize.value.set(R.width,R.height),_.transmissionMap&&(x.transmissionMap.value=_.transmissionMap),x.thickness.value=_.thickness,_.thicknessMap&&(x.thicknessMap.value=_.thicknessMap),x.attenuationDistance.value=_.attenuationDistance,x.attenuationTint.value.copy(_.attenuationTint)),x.specularIntensity.value=_.specularIntensity,x.specularTint.value.copy(_.specularTint),_.specularIntensityMap&&(x.specularIntensityMap.value=_.specularIntensityMap),_.specularTintMap&&(x.specularTintMap.value=_.specularTintMap)}function v(x,_){_.matcap&&(x.matcap.value=_.matcap),_.bumpMap&&(x.bumpMap.value=_.bumpMap,x.bumpScale.value=_.bumpScale,_.side===de&&(x.bumpScale.value*=-1)),_.normalMap&&(x.normalMap.value=_.normalMap,x.normalScale.value.copy(_.normalScale),_.side===de&&x.normalScale.value.negate()),_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias)}function b(x,_){_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias)}function w(x,_){_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias),x.referencePosition.value.copy(_.referencePosition),x.nearDistance.value=_.nearDistance,x.farDistance.value=_.farDistance}function M(x,_){_.bumpMap&&(x.bumpMap.value=_.bumpMap,x.bumpScale.value=_.bumpScale,_.side===de&&(x.bumpScale.value*=-1)),_.normalMap&&(x.normalMap.value=_.normalMap,x.normalScale.value.copy(_.normalScale),_.side===de&&x.normalScale.value.negate()),_.displacementMap&&(x.displacementMap.value=_.displacementMap,x.displacementScale.value=_.displacementScale,x.displacementBias.value=_.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function M0(){const o=bs("canvas");return o.style.display="block",o}function te(o={}){const t=o.canvas!==void 0?o.canvas:M0(),e=o.context!==void 0?o.context:null,n=o.alpha!==void 0?o.alpha:!1,i=o.depth!==void 0?o.depth:!0,s=o.stencil!==void 0?o.stencil:!0,l=o.antialias!==void 0?o.antialias:!1,h=o.premultipliedAlpha!==void 0?o.premultipliedAlpha:!0,u=o.preserveDrawingBuffer!==void 0?o.preserveDrawingBuffer:!1,d=o.powerPreference!==void 0?o.powerPreference:"default",f=o.failIfMajorPerformanceCaveat!==void 0?o.failIfMajorPerformanceCaveat:!1;let g=null,m=null;const v=[],b=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=we,this.physicallyCorrectLights=!1,this.toneMapping=ii,this.toneMappingExposure=1;const w=this;let M=!1,x=0,_=0,R=null,C=-1,P=null;const N=new Qt,T=new Qt;let H=null,nt=t.width,Y=t.height,k=1,ht=null,G=null;const j=new Qt(0,0,nt,Y),W=new Qt(0,0,nt,Y);let B=!1;const X=[],at=new Os;let yt=!1,bt=!1,mt=null;const vt=new It,K=new L,st={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function wt(){return R===null?k:1}let q=e;function Tt(S,O){for(let U=0;U<S.length;U++){const z=S[U],Q=t.getContext(z,O);if(Q!==null)return Q}return null}try{const S={alpha:n,depth:i,stencil:s,antialias:l,premultipliedAlpha:h,preserveDrawingBuffer:u,powerPreference:d,failIfMajorPerformanceCaveat:f};if(t.addEventListener("webglcontextlost",Ot,!1),t.addEventListener("webglcontextrestored",zt,!1),q===null){const O=["webgl2","webgl","experimental-webgl"];if(w.isWebGL1Renderer===!0&&O.shift(),q=Tt(O,S),q===null)throw Tt(O)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}q.getShaderPrecisionFormat===void 0&&(q.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(S){throw console.error("THREE.WebGLRenderer: "+S.message),S}let At,ut,xt,kt,$,et,lt,Mt,dt,A,E,Z,rt,it,_t,Lt,St,Nt,Et,F,pt,J,gt;function D(){At=new j_(q),ut=new V_(q,At,o),At.init(ut),J=new x0(q,At,ut),xt=new v0(q,At,ut),X[0]=1029,kt=new Z_(q),$=new o0,et=new _0(q,At,xt,$,ut,J,kt),lt=new z_(w),Mt=new q_(w),dt=new lg(q,ut),gt=new F_(q,At,dt,ut),A=new X_(q,dt,kt,gt),E=new Q_(q,A,dt,kt),Et=new J_(q,ut,et),Lt=new O_($),Z=new s0(w,lt,Mt,At,ut,gt,Lt),rt=new w0($),it=new l0($),_t=new f0(At,ut),Nt=new k_(w,lt,xt,E,h),St=new _h(w,E,ut),F=new B_(q,At,kt,ut),pt=new Y_(q,At,kt,ut),kt.programs=Z.programs,w.capabilities=ut,w.extensions=At,w.properties=$,w.renderLists=it,w.shadowMap=St,w.state=xt,w.info=kt}D();const ot=new y0(w,q);this.xr=ot,this.getContext=function(){return q},this.getContextAttributes=function(){return q.getContextAttributes()},this.forceContextLoss=function(){const S=At.get("WEBGL_lose_context");S&&S.loseContext()},this.forceContextRestore=function(){const S=At.get("WEBGL_lose_context");S&&S.restoreContext()},this.getPixelRatio=function(){return k},this.setPixelRatio=function(S){S!==void 0&&(k=S,this.setSize(nt,Y,!1))},this.getSize=function(S){return S.set(nt,Y)},this.setSize=function(S,O,U){if(ot.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}nt=S,Y=O,t.width=Math.floor(S*k),t.height=Math.floor(O*k),U!==!1&&(t.style.width=S+"px",t.style.height=O+"px"),this.setViewport(0,0,S,O)},this.getDrawingBufferSize=function(S){return S.set(nt*k,Y*k).floor()},this.setDrawingBufferSize=function(S,O,U){nt=S,Y=O,k=U,t.width=Math.floor(S*U),t.height=Math.floor(O*U),this.setViewport(0,0,S,O)},this.getCurrentViewport=function(S){return S.copy(N)},this.getViewport=function(S){return S.copy(j)},this.setViewport=function(S,O,U,z){S.isVector4?j.set(S.x,S.y,S.z,S.w):j.set(S,O,U,z),xt.viewport(N.copy(j).multiplyScalar(k).floor())},this.getScissor=function(S){return S.copy(W)},this.setScissor=function(S,O,U,z){S.isVector4?W.set(S.x,S.y,S.z,S.w):W.set(S,O,U,z),xt.scissor(T.copy(W).multiplyScalar(k).floor())},this.getScissorTest=function(){return B},this.setScissorTest=function(S){xt.setScissorTest(B=S)},this.setOpaqueSort=function(S){ht=S},this.setTransparentSort=function(S){G=S},this.getClearColor=function(S){return S.copy(Nt.getClearColor())},this.setClearColor=function(){Nt.setClearColor.apply(Nt,arguments)},this.getClearAlpha=function(){return Nt.getClearAlpha()},this.setClearAlpha=function(){Nt.setClearAlpha.apply(Nt,arguments)},this.clear=function(S,O,U){let z=0;(S===void 0||S)&&(z|=16384),(O===void 0||O)&&(z|=256),(U===void 0||U)&&(z|=1024),q.clear(z)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Ot,!1),t.removeEventListener("webglcontextrestored",zt,!1),it.dispose(),_t.dispose(),$.dispose(),lt.dispose(),Mt.dispose(),E.dispose(),gt.dispose(),ot.dispose(),ot.removeEventListener("sessionstart",ci),ot.removeEventListener("sessionend",Ve),mt&&(mt.dispose(),mt=null),Ze.stop()};function Ot(S){S.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),M=!0}function zt(){console.log("THREE.WebGLRenderer: Context Restored."),M=!1;const S=kt.autoReset,O=St.enabled,U=St.autoUpdate,z=St.needsUpdate,Q=St.type;D(),kt.autoReset=S,St.enabled=O,St.autoUpdate=U,St.needsUpdate=z,St.type=Q}function ie(S){const O=S.target;O.removeEventListener("dispose",ie),Zt(O)}function Zt(S){be(S),$.remove(S)}function be(S){const O=$.get(S).programs;O!==void 0&&O.forEach(function(U){Z.releaseProgram(U)})}function Re(S,O){S.render(function(U){w.renderBufferImmediate(U,O)})}this.renderBufferImmediate=function(S,O){gt.initAttributes();const U=$.get(S);S.hasPositions&&!U.position&&(U.position=q.createBuffer()),S.hasNormals&&!U.normal&&(U.normal=q.createBuffer()),S.hasUvs&&!U.uv&&(U.uv=q.createBuffer()),S.hasColors&&!U.color&&(U.color=q.createBuffer());const z=O.getAttributes();S.hasPositions&&(q.bindBuffer(34962,U.position),q.bufferData(34962,S.positionArray,35048),gt.enableAttribute(z.position.location),q.vertexAttribPointer(z.position.location,3,5126,!1,0,0)),S.hasNormals&&(q.bindBuffer(34962,U.normal),q.bufferData(34962,S.normalArray,35048),gt.enableAttribute(z.normal.location),q.vertexAttribPointer(z.normal.location,3,5126,!1,0,0)),S.hasUvs&&(q.bindBuffer(34962,U.uv),q.bufferData(34962,S.uvArray,35048),gt.enableAttribute(z.uv.location),q.vertexAttribPointer(z.uv.location,2,5126,!1,0,0)),S.hasColors&&(q.bindBuffer(34962,U.color),q.bufferData(34962,S.colorArray,35048),gt.enableAttribute(z.color.location),q.vertexAttribPointer(z.color.location,3,5126,!1,0,0)),gt.disableUnusedAttributes(),q.drawArrays(4,0,S.count),S.count=0},this.renderBufferDirect=function(S,O,U,z,Q,Ft){O===null&&(O=st);const Rt=Q.isMesh&&Q.matrixWorld.determinant()<0,Pt=$r(S,O,U,z,Q);xt.setMaterial(z,Rt);let Vt=U.index;const Gt=U.attributes.position;if(Vt===null){if(Gt===void 0||Gt.count===0)return}else if(Vt.count===0)return;let Ut=1;z.wireframe===!0&&(Vt=A.getWireframeAttribute(U),Ut=2),gt.setup(Q,z,Pt,U,Vt);let qt,re=F;Vt!==null&&(qt=dt.get(Vt),re=pt,re.setIndex(qt));const nn=Vt!==null?Vt.count:Gt.count,jt=U.drawRange.start*Ut,$n=U.drawRange.count*Ut,Jt=Ft!==null?Ft.start*Ut:0,ye=Ft!==null?Ft.count*Ut:1/0,Oe=Math.max(jt,Jt),dn=Math.min(nn,jt+$n,Jt+ye)-1,rn=Math.max(0,dn-Oe+1);if(rn!==0){if(Q.isMesh)z.wireframe===!0?(xt.setLineWidth(z.wireframeLinewidth*wt()),re.setMode(1)):re.setMode(4);else if(Q.isLine){let ne=z.linewidth;ne===void 0&&(ne=1),xt.setLineWidth(ne*wt()),Q.isLineSegments?re.setMode(1):Q.isLineLoop?re.setMode(2):re.setMode(3)}else Q.isPoints?re.setMode(0):Q.isSprite&&re.setMode(4);if(Q.isInstancedMesh)re.renderInstances(Oe,rn,Q.count);else if(U.isInstancedBufferGeometry){const ne=Math.min(U.instanceCount,U._maxInstanceCount);re.renderInstances(Oe,rn,ne)}else re.render(Oe,rn)}},this.compile=function(S,O){m=_t.get(S),m.init(),b.push(m),S.traverseVisible(function(U){U.isLight&&U.layers.test(O.layers)&&(m.pushLight(U),U.castShadow&&m.pushShadow(U))}),m.setupLights(w.physicallyCorrectLights),S.traverse(function(U){const z=U.material;if(z)if(Array.isArray(z))for(let Q=0;Q<z.length;Q++){const Ft=z[Q];Zn(Ft,S,U)}else Zn(z,S,U)}),b.pop(),m=null};let Ce=null;function Ae(S){Ce&&Ce(S)}function ci(){Ze.stop()}function Ve(){Ze.start()}const Ze=new Bc;Ze.setAnimationLoop(Ae),typeof window!="undefined"&&Ze.setContext(window),this.setAnimationLoop=function(S){Ce=S,ot.setAnimationLoop(S),S===null?Ze.stop():Ze.start()},ot.addEventListener("sessionstart",ci),ot.addEventListener("sessionend",Ve),this.render=function(S,O){if(O!==void 0&&O.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(M===!0)return;S.autoUpdate===!0&&S.updateMatrixWorld(),O.parent===null&&O.updateMatrixWorld(),ot.enabled===!0&&ot.isPresenting===!0&&(ot.cameraAutoUpdate===!0&&ot.updateCamera(O),O=ot.getCamera()),S.isScene===!0&&S.onBeforeRender(w,S,O,R),m=_t.get(S,b.length),m.init(),b.push(m),vt.multiplyMatrices(O.projectionMatrix,O.matrixWorldInverse),at.setFromProjectionMatrix(vt),bt=this.localClippingEnabled,yt=Lt.init(this.clippingPlanes,bt,O),g=it.get(S,v.length),g.init(),v.push(g),$e(S,O,0,w.sortObjects),g.finish(),w.sortObjects===!0&&g.sort(ht,G),yt===!0&&Lt.beginShadows();const U=m.state.shadowsArray;if(St.render(U,S,O),yt===!0&&Lt.endShadows(),this.info.autoReset===!0&&this.info.reset(),Nt.render(g,S),m.setupLights(w.physicallyCorrectLights),O.isArrayCamera){const z=O.cameras;for(let Q=0,Ft=z.length;Q<Ft;Q++){const Rt=z[Q];Zr(g,S,Rt,Rt.viewport)}}else Zr(g,S,O);R!==null&&(et.updateMultisampleRenderTarget(R),et.updateRenderTargetMipmap(R)),S.isScene===!0&&S.onAfterRender(w,S,O),xt.buffers.depth.setTest(!0),xt.buffers.depth.setMask(!0),xt.buffers.color.setMask(!0),xt.setPolygonOffset(!1),gt.resetDefaultState(),C=-1,P=null,b.pop(),b.length>0?m=b[b.length-1]:m=null,v.pop(),v.length>0?g=v[v.length-1]:g=null};function $e(S,O,U,z){if(S.visible===!1)return;if(S.layers.test(O.layers)){if(S.isGroup)U=S.renderOrder;else if(S.isLOD)S.autoUpdate===!0&&S.update(O);else if(S.isLight)m.pushLight(S),S.castShadow&&m.pushShadow(S);else if(S.isSprite){if(!S.frustumCulled||at.intersectsSprite(S)){z&&K.setFromMatrixPosition(S.matrixWorld).applyMatrix4(vt);const Rt=E.update(S),Pt=S.material;Pt.visible&&g.push(S,Rt,Pt,U,K.z,null)}}else if(S.isImmediateRenderObject)z&&K.setFromMatrixPosition(S.matrixWorld).applyMatrix4(vt),g.push(S,null,S.material,U,K.z,null);else if((S.isMesh||S.isLine||S.isPoints)&&(S.isSkinnedMesh&&S.skeleton.frame!==kt.render.frame&&(S.skeleton.update(),S.skeleton.frame=kt.render.frame),!S.frustumCulled||at.intersectsObject(S))){z&&K.setFromMatrixPosition(S.matrixWorld).applyMatrix4(vt);const Rt=E.update(S),Pt=S.material;if(Array.isArray(Pt)){const Vt=Rt.groups;for(let Gt=0,Ut=Vt.length;Gt<Ut;Gt++){const qt=Vt[Gt],re=Pt[qt.materialIndex];re&&re.visible&&g.push(S,Rt,re,U,K.z,qt)}}else Pt.visible&&g.push(S,Rt,Pt,U,K.z,null)}}const Ft=S.children;for(let Rt=0,Pt=Ft.length;Rt<Pt;Rt++)$e(Ft[Rt],O,U,z)}function Zr(S,O,U,z){const Q=S.opaque,Ft=S.transmissive,Rt=S.transparent;m.setupLightsView(U),Ft.length>0&&Xn(Q,O,U),z&&xt.viewport(N.copy(z)),Q.length>0&&Yn(Q,O,U),Ft.length>0&&Yn(Ft,O,U),Rt.length>0&&Yn(Rt,O,U)}function Xn(S,O,U){if(mt===null){const Rt=l===!0&&ut.isWebGL2===!0?yc:an;mt=new Rt(1024,1024,{generateMipmaps:!0,type:J.convert(Si)!==null?Si:Pn,minFilter:ps,magFilter:fe,wrapS:Ue,wrapT:Ue})}const z=w.getRenderTarget();w.setRenderTarget(mt),w.clear();const Q=w.toneMapping;w.toneMapping=ii,Yn(S,O,U),w.toneMapping=Q,et.updateMultisampleRenderTarget(mt),et.updateRenderTargetMipmap(mt),w.setRenderTarget(z)}function Yn(S,O,U){const z=O.isScene===!0?O.overrideMaterial:null;for(let Q=0,Ft=S.length;Q<Ft;Q++){const Rt=S[Q],Pt=Rt.object,Vt=Rt.geometry,Gt=z===null?Rt.material:z,Ut=Rt.group;Pt.layers.test(U.layers)&&hi(Pt,O,U,Vt,Gt,Ut)}}function hi(S,O,U,z,Q,Ft){if(S.onBeforeRender(w,O,U,z,Q,Ft),S.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse,S.matrixWorld),S.normalMatrix.getNormalMatrix(S.modelViewMatrix),Q.onBeforeRender(w,O,U,z,S,Ft),S.isImmediateRenderObject){const Rt=$r(U,O,z,Q,S);xt.setMaterial(Q),gt.reset(),Re(S,Rt)}else Q.transparent===!0&&Q.side===wi?(Q.side=de,Q.needsUpdate=!0,w.renderBufferDirect(U,O,z,Q,S,Ft),Q.side=yr,Q.needsUpdate=!0,w.renderBufferDirect(U,O,z,Q,S,Ft),Q.side=wi):w.renderBufferDirect(U,O,z,Q,S,Ft);S.onAfterRender(w,O,U,z,Q,Ft)}function Zn(S,O,U){O.isScene!==!0&&(O=st);const z=$.get(S),Q=m.state.lights,Ft=m.state.shadowsArray,Rt=Q.state.version,Pt=Z.getParameters(S,Q.state,Ft,O,U),Vt=Z.getProgramCacheKey(Pt);let Gt=z.programs;z.environment=S.isMeshStandardMaterial?O.environment:null,z.fog=O.fog,z.envMap=(S.isMeshStandardMaterial?Mt:lt).get(S.envMap||z.environment),Gt===void 0&&(S.addEventListener("dispose",ie),Gt=new Map,z.programs=Gt);let Ut=Gt.get(Vt);if(Ut!==void 0){if(z.currentProgram===Ut&&z.lightsStateVersion===Rt)return ui(S,Pt),Ut}else Pt.uniforms=Z.getUniforms(S),S.onBuild(Pt,w),S.onBeforeCompile(Pt,w),Ut=Z.acquireProgram(Pt,Vt),Gt.set(Vt,Ut),z.uniforms=Pt.uniforms;const qt=z.uniforms;(!S.isShaderMaterial&&!S.isRawShaderMaterial||S.clipping===!0)&&(qt.clippingPlanes=Lt.uniform),ui(S,Pt),z.needsLights=ao(S),z.lightsStateVersion=Rt,z.needsLights&&(qt.ambientLightColor.value=Q.state.ambient,qt.lightProbe.value=Q.state.probe,qt.directionalLights.value=Q.state.directional,qt.directionalLightShadows.value=Q.state.directionalShadow,qt.spotLights.value=Q.state.spot,qt.spotLightShadows.value=Q.state.spotShadow,qt.rectAreaLights.value=Q.state.rectArea,qt.ltc_1.value=Q.state.rectAreaLTC1,qt.ltc_2.value=Q.state.rectAreaLTC2,qt.pointLights.value=Q.state.point,qt.pointLightShadows.value=Q.state.pointShadow,qt.hemisphereLights.value=Q.state.hemi,qt.directionalShadowMap.value=Q.state.directionalShadowMap,qt.directionalShadowMatrix.value=Q.state.directionalShadowMatrix,qt.spotShadowMap.value=Q.state.spotShadowMap,qt.spotShadowMatrix.value=Q.state.spotShadowMatrix,qt.pointShadowMap.value=Q.state.pointShadowMap,qt.pointShadowMatrix.value=Q.state.pointShadowMatrix);const re=Ut.getUniforms(),nn=Un.seqWithValue(re.seq,qt);return z.currentProgram=Ut,z.uniformsList=nn,Ut}function ui(S,O){const U=$.get(S);U.outputEncoding=O.outputEncoding,U.instancing=O.instancing,U.skinning=O.skinning,U.morphTargets=O.morphTargets,U.morphNormals=O.morphNormals,U.morphTargetsCount=O.morphTargetsCount,U.numClippingPlanes=O.numClippingPlanes,U.numIntersection=O.numClipIntersection,U.vertexAlphas=O.vertexAlphas,U.vertexTangents=O.vertexTangents}function $r(S,O,U,z,Q){O.isScene!==!0&&(O=st),et.resetTextureUnits();const Ft=O.fog,Rt=z.isMeshStandardMaterial?O.environment:null,Pt=R===null?w.outputEncoding:R.texture.encoding,Vt=(z.isMeshStandardMaterial?Mt:lt).get(z.envMap||Rt),Gt=z.vertexColors===!0&&!!U&&!!U.attributes.color&&U.attributes.color.itemSize===4,Ut=!!z.normalMap&&!!U&&!!U.attributes.tangent,qt=!!U&&!!U.morphAttributes.position,re=!!U&&!!U.morphAttributes.normal,nn=!!U&&!!U.morphAttributes.position?U.morphAttributes.position.length:0,jt=$.get(z),$n=m.state.lights;if(yt===!0&&(bt===!0||S!==P)){const De=S===P&&z.id===C;Lt.setState(z,S,De)}let Jt=!1;z.version===jt.__version?(jt.needsLights&&jt.lightsStateVersion!==$n.state.version||jt.outputEncoding!==Pt||Q.isInstancedMesh&&jt.instancing===!1||!Q.isInstancedMesh&&jt.instancing===!0||Q.isSkinnedMesh&&jt.skinning===!1||!Q.isSkinnedMesh&&jt.skinning===!0||jt.envMap!==Vt||z.fog&&jt.fog!==Ft||jt.numClippingPlanes!==void 0&&(jt.numClippingPlanes!==Lt.numPlanes||jt.numIntersection!==Lt.numIntersection)||jt.vertexAlphas!==Gt||jt.vertexTangents!==Ut||jt.morphTargets!==qt||jt.morphNormals!==re||ut.isWebGL2===!0&&jt.morphTargetsCount!==nn)&&(Jt=!0):(Jt=!0,jt.__version=z.version);let ye=jt.currentProgram;Jt===!0&&(ye=Zn(z,O,Q));let Oe=!1,dn=!1,rn=!1;const ne=ye.getUniforms(),yn=jt.uniforms;if(xt.useProgram(ye.program)&&(Oe=!0,dn=!0,rn=!0),z.id!==C&&(C=z.id,dn=!0),Oe||P!==S){if(ne.setValue(q,"projectionMatrix",S.projectionMatrix),ut.logarithmicDepthBuffer&&ne.setValue(q,"logDepthBufFC",2/(Math.log(S.far+1)/Math.LN2)),P!==S&&(P=S,dn=!0,rn=!0),z.isShaderMaterial||z.isMeshPhongMaterial||z.isMeshToonMaterial||z.isMeshStandardMaterial||z.envMap){const De=ne.map.cameraPosition;De!==void 0&&De.setValue(q,K.setFromMatrixPosition(S.matrixWorld))}(z.isMeshPhongMaterial||z.isMeshToonMaterial||z.isMeshLambertMaterial||z.isMeshBasicMaterial||z.isMeshStandardMaterial||z.isShaderMaterial)&&ne.setValue(q,"isOrthographic",S.isOrthographicCamera===!0),(z.isMeshPhongMaterial||z.isMeshToonMaterial||z.isMeshLambertMaterial||z.isMeshBasicMaterial||z.isMeshStandardMaterial||z.isShaderMaterial||z.isShadowMaterial||Q.isSkinnedMesh)&&ne.setValue(q,"viewMatrix",S.matrixWorldInverse)}if(Q.isSkinnedMesh){ne.setOptional(q,Q,"bindMatrix"),ne.setOptional(q,Q,"bindMatrixInverse");const De=Q.skeleton;De&&(ut.floatVertexTextures?(De.boneTexture===null&&De.computeBoneTexture(),ne.setValue(q,"boneTexture",De.boneTexture,et),ne.setValue(q,"boneTextureSize",De.boneTextureSize)):ne.setOptional(q,De,"boneMatrices"))}return!!U&&(U.morphAttributes.position!==void 0||U.morphAttributes.normal!==void 0)&&Et.update(Q,U,z,ye),(dn||jt.receiveShadow!==Q.receiveShadow)&&(jt.receiveShadow=Q.receiveShadow,ne.setValue(q,"receiveShadow",Q.receiveShadow)),dn&&(ne.setValue(q,"toneMappingExposure",w.toneMappingExposure),jt.needsLights&&oo(yn,rn),Ft&&z.fog&&rt.refreshFogUniforms(yn,Ft),rt.refreshMaterialUniforms(yn,z,k,Y,mt),Un.upload(q,jt.uniformsList,yn,et)),z.isShaderMaterial&&z.uniformsNeedUpdate===!0&&(Un.upload(q,jt.uniformsList,yn,et),z.uniformsNeedUpdate=!1),z.isSpriteMaterial&&ne.setValue(q,"center",Q.center),ne.setValue(q,"modelViewMatrix",Q.modelViewMatrix),ne.setValue(q,"normalMatrix",Q.normalMatrix),ne.setValue(q,"modelMatrix",Q.matrixWorld),ye}function oo(S,O){S.ambientLightColor.needsUpdate=O,S.lightProbe.needsUpdate=O,S.directionalLights.needsUpdate=O,S.directionalLightShadows.needsUpdate=O,S.pointLights.needsUpdate=O,S.pointLightShadows.needsUpdate=O,S.spotLights.needsUpdate=O,S.spotLightShadows.needsUpdate=O,S.rectAreaLights.needsUpdate=O,S.hemisphereLights.needsUpdate=O}function ao(S){return S.isMeshLambertMaterial||S.isMeshToonMaterial||S.isMeshPhongMaterial||S.isMeshStandardMaterial||S.isShadowMaterial||S.isShaderMaterial&&S.lights===!0}this.getActiveCubeFace=function(){return x},this.getActiveMipmapLevel=function(){return _},this.getRenderTarget=function(){return R},this.setRenderTarget=function(S,O=0,U=0){R=S,x=O,_=U,S&&$.get(S).__webglFramebuffer===void 0&&et.setupRenderTarget(S);let z=null,Q=!1,Ft=!1;if(S){const Pt=S.texture;(Pt.isDataTexture3D||Pt.isDataTexture2DArray)&&(Ft=!0);const Vt=$.get(S).__webglFramebuffer;S.isWebGLCubeRenderTarget?(z=Vt[O],Q=!0):S.isWebGLMultisampleRenderTarget?z=$.get(S).__webglMultisampledFramebuffer:z=Vt,N.copy(S.viewport),T.copy(S.scissor),H=S.scissorTest}else N.copy(j).multiplyScalar(k).floor(),T.copy(W).multiplyScalar(k).floor(),H=B;if(xt.bindFramebuffer(36160,z)&&ut.drawBuffers){let Pt=!1;if(S)if(S.isWebGLMultipleRenderTargets){const Vt=S.texture;if(X.length!==Vt.length||X[0]!==36064){for(let Gt=0,Ut=Vt.length;Gt<Ut;Gt++)X[Gt]=36064+Gt;X.length=Vt.length,Pt=!0}}else(X.length!==1||X[0]!==36064)&&(X[0]=36064,X.length=1,Pt=!0);else(X.length!==1||X[0]!==1029)&&(X[0]=1029,X.length=1,Pt=!0);Pt&&(ut.isWebGL2?q.drawBuffers(X):At.get("WEBGL_draw_buffers").drawBuffersWEBGL(X))}if(xt.viewport(N),xt.scissor(T),xt.setScissorTest(H),Q){const Pt=$.get(S.texture);q.framebufferTexture2D(36160,36064,34069+O,Pt.__webglTexture,U)}else if(Ft){const Pt=$.get(S.texture),Vt=O||0;q.framebufferTextureLayer(36160,36064,Pt.__webglTexture,U||0,Vt)}C=-1},this.readRenderTargetPixels=function(S,O,U,z,Q,Ft,Rt){if(!(S&&S.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Pt=$.get(S).__webglFramebuffer;if(S.isWebGLCubeRenderTarget&&Rt!==void 0&&(Pt=Pt[Rt]),Pt){xt.bindFramebuffer(36160,Pt);try{const Vt=S.texture,Gt=Vt.format,Ut=Vt.type;if(Gt!==Pe&&J.convert(Gt)!==q.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const qt=Ut===Si&&(At.has("EXT_color_buffer_half_float")||ut.isWebGL2&&At.has("EXT_color_buffer_float"));if(Ut!==Pn&&J.convert(Ut)!==q.getParameter(35738)&&!(Ut===Ln&&(ut.isWebGL2||At.has("OES_texture_float")||At.has("WEBGL_color_buffer_float")))&&!qt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}q.checkFramebufferStatus(36160)===36053?O>=0&&O<=S.width-z&&U>=0&&U<=S.height-Q&&q.readPixels(O,U,z,Q,J.convert(Gt),J.convert(Ut),Ft):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Vt=R!==null?$.get(R).__webglFramebuffer:null;xt.bindFramebuffer(36160,Vt)}}},this.copyFramebufferToTexture=function(S,O,U=0){const z=Math.pow(2,-U),Q=Math.floor(O.image.width*z),Ft=Math.floor(O.image.height*z);let Rt=J.convert(O.format);ut.isWebGL2&&(Rt===6407&&(Rt=32849),Rt===6408&&(Rt=32856)),et.setTexture2D(O,0),q.copyTexImage2D(3553,U,Rt,S.x,S.y,Q,Ft,0),xt.unbindTexture()},this.copyTextureToTexture=function(S,O,U,z=0){const Q=O.image.width,Ft=O.image.height,Rt=J.convert(U.format),Pt=J.convert(U.type);et.setTexture2D(U,0),q.pixelStorei(37440,U.flipY),q.pixelStorei(37441,U.premultiplyAlpha),q.pixelStorei(3317,U.unpackAlignment),O.isDataTexture?q.texSubImage2D(3553,z,S.x,S.y,Q,Ft,Rt,Pt,O.image.data):O.isCompressedTexture?q.compressedTexSubImage2D(3553,z,S.x,S.y,O.mipmaps[0].width,O.mipmaps[0].height,Rt,O.mipmaps[0].data):q.texSubImage2D(3553,z,S.x,S.y,Rt,Pt,O.image),z===0&&U.generateMipmaps&&q.generateMipmap(3553),xt.unbindTexture()},this.copyTextureToTexture3D=function(S,O,U,z,Q=0){if(w.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Ft=S.max.x-S.min.x+1,Rt=S.max.y-S.min.y+1,Pt=S.max.z-S.min.z+1,Vt=J.convert(z.format),Gt=J.convert(z.type);let Ut;if(z.isDataTexture3D)et.setTexture3D(z,0),Ut=32879;else if(z.isDataTexture2DArray)et.setTexture2DArray(z,0),Ut=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}q.pixelStorei(37440,z.flipY),q.pixelStorei(37441,z.premultiplyAlpha),q.pixelStorei(3317,z.unpackAlignment);const qt=q.getParameter(3314),re=q.getParameter(32878),nn=q.getParameter(3316),jt=q.getParameter(3315),$n=q.getParameter(32877),Jt=U.isCompressedTexture?U.mipmaps[0]:U.image;q.pixelStorei(3314,Jt.width),q.pixelStorei(32878,Jt.height),q.pixelStorei(3316,S.min.x),q.pixelStorei(3315,S.min.y),q.pixelStorei(32877,S.min.z),U.isDataTexture||U.isDataTexture3D?q.texSubImage3D(Ut,Q,O.x,O.y,O.z,Ft,Rt,Pt,Vt,Gt,Jt.data):U.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),q.compressedTexSubImage3D(Ut,Q,O.x,O.y,O.z,Ft,Rt,Pt,Vt,Jt.data)):q.texSubImage3D(Ut,Q,O.x,O.y,O.z,Ft,Rt,Pt,Vt,Gt,Jt),q.pixelStorei(3314,qt),q.pixelStorei(32878,re),q.pixelStorei(3316,nn),q.pixelStorei(3315,jt),q.pixelStorei(32877,$n),Q===0&&z.generateMipmaps&&q.generateMipmap(Ut),xt.unbindTexture()},this.initTexture=function(S){et.setTexture2D(S,0),xt.unbindTexture()},this.resetState=function(){x=0,_=0,R=null,xt.reset(),gt.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class S0 extends te{}S0.prototype.isWebGL1Renderer=!0;class bh extends $t{constructor(){super();this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}bh.prototype.isScene=!0;class Nr{constructor(t,e){this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=Er,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=on()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,s=this.stride;i<s;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=on()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=on()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}Nr.prototype.isInterleavedBuffer=!0;const he=new L;class kr{constructor(t,e,n,i=!1){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)he.x=this.getX(e),he.y=this.getY(e),he.z=this.getZ(e),he.applyMatrix4(t),this.setXYZ(e,he.x,he.y,he.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)he.x=this.getX(e),he.y=this.getY(e),he.z=this.getZ(e),he.applyNormalMatrix(t),this.setXYZ(e,he.x,he.y,he.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)he.x=this.getX(e),he.y=this.getY(e),he.z=this.getZ(e),he.transformDirection(t),this.setXYZ(e,he.x,he.y,he.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,s){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=s,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[i+s])}return new pe(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new kr(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}kr.prototype.isInterleavedBufferAttribute=!0;class yh extends Se{constructor(t){super();this.type="SpriteMaterial",this.color=new Ct(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}yh.prototype.isSpriteMaterial=!0;let Qi;const Fr=new L,tr=new L,er=new L,nr=new tt,Br=new tt,wh=new It,Gs=new L,Vr=new L,Ws=new L,Mh=new tt,Ra=new tt,Sh=new tt;class E0 extends $t{constructor(t){super();if(this.type="Sprite",Qi===void 0){Qi=new ae;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new Nr(e,5);Qi.setIndex([0,1,2,0,2,3]),Qi.setAttribute("position",new kr(n,3,0,!1)),Qi.setAttribute("uv",new kr(n,2,3,!1))}this.geometry=Qi,this.material=t!==void 0?t:new yh,this.center=new tt(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),tr.setFromMatrixScale(this.matrixWorld),wh.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),er.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&tr.multiplyScalar(-er.z);const n=this.material.rotation;let i,s;n!==0&&(s=Math.cos(n),i=Math.sin(n));const l=this.center;qs(Gs.set(-.5,-.5,0),er,l,tr,i,s),qs(Vr.set(.5,-.5,0),er,l,tr,i,s),qs(Ws.set(.5,.5,0),er,l,tr,i,s),Mh.set(0,0),Ra.set(1,0),Sh.set(1,1);let h=t.ray.intersectTriangle(Gs,Vr,Ws,!1,Fr);if(h===null&&(qs(Vr.set(-.5,.5,0),er,l,tr,i,s),Ra.set(0,1),h=t.ray.intersectTriangle(Gs,Ws,Vr,!1,Fr),h===null))return;const u=t.ray.origin.distanceTo(Fr);u<t.near||u>t.far||e.push({distance:u,point:Fr.clone(),uv:ue.getUV(Fr,Gs,Vr,Ws,Mh,Ra,Sh,new tt),face:null,object:this})}copy(t){return super.copy(t),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}E0.prototype.isSprite=!0;function qs(o,t,e,n,i,s){nr.subVectors(o,e).addScalar(.5).multiply(n),i!==void 0?(Br.x=s*nr.x-i*nr.y,Br.y=i*nr.x+s*nr.y):Br.copy(nr),o.copy(t),o.x+=Br.x,o.y+=Br.y,o.applyMatrix4(wh)}const Eh=new L,Th=new Qt,Ch=new Qt,T0=new L,Ah=new It;class Ph extends Fe{constructor(t,e){super(t,e);this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new It,this.bindMatrixInverse=new It}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Qt,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const s=1/t.manhattanLength();s!==1/0?t.multiplyScalar(s):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,i=this.geometry;Th.fromBufferAttribute(i.attributes.skinIndex,t),Ch.fromBufferAttribute(i.attributes.skinWeight,t),Eh.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let s=0;s<4;s++){const l=Ch.getComponent(s);if(l!==0){const h=Th.getComponent(s);Ah.multiplyMatrices(n.bones[h].matrixWorld,n.boneInverses[h]),e.addScaledVector(T0.copy(Eh).applyMatrix4(Ah),l)}}return e.applyMatrix4(this.bindMatrixInverse)}}Ph.prototype.isSkinnedMesh=!0;class C0 extends $t{constructor(){super();this.type="Bone"}}C0.prototype.isBone=!0;class A0 extends xe{constructor(t=null,e=1,n=1,i,s,l,h,u,d=fe,f=fe,g,m){super(null,l,h,u,d,f,i,s,g,m);this.image={data:t,width:e,height:n},this.magFilter=d,this.minFilter=f,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}A0.prototype.isDataTexture=!0;class Da extends pe{constructor(t,e,n,i=1){typeof n=="number"&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));super(t,e,n);this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}Da.prototype.isInstancedBufferAttribute=!0;const Lh=new It,Rh=new It,js=[],Or=new Fe;class P0 extends Fe{constructor(t,e,n){super(t,e);this.instanceMatrix=new Da(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}raycast(t,e){const n=this.matrixWorld,i=this.count;if(Or.geometry=this.geometry,Or.material=this.material,Or.material!==void 0)for(let s=0;s<i;s++){this.getMatrixAt(s,Lh),Rh.multiplyMatrices(n,Lh),Or.matrixWorld=Rh,Or.raycast(t,js);for(let l=0,h=js.length;l<h;l++){const u=js[l];u.instanceId=s,u.object=this,e.push(u)}js.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new Da(new Float32Array(this.instanceMatrix.count*3),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}P0.prototype.isInstancedMesh=!0;class zr extends Se{constructor(t){super();this.type="LineBasicMaterial",this.color=new Ct(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}zr.prototype.isLineBasicMaterial=!0;const Dh=new L,Ih=new L,Nh=new It,Ia=new Fi,Xs=new ki;class Na extends $t{constructor(t=new ae,e=new zr){super();this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[0];for(let i=1,s=e.count;i<s;i++)Dh.fromBufferAttribute(e,i-1),Ih.fromBufferAttribute(e,i),n[i]=n[i-1],n[i]+=Dh.distanceTo(Ih);t.setAttribute("lineDistance",new me(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,s=t.params.Line.threshold,l=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Xs.copy(n.boundingSphere),Xs.applyMatrix4(i),Xs.radius+=s,t.ray.intersectsSphere(Xs)===!1)return;Nh.copy(i).invert(),Ia.copy(t.ray).applyMatrix4(Nh);const h=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=h*h,d=new L,f=new L,g=new L,m=new L,v=this.isLineSegments?2:1;if(n.isBufferGeometry){const b=n.index,M=n.attributes.position;if(b!==null){const x=Math.max(0,l.start),_=Math.min(b.count,l.start+l.count);for(let R=x,C=_-1;R<C;R+=v){const P=b.getX(R),N=b.getX(R+1);if(d.fromBufferAttribute(M,P),f.fromBufferAttribute(M,N),Ia.distanceSqToSegment(d,f,m,g)>u)continue;m.applyMatrix4(this.matrixWorld);const H=t.ray.origin.distanceTo(m);H<t.near||H>t.far||e.push({distance:H,point:g.clone().applyMatrix4(this.matrixWorld),index:R,face:null,faceIndex:null,object:this})}}else{const x=Math.max(0,l.start),_=Math.min(M.count,l.start+l.count);for(let R=x,C=_-1;R<C;R+=v){if(d.fromBufferAttribute(M,R),f.fromBufferAttribute(M,R+1),Ia.distanceSqToSegment(d,f,m,g)>u)continue;m.applyMatrix4(this.matrixWorld);const N=t.ray.origin.distanceTo(m);N<t.near||N>t.far||e.push({distance:N,point:g.clone().applyMatrix4(this.matrixWorld),index:R,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,l=i.length;s<l;s++){const h=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Na.prototype.isLine=!0;const kh=new L,Fh=new L;class ka extends Na{constructor(t,e){super(t,e);this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[];for(let i=0,s=e.count;i<s;i+=2)kh.fromBufferAttribute(e,i),Fh.fromBufferAttribute(e,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+kh.distanceTo(Fh);t.setAttribute("lineDistance",new me(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}ka.prototype.isLineSegments=!0;class L0 extends Na{constructor(t,e){super(t,e);this.type="LineLoop"}}L0.prototype.isLineLoop=!0;class Bh extends Se{constructor(t){super();this.type="PointsMaterial",this.color=new Ct(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}Bh.prototype.isPointsMaterial=!0;const Vh=new It,Fa=new Fi,Ys=new ki,Zs=new L;class R0 extends $t{constructor(t=new ae,e=new Bh){super();this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,s=t.params.Points.threshold,l=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Ys.copy(n.boundingSphere),Ys.applyMatrix4(i),Ys.radius+=s,t.ray.intersectsSphere(Ys)===!1)return;Vh.copy(i).invert(),Fa.copy(t.ray).applyMatrix4(Vh);const h=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=h*h;if(n.isBufferGeometry){const d=n.index,g=n.attributes.position;if(d!==null){const m=Math.max(0,l.start),v=Math.min(d.count,l.start+l.count);for(let b=m,w=v;b<w;b++){const M=d.getX(b);Zs.fromBufferAttribute(g,M),Oh(Zs,M,u,i,t,e,this)}}else{const m=Math.max(0,l.start),v=Math.min(g.count,l.start+l.count);for(let b=m,w=v;b<w;b++)Zs.fromBufferAttribute(g,b),Oh(Zs,b,u,i,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,l=i.length;s<l;s++){const h=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}R0.prototype.isPoints=!0;function Oh(o,t,e,n,i,s,l){const h=Fa.distanceSqToPoint(o);if(h<e){const u=new L;Fa.closestPointToPoint(o,u),u.applyMatrix4(n);const d=i.ray.origin.distanceTo(u);if(d<i.near||d>i.far)return;s.push({distance:d,distanceToRay:Math.sqrt(h),point:u,index:t,face:null,object:l})}}class D0 extends xe{constructor(t,e,n,i,s,l,h,u,d){super(t,e,n,i,s,l,h,u,d);this.format=h!==void 0?h:Ei,this.minFilter=l!==void 0?l:je,this.magFilter=s!==void 0?s:je,this.generateMipmaps=!1;const f=this;function g(){f.needsUpdate=!0,t.requestVideoFrameCallback(g)}"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(g)}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}D0.prototype.isVideoTexture=!0;class I0 extends xe{constructor(t,e,n,i,s,l,h,u,d,f,g,m){super(null,l,h,u,d,f,i,s,g,m);this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}I0.prototype.isCompressedTexture=!0;class N0 extends xe{constructor(t,e,n,i,s,l,h,u,d){super(t,e,n,i,s,l,h,u,d);this.needsUpdate=!0}}N0.prototype.isCanvasTexture=!0;class k0 extends xe{constructor(t,e,n,i,s,l,h,u,d,f){if(f=f!==void 0?f:Ti,f!==Ti&&f!==Sr)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&f===Ti&&(n=fs),n===void 0&&f===Sr&&(n=Mr);super(null,i,s,l,h,u,f,n,d);this.image={width:t,height:e},this.magFilter=h!==void 0?h:fe,this.minFilter=u!==void 0?u:fe,this.flipY=!1,this.generateMipmaps=!1}}k0.prototype.isDepthTexture=!0;new L;new L;new L;new ue;class Ye{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),s=0;e.push(0);for(let l=1;l<=t;l++)n=this.getPoint(l/t),s+=n.distanceTo(i),e.push(s),i=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let i=0;const s=n.length;let l;e?l=e:l=t*n[s-1];let h=0,u=s-1,d;for(;h<=u;)if(i=Math.floor(h+(u-h)/2),d=n[i]-l,d<0)h=i+1;else if(d>0)u=i-1;else{u=i;break}if(i=u,n[i]===l)return i/(s-1);const f=n[i],m=n[i+1]-f,v=(l-f)/m;return(i+v)/(s-1)}getTangent(t,e){const n=1e-4;let i=t-n,s=t+n;i<0&&(i=0),s>1&&(s=1);const l=this.getPoint(i),h=this.getPoint(s),u=e||(l.isVector2?new tt:new L);return u.copy(h).sub(l).normalize(),u}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new L,i=[],s=[],l=[],h=new L,u=new It;for(let v=0;v<=t;v++){const b=v/t;i[v]=this.getTangentAt(b,new L)}s[0]=new L,l[0]=new L;let d=Number.MAX_VALUE;const f=Math.abs(i[0].x),g=Math.abs(i[0].y),m=Math.abs(i[0].z);f<=d&&(d=f,n.set(1,0,0)),g<=d&&(d=g,n.set(0,1,0)),m<=d&&n.set(0,0,1),h.crossVectors(i[0],n).normalize(),s[0].crossVectors(i[0],h),l[0].crossVectors(i[0],s[0]);for(let v=1;v<=t;v++){if(s[v]=s[v-1].clone(),l[v]=l[v-1].clone(),h.crossVectors(i[v-1],i[v]),h.length()>Number.EPSILON){h.normalize();const b=Math.acos(ke(i[v-1].dot(i[v]),-1,1));s[v].applyMatrix4(u.makeRotationAxis(h,b))}l[v].crossVectors(i[v],s[v])}if(e===!0){let v=Math.acos(ke(s[0].dot(s[t]),-1,1));v/=t,i[0].dot(h.crossVectors(s[0],s[t]))>0&&(v=-v);for(let b=1;b<=t;b++)s[b].applyMatrix4(u.makeRotationAxis(i[b],v*b)),l[b].crossVectors(i[b],s[b])}return{tangents:i,normals:s,binormals:l}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class $s extends Ye{constructor(t=0,e=0,n=1,i=1,s=0,l=Math.PI*2,h=!1,u=0){super();this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=i,this.aStartAngle=s,this.aEndAngle=l,this.aClockwise=h,this.aRotation=u}getPoint(t,e){const n=e||new tt,i=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const l=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=i;for(;s>i;)s-=i;s<Number.EPSILON&&(l?s=0:s=i),this.aClockwise===!0&&!l&&(s===i?s=-i:s=s-i);const h=this.aStartAngle+t*s;let u=this.aX+this.xRadius*Math.cos(h),d=this.aY+this.yRadius*Math.sin(h);if(this.aRotation!==0){const f=Math.cos(this.aRotation),g=Math.sin(this.aRotation),m=u-this.aX,v=d-this.aY;u=m*f-v*g+this.aX,d=m*g+v*f+this.aY}return n.set(u,d)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}$s.prototype.isEllipseCurve=!0;class zh extends $s{constructor(t,e,n,i,s,l){super(t,e,n,n,i,s,l);this.type="ArcCurve"}}zh.prototype.isArcCurve=!0;function Ba(){let o=0,t=0,e=0,n=0;function i(s,l,h,u){o=s,t=h,e=-3*s+3*l-2*h-u,n=2*s-2*l+h+u}return{initCatmullRom:function(s,l,h,u,d){i(l,h,d*(h-s),d*(u-l))},initNonuniformCatmullRom:function(s,l,h,u,d,f,g){let m=(l-s)/d-(h-s)/(d+f)+(h-l)/f,v=(h-l)/f-(u-l)/(f+g)+(u-h)/g;m*=f,v*=f,i(l,h,m,v)},calc:function(s){const l=s*s,h=l*s;return o+t*s+e*l+n*h}}}const Ks=new L,Va=new Ba,Oa=new Ba,za=new Ba;class Uh extends Ye{constructor(t=[],e=!1,n="centripetal",i=.5){super();this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}getPoint(t,e=new L){const n=e,i=this.points,s=i.length,l=(s-(this.closed?0:1))*t;let h=Math.floor(l),u=l-h;this.closed?h+=h>0?0:(Math.floor(Math.abs(h)/s)+1)*s:u===0&&h===s-1&&(h=s-2,u=1);let d,f;this.closed||h>0?d=i[(h-1)%s]:(Ks.subVectors(i[0],i[1]).add(i[0]),d=Ks);const g=i[h%s],m=i[(h+1)%s];if(this.closed||h+2<s?f=i[(h+2)%s]:(Ks.subVectors(i[s-1],i[s-2]).add(i[s-1]),f=Ks),this.curveType==="centripetal"||this.curveType==="chordal"){const v=this.curveType==="chordal"?.5:.25;let b=Math.pow(d.distanceToSquared(g),v),w=Math.pow(g.distanceToSquared(m),v),M=Math.pow(m.distanceToSquared(f),v);w<1e-4&&(w=1),b<1e-4&&(b=w),M<1e-4&&(M=w),Va.initNonuniformCatmullRom(d.x,g.x,m.x,f.x,b,w,M),Oa.initNonuniformCatmullRom(d.y,g.y,m.y,f.y,b,w,M),za.initNonuniformCatmullRom(d.z,g.z,m.z,f.z,b,w,M)}else this.curveType==="catmullrom"&&(Va.initCatmullRom(d.x,g.x,m.x,f.x,this.tension),Oa.initCatmullRom(d.y,g.y,m.y,f.y,this.tension),za.initCatmullRom(d.z,g.z,m.z,f.z,this.tension));return n.set(Va.calc(u),Oa.calc(u),za.calc(u)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new L().fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}Uh.prototype.isCatmullRomCurve3=!0;function Hh(o,t,e,n,i){const s=(n-t)*.5,l=(i-e)*.5,h=o*o,u=o*h;return(2*e-2*n+s+l)*u+(-3*e+3*n-2*s-l)*h+s*o+e}function F0(o,t){const e=1-o;return e*e*t}function B0(o,t){return 2*(1-o)*o*t}function V0(o,t){return o*o*t}function Ur(o,t,e,n){return F0(o,t)+B0(o,e)+V0(o,n)}function O0(o,t){const e=1-o;return e*e*e*t}function z0(o,t){const e=1-o;return 3*e*e*o*t}function U0(o,t){return 3*(1-o)*o*o*t}function H0(o,t){return o*o*o*t}function Hr(o,t,e,n,i){return O0(o,t)+z0(o,e)+U0(o,n)+H0(o,i)}class Ua extends Ye{constructor(t=new tt,e=new tt,n=new tt,i=new tt){super();this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new tt){const n=e,i=this.v0,s=this.v1,l=this.v2,h=this.v3;return n.set(Hr(t,i.x,s.x,l.x,h.x),Hr(t,i.y,s.y,l.y,h.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Ua.prototype.isCubicBezierCurve=!0;class Gh extends Ye{constructor(t=new L,e=new L,n=new L,i=new L){super();this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new L){const n=e,i=this.v0,s=this.v1,l=this.v2,h=this.v3;return n.set(Hr(t,i.x,s.x,l.x,h.x),Hr(t,i.y,s.y,l.y,h.y),Hr(t,i.z,s.z,l.z,h.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Gh.prototype.isCubicBezierCurve3=!0;class Js extends Ye{constructor(t=new tt,e=new tt){super();this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new tt){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new tt;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Js.prototype.isLineCurve=!0;class G0 extends Ye{constructor(t=new L,e=new L){super();this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new L){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Ha extends Ye{constructor(t=new tt,e=new tt,n=new tt){super();this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new tt){const n=e,i=this.v0,s=this.v1,l=this.v2;return n.set(Ur(t,i.x,s.x,l.x),Ur(t,i.y,s.y,l.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Ha.prototype.isQuadraticBezierCurve=!0;class Wh extends Ye{constructor(t=new L,e=new L,n=new L){super();this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new L){const n=e,i=this.v0,s=this.v1,l=this.v2;return n.set(Ur(t,i.x,s.x,l.x),Ur(t,i.y,s.y,l.y),Ur(t,i.z,s.z,l.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Wh.prototype.isQuadraticBezierCurve3=!0;class Ga extends Ye{constructor(t=[]){super();this.type="SplineCurve",this.points=t}getPoint(t,e=new tt){const n=e,i=this.points,s=(i.length-1)*t,l=Math.floor(s),h=s-l,u=i[l===0?l:l-1],d=i[l],f=i[l>i.length-2?i.length-1:l+1],g=i[l>i.length-3?i.length-1:l+2];return n.set(Hh(h,u.x,d.x,f.x,g.x),Hh(h,u.y,d.y,f.y,g.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new tt().fromArray(i))}return this}}Ga.prototype.isSplineCurve=!0;var qh=Object.freeze({__proto__:null,ArcCurve:zh,CatmullRomCurve3:Uh,CubicBezierCurve:Ua,CubicBezierCurve3:Gh,EllipseCurve:$s,LineCurve:Js,LineCurve3:G0,QuadraticBezierCurve:Ha,QuadraticBezierCurve3:Wh,SplineCurve:Ga});class W0 extends Ye{constructor(){super();this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new Js(e,t))}getPoint(t,e){const n=t*this.getLength(),i=this.getCurveLengths();let s=0;for(;s<i.length;){if(i[s]>=n){const l=i[s]-n,h=this.curves[s],u=h.getLength(),d=u===0?0:1-l/u;return h.getPointAt(d,e)}s++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let i=0,s=this.curves;i<s.length;i++){const l=s[i],h=l&&l.isEllipseCurve?t*2:l&&(l.isLineCurve||l.isLineCurve3)?1:l&&l.isSplineCurve?t*l.points.length:t,u=l.getPoints(h);for(let d=0;d<u.length;d++){const f=u[d];n&&n.equals(f)||(e.push(f),n=f)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(new qh[i.type]().fromJSON(i))}return this}}class Wa extends W0{constructor(t){super();this.type="Path",this.currentPoint=new tt,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new Js(this.currentPoint.clone(),new tt(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,i){const s=new Ha(this.currentPoint.clone(),new tt(t,e),new tt(n,i));return this.curves.push(s),this.currentPoint.set(n,i),this}bezierCurveTo(t,e,n,i,s,l){const h=new Ua(this.currentPoint.clone(),new tt(t,e),new tt(n,i),new tt(s,l));return this.curves.push(h),this.currentPoint.set(s,l),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new Ga(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,i,s,l){const h=this.currentPoint.x,u=this.currentPoint.y;return this.absarc(t+h,e+u,n,i,s,l),this}absarc(t,e,n,i,s,l){return this.absellipse(t,e,n,n,i,s,l),this}ellipse(t,e,n,i,s,l,h,u){const d=this.currentPoint.x,f=this.currentPoint.y;return this.absellipse(t+d,e+f,n,i,s,l,h,u),this}absellipse(t,e,n,i,s,l,h,u){const d=new $s(t,e,n,i,s,l,h,u);if(this.curves.length>0){const g=d.getPoint(0);g.equals(this.currentPoint)||this.lineTo(g.x,g.y)}this.curves.push(d);const f=d.getPoint(1);return this.currentPoint.copy(f),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Gr extends Wa{constructor(t){super(t);this.uuid=on(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(new Wa().fromJSON(i))}return this}}const q0={triangulate:function(o,t,e=2){const n=t&&t.length,i=n?t[0]*e:o.length;let s=jh(o,0,i,e,!0);const l=[];if(!s||s.next===s.prev)return l;let h,u,d,f,g,m,v;if(n&&(s=$0(o,t,s,e)),o.length>80*e){h=d=o[0],u=f=o[1];for(let b=e;b<i;b+=e)g=o[b],m=o[b+1],g<h&&(h=g),m<u&&(u=m),g>d&&(d=g),m>f&&(f=m);v=Math.max(d-h,f-u),v=v!==0?1/v:0}return Wr(s,l,e,h,u,v),l}};function jh(o,t,e,n,i){let s,l;if(i===ab(o,t,e,n)>0)for(s=t;s<e;s+=n)l=Zh(s,o[s],o[s+1],l);else for(s=e-n;s>=t;s-=n)l=Zh(s,o[s],o[s+1],l);return l&&Qs(l,l.next)&&(jr(l),l=l.next),l}function Hn(o,t){if(!o)return o;t||(t=o);let e=o,n;do if(n=!1,!e.steiner&&(Qs(e,e.next)||ce(e.prev,e,e.next)===0)){if(jr(e),e=t=e.prev,e===e.next)break;n=!0}else e=e.next;while(n||e!==t);return t}function Wr(o,t,e,n,i,s,l){if(!o)return;!l&&s&&eb(o,n,i,s);let h=o,u,d;for(;o.prev!==o.next;){if(u=o.prev,d=o.next,s?X0(o,n,i,s):j0(o)){t.push(u.i/e),t.push(o.i/e),t.push(d.i/e),jr(o),o=d.next,h=d.next;continue}if(o=d,o===h){l?l===1?(o=Y0(Hn(o),t,e),Wr(o,t,e,n,i,s,2)):l===2&&Z0(o,t,e,n,i,s):Wr(Hn(o),t,e,n,i,s,1);break}}}function j0(o){const t=o.prev,e=o,n=o.next;if(ce(t,e,n)>=0)return!1;let i=o.next.next;for(;i!==o.prev;){if(ir(t.x,t.y,e.x,e.y,n.x,n.y,i.x,i.y)&&ce(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function X0(o,t,e,n){const i=o.prev,s=o,l=o.next;if(ce(i,s,l)>=0)return!1;const h=i.x<s.x?i.x<l.x?i.x:l.x:s.x<l.x?s.x:l.x,u=i.y<s.y?i.y<l.y?i.y:l.y:s.y<l.y?s.y:l.y,d=i.x>s.x?i.x>l.x?i.x:l.x:s.x>l.x?s.x:l.x,f=i.y>s.y?i.y>l.y?i.y:l.y:s.y>l.y?s.y:l.y,g=qa(h,u,t,e,n),m=qa(d,f,t,e,n);let v=o.prevZ,b=o.nextZ;for(;v&&v.z>=g&&b&&b.z<=m;){if(v!==o.prev&&v!==o.next&&ir(i.x,i.y,s.x,s.y,l.x,l.y,v.x,v.y)&&ce(v.prev,v,v.next)>=0||(v=v.prevZ,b!==o.prev&&b!==o.next&&ir(i.x,i.y,s.x,s.y,l.x,l.y,b.x,b.y)&&ce(b.prev,b,b.next)>=0))return!1;b=b.nextZ}for(;v&&v.z>=g;){if(v!==o.prev&&v!==o.next&&ir(i.x,i.y,s.x,s.y,l.x,l.y,v.x,v.y)&&ce(v.prev,v,v.next)>=0)return!1;v=v.prevZ}for(;b&&b.z<=m;){if(b!==o.prev&&b!==o.next&&ir(i.x,i.y,s.x,s.y,l.x,l.y,b.x,b.y)&&ce(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function Y0(o,t,e){let n=o;do{const i=n.prev,s=n.next.next;!Qs(i,s)&&Xh(i,n,n.next,s)&&qr(i,s)&&qr(s,i)&&(t.push(i.i/e),t.push(n.i/e),t.push(s.i/e),jr(n),jr(n.next),n=o=s),n=n.next}while(n!==o);return Hn(n)}function Z0(o,t,e,n,i,s){let l=o;do{let h=l.next.next;for(;h!==l.prev;){if(l.i!==h.i&&rb(l,h)){let u=Yh(l,h);l=Hn(l,l.next),u=Hn(u,u.next),Wr(l,t,e,n,i,s),Wr(u,t,e,n,i,s);return}h=h.next}l=l.next}while(l!==o)}function $0(o,t,e,n){const i=[];let s,l,h,u,d;for(s=0,l=t.length;s<l;s++)h=t[s]*n,u=s<l-1?t[s+1]*n:o.length,d=jh(o,h,u,n,!1),d===d.next&&(d.steiner=!0),i.push(ib(d));for(i.sort(K0),s=0;s<i.length;s++)J0(i[s],e),e=Hn(e,e.next);return e}function K0(o,t){return o.x-t.x}function J0(o,t){if(t=Q0(o,t),t){const e=Yh(t,o);Hn(t,t.next),Hn(e,e.next)}}function Q0(o,t){let e=t;const n=o.x,i=o.y;let s=-1/0,l;do{if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const m=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(m<=n&&m>s){if(s=m,m===n){if(i===e.y)return e;if(i===e.next.y)return e.next}l=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!l)return null;if(n===s)return l;const h=l,u=l.x,d=l.y;let f=1/0,g;e=l;do n>=e.x&&e.x>=u&&n!==e.x&&ir(i<d?n:s,i,u,d,i<d?s:n,i,e.x,e.y)&&(g=Math.abs(i-e.y)/(n-e.x),qr(e,o)&&(g<f||g===f&&(e.x>l.x||e.x===l.x&&tb(l,e)))&&(l=e,f=g)),e=e.next;while(e!==h);return l}function tb(o,t){return ce(o.prev,o,t.prev)<0&&ce(t.next,o,o.next)<0}function eb(o,t,e,n){let i=o;do i.z===null&&(i.z=qa(i.x,i.y,t,e,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==o);i.prevZ.nextZ=null,i.prevZ=null,nb(i)}function nb(o){let t,e,n,i,s,l,h,u,d=1;do{for(e=o,o=null,s=null,l=0;e;){for(l++,n=e,h=0,t=0;t<d&&(h++,n=n.nextZ,!!n);t++);for(u=d;h>0||u>0&&n;)h!==0&&(u===0||!n||e.z<=n.z)?(i=e,e=e.nextZ,h--):(i=n,n=n.nextZ,u--),s?s.nextZ=i:o=i,i.prevZ=s,s=i;e=n}s.nextZ=null,d*=2}while(l>1);return o}function qa(o,t,e,n,i){return o=32767*(o-e)*i,t=32767*(t-n)*i,o=(o|o<<8)&16711935,o=(o|o<<4)&252645135,o=(o|o<<2)&858993459,o=(o|o<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,o|t<<1}function ib(o){let t=o,e=o;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==o);return e}function ir(o,t,e,n,i,s,l,h){return(i-l)*(t-h)-(o-l)*(s-h)>=0&&(o-l)*(n-h)-(e-l)*(t-h)>=0&&(e-l)*(s-h)-(i-l)*(n-h)>=0}function rb(o,t){return o.next.i!==t.i&&o.prev.i!==t.i&&!sb(o,t)&&(qr(o,t)&&qr(t,o)&&ob(o,t)&&(ce(o.prev,o,t.prev)||ce(o,t.prev,t))||Qs(o,t)&&ce(o.prev,o,o.next)>0&&ce(t.prev,t,t.next)>0)}function ce(o,t,e){return(t.y-o.y)*(e.x-t.x)-(t.x-o.x)*(e.y-t.y)}function Qs(o,t){return o.x===t.x&&o.y===t.y}function Xh(o,t,e,n){const i=eo(ce(o,t,e)),s=eo(ce(o,t,n)),l=eo(ce(e,n,o)),h=eo(ce(e,n,t));return!!(i!==s&&l!==h||i===0&&to(o,e,t)||s===0&&to(o,n,t)||l===0&&to(e,o,n)||h===0&&to(e,t,n))}function to(o,t,e){return t.x<=Math.max(o.x,e.x)&&t.x>=Math.min(o.x,e.x)&&t.y<=Math.max(o.y,e.y)&&t.y>=Math.min(o.y,e.y)}function eo(o){return o>0?1:o<0?-1:0}function sb(o,t){let e=o;do{if(e.i!==o.i&&e.next.i!==o.i&&e.i!==t.i&&e.next.i!==t.i&&Xh(e,e.next,o,t))return!0;e=e.next}while(e!==o);return!1}function qr(o,t){return ce(o.prev,o,o.next)<0?ce(o,t,o.next)>=0&&ce(o,o.prev,t)>=0:ce(o,t,o.prev)<0||ce(o,o.next,t)<0}function ob(o,t){let e=o,n=!1;const i=(o.x+t.x)/2,s=(o.y+t.y)/2;do e.y>s!=e.next.y>s&&e.next.y!==e.y&&i<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(n=!n),e=e.next;while(e!==o);return n}function Yh(o,t){const e=new ja(o.i,o.x,o.y),n=new ja(t.i,t.x,t.y),i=o.next,s=t.prev;return o.next=t,t.prev=o,e.next=i,i.prev=e,n.next=e,e.prev=n,s.next=n,n.prev=s,n}function Zh(o,t,e,n){const i=new ja(o,t,e);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function jr(o){o.next.prev=o.prev,o.prev.next=o.next,o.prevZ&&(o.prevZ.nextZ=o.nextZ),o.nextZ&&(o.nextZ.prevZ=o.prevZ)}function ja(o,t,e){this.i=o,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function ab(o,t,e,n){let i=0;for(let s=t,l=e-n;s<e;s+=n)i+=(o[l]-o[s])*(o[s+1]+o[l+1]),l=s;return i}class Gn{static area(t){const e=t.length;let n=0;for(let i=e-1,s=0;s<e;i=s++)n+=t[i].x*t[s].y-t[s].x*t[i].y;return n*.5}static isClockWise(t){return Gn.area(t)<0}static triangulateShape(t,e){const n=[],i=[],s=[];$h(t),Kh(n,t);let l=t.length;e.forEach($h);for(let u=0;u<e.length;u++)i.push(l),l+=e[u].length,Kh(n,e[u]);const h=q0.triangulate(n,i);for(let u=0;u<h.length;u+=3)s.push(h.slice(u,u+3));return s}}function $h(o){const t=o.length;t>2&&o[t-1].equals(o[0])&&o.pop()}function Kh(o,t){for(let e=0;e<t.length;e++)o.push(t[e].x),o.push(t[e].y)}class rr extends ae{constructor(t=new Gr([new tt(.5,.5),new tt(-.5,.5),new tt(-.5,-.5),new tt(.5,-.5)]),e={}){super();this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],s=[];for(let h=0,u=t.length;h<u;h++){const d=t[h];l(d)}this.setAttribute("position",new me(i,3)),this.setAttribute("uv",new me(s,2)),this.computeVertexNormals();function l(h){const u=[],d=e.curveSegments!==void 0?e.curveSegments:12,f=e.steps!==void 0?e.steps:1;let g=e.depth!==void 0?e.depth:1,m=e.bevelEnabled!==void 0?e.bevelEnabled:!0,v=e.bevelThickness!==void 0?e.bevelThickness:.2,b=e.bevelSize!==void 0?e.bevelSize:v-.1,w=e.bevelOffset!==void 0?e.bevelOffset:0,M=e.bevelSegments!==void 0?e.bevelSegments:3;const x=e.extrudePath,_=e.UVGenerator!==void 0?e.UVGenerator:lb;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),g=e.amount);let R,C=!1,P,N,T,H;x&&(R=x.getSpacedPoints(f),C=!0,m=!1,P=x.computeFrenetFrames(f,!1),N=new L,T=new L,H=new L),m||(M=0,v=0,b=0,w=0);const nt=h.extractPoints(d);let Y=nt.shape;const k=nt.holes;if(!Gn.isClockWise(Y)){Y=Y.reverse();for(let $=0,et=k.length;$<et;$++){const lt=k[$];Gn.isClockWise(lt)&&(k[$]=lt.reverse())}}const G=Gn.triangulateShape(Y,k),j=Y;for(let $=0,et=k.length;$<et;$++){const lt=k[$];Y=Y.concat(lt)}function W($,et,lt){return et||console.error("THREE.ExtrudeGeometry: vec does not exist"),et.clone().multiplyScalar(lt).add($)}const B=Y.length,X=G.length;function at($,et,lt){let Mt,dt,A;const E=$.x-et.x,Z=$.y-et.y,rt=lt.x-$.x,it=lt.y-$.y,_t=E*E+Z*Z,Lt=E*it-Z*rt;if(Math.abs(Lt)>Number.EPSILON){const St=Math.sqrt(_t),Nt=Math.sqrt(rt*rt+it*it),Et=et.x-Z/St,F=et.y+E/St,pt=lt.x-it/Nt,J=lt.y+rt/Nt,gt=((pt-Et)*it-(J-F)*rt)/(E*it-Z*rt);Mt=Et+E*gt-$.x,dt=F+Z*gt-$.y;const D=Mt*Mt+dt*dt;if(D<=2)return new tt(Mt,dt);A=Math.sqrt(D/2)}else{let St=!1;E>Number.EPSILON?rt>Number.EPSILON&&(St=!0):E<-Number.EPSILON?rt<-Number.EPSILON&&(St=!0):Math.sign(Z)===Math.sign(it)&&(St=!0),St?(Mt=-Z,dt=E,A=Math.sqrt(_t)):(Mt=E,dt=Z,A=Math.sqrt(_t/2))}return new tt(Mt/A,dt/A)}const yt=[];for(let $=0,et=j.length,lt=et-1,Mt=$+1;$<et;$++,lt++,Mt++)lt===et&&(lt=0),Mt===et&&(Mt=0),yt[$]=at(j[$],j[lt],j[Mt]);const bt=[];let mt,vt=yt.concat();for(let $=0,et=k.length;$<et;$++){const lt=k[$];mt=[];for(let Mt=0,dt=lt.length,A=dt-1,E=Mt+1;Mt<dt;Mt++,A++,E++)A===dt&&(A=0),E===dt&&(E=0),mt[Mt]=at(lt[Mt],lt[A],lt[E]);bt.push(mt),vt=vt.concat(mt)}for(let $=0;$<M;$++){const et=$/M,lt=v*Math.cos(et*Math.PI/2),Mt=b*Math.sin(et*Math.PI/2)+w;for(let dt=0,A=j.length;dt<A;dt++){const E=W(j[dt],yt[dt],Mt);Tt(E.x,E.y,-lt)}for(let dt=0,A=k.length;dt<A;dt++){const E=k[dt];mt=bt[dt];for(let Z=0,rt=E.length;Z<rt;Z++){const it=W(E[Z],mt[Z],Mt);Tt(it.x,it.y,-lt)}}}const K=b+w;for(let $=0;$<B;$++){const et=m?W(Y[$],vt[$],K):Y[$];C?(T.copy(P.normals[0]).multiplyScalar(et.x),N.copy(P.binormals[0]).multiplyScalar(et.y),H.copy(R[0]).add(T).add(N),Tt(H.x,H.y,H.z)):Tt(et.x,et.y,0)}for(let $=1;$<=f;$++)for(let et=0;et<B;et++){const lt=m?W(Y[et],vt[et],K):Y[et];C?(T.copy(P.normals[$]).multiplyScalar(lt.x),N.copy(P.binormals[$]).multiplyScalar(lt.y),H.copy(R[$]).add(T).add(N),Tt(H.x,H.y,H.z)):Tt(lt.x,lt.y,g/f*$)}for(let $=M-1;$>=0;$--){const et=$/M,lt=v*Math.cos(et*Math.PI/2),Mt=b*Math.sin(et*Math.PI/2)+w;for(let dt=0,A=j.length;dt<A;dt++){const E=W(j[dt],yt[dt],Mt);Tt(E.x,E.y,g+lt)}for(let dt=0,A=k.length;dt<A;dt++){const E=k[dt];mt=bt[dt];for(let Z=0,rt=E.length;Z<rt;Z++){const it=W(E[Z],mt[Z],Mt);C?Tt(it.x,it.y+R[f-1].y,R[f-1].x+lt):Tt(it.x,it.y,g+lt)}}}st(),wt();function st(){const $=i.length/3;if(m){let et=0,lt=B*et;for(let Mt=0;Mt<X;Mt++){const dt=G[Mt];At(dt[2]+lt,dt[1]+lt,dt[0]+lt)}et=f+M*2,lt=B*et;for(let Mt=0;Mt<X;Mt++){const dt=G[Mt];At(dt[0]+lt,dt[1]+lt,dt[2]+lt)}}else{for(let et=0;et<X;et++){const lt=G[et];At(lt[2],lt[1],lt[0])}for(let et=0;et<X;et++){const lt=G[et];At(lt[0]+B*f,lt[1]+B*f,lt[2]+B*f)}}n.addGroup($,i.length/3-$,0)}function wt(){const $=i.length/3;let et=0;q(j,et),et+=j.length;for(let lt=0,Mt=k.length;lt<Mt;lt++){const dt=k[lt];q(dt,et),et+=dt.length}n.addGroup($,i.length/3-$,1)}function q($,et){let lt=$.length;for(;--lt>=0;){const Mt=lt;let dt=lt-1;dt<0&&(dt=$.length-1);for(let A=0,E=f+M*2;A<E;A++){const Z=B*A,rt=B*(A+1),it=et+Mt+Z,_t=et+dt+Z,Lt=et+dt+rt,St=et+Mt+rt;ut(it,_t,Lt,St)}}}function Tt($,et,lt){u.push($),u.push(et),u.push(lt)}function At($,et,lt){xt($),xt(et),xt(lt);const Mt=i.length/3,dt=_.generateTopUV(n,i,Mt-3,Mt-2,Mt-1);kt(dt[0]),kt(dt[1]),kt(dt[2])}function ut($,et,lt,Mt){xt($),xt(et),xt(Mt),xt(et),xt(lt),xt(Mt);const dt=i.length/3,A=_.generateSideWallUV(n,i,dt-6,dt-3,dt-2,dt-1);kt(A[0]),kt(A[1]),kt(A[3]),kt(A[1]),kt(A[2]),kt(A[3])}function xt($){i.push(u[$*3+0]),i.push(u[$*3+1]),i.push(u[$*3+2])}function kt($){s.push($.x),s.push($.y)}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,n=this.parameters.options;return cb(e,n,t)}static fromJSON(t,e){const n=[];for(let s=0,l=t.shapes.length;s<l;s++){const h=e[t.shapes[s]];n.push(h)}const i=t.options.extrudePath;return i!==void 0&&(t.options.extrudePath=new qh[i.type]().fromJSON(i)),new rr(n,t.options)}}const lb={generateTopUV:function(o,t,e,n,i){const s=t[e*3],l=t[e*3+1],h=t[n*3],u=t[n*3+1],d=t[i*3],f=t[i*3+1];return[new tt(s,l),new tt(h,u),new tt(d,f)]},generateSideWallUV:function(o,t,e,n,i,s){const l=t[e*3],h=t[e*3+1],u=t[e*3+2],d=t[n*3],f=t[n*3+1],g=t[n*3+2],m=t[i*3],v=t[i*3+1],b=t[i*3+2],w=t[s*3],M=t[s*3+1],x=t[s*3+2];return Math.abs(h-f)<Math.abs(l-d)?[new tt(l,1-u),new tt(d,1-g),new tt(m,1-b),new tt(w,1-x)]:[new tt(h,1-u),new tt(f,1-g),new tt(v,1-b),new tt(M,1-x)]}};function cb(o,t,e){if(e.shapes=[],Array.isArray(o))for(let n=0,i=o.length;n<i;n++){const s=o[n];e.shapes.push(s.uuid)}else e.shapes.push(o.uuid);return t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class Xa extends ae{constructor(t=new Gr([new tt(0,.5),new tt(-.5,-.5),new tt(.5,-.5)]),e=12){super();this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],s=[],l=[];let h=0,u=0;if(Array.isArray(t)===!1)d(t);else for(let f=0;f<t.length;f++)d(t[f]),this.addGroup(h,u,f),h+=u,u=0;this.setIndex(n),this.setAttribute("position",new me(i,3)),this.setAttribute("normal",new me(s,3)),this.setAttribute("uv",new me(l,2));function d(f){const g=i.length/3,m=f.extractPoints(e);let v=m.shape;const b=m.holes;Gn.isClockWise(v)===!1&&(v=v.reverse());for(let M=0,x=b.length;M<x;M++){const _=b[M];Gn.isClockWise(_)===!0&&(b[M]=_.reverse())}const w=Gn.triangulateShape(v,b);for(let M=0,x=b.length;M<x;M++){const _=b[M];v=v.concat(_)}for(let M=0,x=v.length;M<x;M++){const _=v[M];i.push(_.x,_.y,0),s.push(0,0,1),l.push(_.x,_.y)}for(let M=0,x=w.length;M<x;M++){const _=w[M],R=_[0]+g,C=_[1]+g,P=_[2]+g;n.push(R,C,P),u+=3}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return hb(e,t)}static fromJSON(t,e){const n=[];for(let i=0,s=t.shapes.length;i<s;i++){const l=e[t.shapes[i]];n.push(l)}return new Xa(n,t.curveSegments)}}function hb(o,t){if(t.shapes=[],Array.isArray(o))for(let e=0,n=o.length;e<n;e++){const i=o[e];t.shapes.push(i.uuid)}else t.shapes.push(o.uuid);return t}class ub extends Se{constructor(t){super();this.type="ShadowMaterial",this.color=new Ct(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}ub.prototype.isShadowMaterial=!0;class Jh extends Se{constructor(t){super();this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ct(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ct(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pi,this.normalScale=new tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}Jh.prototype.isMeshStandardMaterial=!0;class db extends Jh{constructor(t){super();this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new tt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return ke(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.sheenTint=new Ct(0),this.sheenRoughness=1,this.transmissionMap=null,this.thickness=.01,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationTint=new Ct(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularTint=new Ct(1,1,1),this.specularTintMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheen=t.sheen,this.sheenTint.copy(t.sheenTint),this.sheenRoughness=t.sheenRoughness,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationTint.copy(t.attenuationTint),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularTint.copy(t.specularTint),this.specularTintMap=t.specularTintMap,this}}db.prototype.isMeshPhysicalMaterial=!0;class pb extends Se{constructor(t){super();this.type="MeshPhongMaterial",this.color=new Ct(16777215),this.specular=new Ct(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ct(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pi,this.normalScale=new tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=cs,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}pb.prototype.isMeshPhongMaterial=!0;class fb extends Se{constructor(t){super();this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ct(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ct(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pi,this.normalScale=new tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}fb.prototype.isMeshToonMaterial=!0;class mb extends Se{constructor(t){super();this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pi,this.normalScale=new tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}mb.prototype.isMeshNormalMaterial=!0;class gb extends Se{constructor(t){super();this.type="MeshLambertMaterial",this.color=new Ct(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ct(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=cs,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}gb.prototype.isMeshLambertMaterial=!0;class vb extends Se{constructor(t){super();this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ct(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Pi,this.normalScale=new tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}vb.prototype.isMeshMatcapMaterial=!0;class _b extends zr{constructor(t){super();this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}_b.prototype.isLineDashedMaterial=!0;const le={arraySlice:function(o,t,e){return le.isTypedArray(o)?new o.constructor(o.subarray(t,e!==void 0?e:o.length)):o.slice(t,e)},convertArray:function(o,t,e){return!o||!e&&o.constructor===t?o:typeof t.BYTES_PER_ELEMENT=="number"?new t(o):Array.prototype.slice.call(o)},isTypedArray:function(o){return ArrayBuffer.isView(o)&&!(o instanceof DataView)},getKeyframeOrder:function(o){function t(i,s){return o[i]-o[s]}const e=o.length,n=new Array(e);for(let i=0;i!==e;++i)n[i]=i;return n.sort(t),n},sortedArray:function(o,t,e){const n=o.length,i=new o.constructor(n);for(let s=0,l=0;l!==n;++s){const h=e[s]*t;for(let u=0;u!==t;++u)i[l++]=o[h+u]}return i},flattenJSON:function(o,t,e,n){let i=1,s=o[0];for(;s!==void 0&&s[n]===void 0;)s=o[i++];if(s===void 0)return;let l=s[n];if(l!==void 0)if(Array.isArray(l))do l=s[n],l!==void 0&&(t.push(s.time),e.push.apply(e,l)),s=o[i++];while(s!==void 0);else if(l.toArray!==void 0)do l=s[n],l!==void 0&&(t.push(s.time),l.toArray(e,e.length)),s=o[i++];while(s!==void 0);else do l=s[n],l!==void 0&&(t.push(s.time),e.push(l)),s=o[i++];while(s!==void 0)},subclip:function(o,t,e,n,i=30){const s=o.clone();s.name=t;const l=[];for(let u=0;u<s.tracks.length;++u){const d=s.tracks[u],f=d.getValueSize(),g=[],m=[];for(let v=0;v<d.times.length;++v){const b=d.times[v]*i;if(!(b<e||b>=n)){g.push(d.times[v]);for(let w=0;w<f;++w)m.push(d.values[v*f+w])}}g.length!==0&&(d.times=le.convertArray(g,d.times.constructor),d.values=le.convertArray(m,d.values.constructor),l.push(d))}s.tracks=l;let h=1/0;for(let u=0;u<s.tracks.length;++u)h>s.tracks[u].times[0]&&(h=s.tracks[u].times[0]);for(let u=0;u<s.tracks.length;++u)s.tracks[u].shift(-1*h);return s.resetDuration(),s},makeClipAdditive:function(o,t=0,e=o,n=30){n<=0&&(n=30);const i=e.tracks.length,s=t/n;for(let l=0;l<i;++l){const h=e.tracks[l],u=h.ValueTypeName;if(u==="bool"||u==="string")continue;const d=o.tracks.find(function(x){return x.name===h.name&&x.ValueTypeName===u});if(d===void 0)continue;let f=0;const g=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=g/3);let m=0;const v=d.getValueSize();d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(m=v/3);const b=h.times.length-1;let w;if(s<=h.times[0]){const x=f,_=g-f;w=le.arraySlice(h.values,x,_)}else if(s>=h.times[b]){const x=b*g+f,_=x+g-f;w=le.arraySlice(h.values,x,_)}else{const x=h.createInterpolant(),_=f,R=g-f;x.evaluate(s),w=le.arraySlice(x.resultBuffer,_,R)}u==="quaternion"&&new Me().fromArray(w).normalize().conjugate().toArray(w);const M=d.times.length;for(let x=0;x<M;++x){const _=x*v+m;if(u==="quaternion")Me.multiplyQuaternionsFlat(d.values,_,w,0,d.values,_);else{const R=v-m*2;for(let C=0;C<R;++C)d.values[_+C]-=w[C]}}}return o.blendMode=fc,o}};class Wn{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],s=e[n-1];t:{e:{let l;n:{i:if(!(t<i)){for(let h=n+2;;){if(i===void 0){if(t<s)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,s)}if(n===h)break;if(s=i,i=e[++n],t<i)break e}l=e.length;break n}if(!(t>=s)){const h=e[1];t<h&&(n=2,s=h);for(let u=n-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(n===u)break;if(i=s,s=e[--n-1],t>=s)break e}l=n,n=0;break n}break t}for(;n<l;){const h=n+l>>>1;t<e[h]?l=h:n=h+1}if(i=e[n],s=e[n-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(i===void 0)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,s,t)}this._cachedIndex=n,this.intervalChanged_(n,s,i)}return this.interpolate_(n,s,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=t*i;for(let l=0;l!==i;++l)e[l]=n[s+l];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Wn.prototype.beforeStart_=Wn.prototype.copySampleValue_;Wn.prototype.afterEnd_=Wn.prototype.copySampleValue_;class xb extends Wn{constructor(t,e,n,i){super(t,e,n,i);this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Ci,endingEnd:Ci}}intervalChanged_(t,e,n){const i=this.parameterPositions;let s=t-2,l=t+1,h=i[s],u=i[l];if(h===void 0)switch(this.getSettings_().endingStart){case Ai:s=t,h=2*e-n;break;case _s:s=i.length-2,h=e+i[s]-i[s+1];break;default:s=t,h=n}if(u===void 0)switch(this.getSettings_().endingEnd){case Ai:l=t,u=2*n-e;break;case _s:l=1,u=n+i[1]-i[0];break;default:l=t-1,u=e}const d=(n-e)*.5,f=this.valueSize;this._weightPrev=d/(e-h),this._weightNext=d/(u-n),this._offsetPrev=s*f,this._offsetNext=l*f}interpolate_(t,e,n,i){const s=this.resultBuffer,l=this.sampleValues,h=this.valueSize,u=t*h,d=u-h,f=this._offsetPrev,g=this._offsetNext,m=this._weightPrev,v=this._weightNext,b=(n-e)/(i-e),w=b*b,M=w*b,x=-m*M+2*m*w-m*b,_=(1+m)*M+(-1.5-2*m)*w+(-.5+m)*b+1,R=(-1-v)*M+(1.5+v)*w+.5*b,C=v*M-v*w;for(let P=0;P!==h;++P)s[P]=x*l[f+P]+_*l[d+P]+R*l[u+P]+C*l[g+P];return s}}class Qh extends Wn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const s=this.resultBuffer,l=this.sampleValues,h=this.valueSize,u=t*h,d=u-h,f=(n-e)/(i-e),g=1-f;for(let m=0;m!==h;++m)s[m]=l[d+m]*g+l[u+m]*f;return s}}class bb extends Wn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class hn{constructor(t,e,n,i){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=le.convertArray(e,this.TimeBufferType),this.values=le.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:le.convertArray(t.times,Array),values:le.convertArray(t.values,Array)};const i=t.getInterpolation();i!==t.DefaultInterpolation&&(n.interpolation=i)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new bb(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Qh(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new xb(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case gs:e=this.InterpolantFactoryMethodDiscrete;break;case vs:e=this.InterpolantFactoryMethodLinear;break;case Uo:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return gs;case this.InterpolantFactoryMethodLinear:return vs;case this.InterpolantFactoryMethodSmooth:return Uo}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let s=0,l=i-1;for(;s!==i&&n[s]<t;)++s;for(;l!==-1&&n[l]>e;)--l;if(++l,s!==0||l!==i){s>=l&&(l=Math.max(l,1),s=l-1);const h=this.getValueSize();this.times=le.arraySlice(n,s,l),this.values=le.arraySlice(this.values,s*h,l*h)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let l=null;for(let h=0;h!==s;h++){const u=n[h];if(typeof u=="number"&&isNaN(u)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,h,u),t=!1;break}if(l!==null&&l>u){console.error("THREE.KeyframeTrack: Out of order keys.",this,h,u,l),t=!1;break}l=u}if(i!==void 0&&le.isTypedArray(i))for(let h=0,u=i.length;h!==u;++h){const d=i[h];if(isNaN(d)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,h,d),t=!1;break}}return t}optimize(){const t=le.arraySlice(this.times),e=le.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===Uo,s=t.length-1;let l=1;for(let h=1;h<s;++h){let u=!1;const d=t[h],f=t[h+1];if(d!==f&&(h!==1||d!==t[0]))if(i)u=!0;else{const g=h*n,m=g-n,v=g+n;for(let b=0;b!==n;++b){const w=e[g+b];if(w!==e[m+b]||w!==e[v+b]){u=!0;break}}}if(u){if(h!==l){t[l]=t[h];const g=h*n,m=l*n;for(let v=0;v!==n;++v)e[m+v]=e[g+v]}++l}}if(s>0){t[l]=t[s];for(let h=s*n,u=l*n,d=0;d!==n;++d)e[u+d]=e[h+d];++l}return l!==t.length?(this.times=le.arraySlice(t,0,l),this.values=le.arraySlice(e,0,l*n)):(this.times=t,this.values=e),this}clone(){const t=le.arraySlice(this.times,0),e=le.arraySlice(this.values,0),n=this.constructor,i=new n(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}hn.prototype.TimeBufferType=Float32Array;hn.prototype.ValueBufferType=Float32Array;hn.prototype.DefaultInterpolation=vs;class sr extends hn{}sr.prototype.ValueTypeName="bool";sr.prototype.ValueBufferType=Array;sr.prototype.DefaultInterpolation=gs;sr.prototype.InterpolantFactoryMethodLinear=void 0;sr.prototype.InterpolantFactoryMethodSmooth=void 0;class tu extends hn{}tu.prototype.ValueTypeName="color";class no extends hn{}no.prototype.ValueTypeName="number";class yb extends Wn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const s=this.resultBuffer,l=this.sampleValues,h=this.valueSize,u=(n-e)/(i-e);let d=t*h;for(let f=d+h;d!==f;d+=4)Me.slerpFlat(s,0,l,d-h,l,d,u);return s}}class Xr extends hn{InterpolantFactoryMethodLinear(t){return new yb(this.times,this.values,this.getValueSize(),t)}}Xr.prototype.ValueTypeName="quaternion";Xr.prototype.DefaultInterpolation=vs;Xr.prototype.InterpolantFactoryMethodSmooth=void 0;class or extends hn{}or.prototype.ValueTypeName="string";or.prototype.ValueBufferType=Array;or.prototype.DefaultInterpolation=gs;or.prototype.InterpolantFactoryMethodLinear=void 0;or.prototype.InterpolantFactoryMethodSmooth=void 0;class io extends hn{}io.prototype.ValueTypeName="vector";class eu{constructor(t,e=-1,n,i=Ho){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=on(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let l=0,h=n.length;l!==h;++l)e.push(Mb(n[l]).scale(i));const s=new this(t.name,t.duration,e,t.blendMode);return s.uuid=t.uuid,s}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let s=0,l=n.length;s!==l;++s)e.push(hn.toJSON(n[s]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const s=e.length,l=[];for(let h=0;h<s;h++){let u=[],d=[];u.push((h+s-1)%s,h,(h+1)%s),d.push(0,1,0);const f=le.getKeyframeOrder(u);u=le.sortedArray(u,1,f),d=le.sortedArray(d,1,f),!i&&u[0]===0&&(u.push(s),d.push(d[0])),l.push(new no(".morphTargetInfluences["+e[h].name+"]",u,d).scale(1/n))}return new this(t,-1,l)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const i=t;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===e)return n[i];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},s=/^([\w-]*?)([\d]+)$/;for(let h=0,u=t.length;h<u;h++){const d=t[h],f=d.name.match(s);if(f&&f.length>1){const g=f[1];let m=i[g];m||(i[g]=m=[]),m.push(d)}}const l=[];for(const h in i)l.push(this.CreateFromMorphTargetSequence(h,i[h],e,n));return l}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(g,m,v,b,w){if(v.length!==0){const M=[],x=[];le.flattenJSON(v,M,x,b),M.length!==0&&w.push(new g(m,M,x))}},i=[],s=t.name||"default",l=t.fps||30,h=t.blendMode;let u=t.length||-1;const d=t.hierarchy||[];for(let g=0;g<d.length;g++){const m=d[g].keys;if(!(!m||m.length===0))if(m[0].morphTargets){const v={};let b;for(b=0;b<m.length;b++)if(m[b].morphTargets)for(let w=0;w<m[b].morphTargets.length;w++)v[m[b].morphTargets[w]]=-1;for(const w in v){const M=[],x=[];for(let _=0;_!==m[b].morphTargets.length;++_){const R=m[b];M.push(R.time),x.push(R.morphTarget===w?1:0)}i.push(new no(".morphTargetInfluence["+w+"]",M,x))}u=v.length*(l||1)}else{const v=".bones["+e[g].name+"]";n(io,v+".position",m,"pos",i),n(Xr,v+".quaternion",m,"rot",i),n(io,v+".scale",m,"scl",i)}}return i.length===0?null:new this(s,u,i,h)}resetDuration(){const t=this.tracks;let e=0;for(let n=0,i=t.length;n!==i;++n){const s=this.tracks[n];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function wb(o){switch(o.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return no;case"vector":case"vector2":case"vector3":case"vector4":return io;case"color":return tu;case"quaternion":return Xr;case"bool":case"boolean":return sr;case"string":return or}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+o)}function Mb(o){if(o.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=wb(o.type);if(o.times===void 0){const e=[],n=[];le.flattenJSON(o.keys,e,n,"value"),o.times=e,o.values=n}return t.parse!==void 0?t.parse(o):new t(o.name,o.times,o.values,o.interpolation)}const ar={enabled:!1,files:{},add:function(o,t){this.enabled!==!1&&(this.files[o]=t)},get:function(o){if(this.enabled!==!1)return this.files[o]},remove:function(o){delete this.files[o]},clear:function(){this.files={}}};class Sb{constructor(t,e,n){const i=this;let s=!1,l=0,h=0,u;const d=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(f){h++,s===!1&&i.onStart!==void 0&&i.onStart(f,l,h),s=!0},this.itemEnd=function(f){l++,i.onProgress!==void 0&&i.onProgress(f,l,h),l===h&&(s=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(f){i.onError!==void 0&&i.onError(f)},this.resolveURL=function(f){return u?u(f):f},this.setURLModifier=function(f){return u=f,this},this.addHandler=function(f,g){return d.push(f,g),this},this.removeHandler=function(f){const g=d.indexOf(f);return g!==-1&&d.splice(g,2),this},this.getHandler=function(f){for(let g=0,m=d.length;g<m;g+=2){const v=d[g],b=d[g+1];if(v.global&&(v.lastIndex=0),v.test(f))return b}return null}}}const Eb=new Sb;class qn{constructor(t){this.manager=t!==void 0?t:Eb,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(i,s){n.load(t,i,e,s)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const en={};class Tb extends qn{constructor(t){super(t)}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,l=ar.get(t);if(l!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(l),s.manager.itemEnd(t)},0),l;if(en[t]!==void 0){en[t].push({onLoad:e,onProgress:n,onError:i});return}const h=/^data:(.*?)(;base64)?,(.*)$/,u=t.match(h);let d;if(u){const f=u[1],g=!!u[2];let m=u[3];m=decodeURIComponent(m),g&&(m=atob(m));try{let v;const b=(this.responseType||"").toLowerCase();switch(b){case"arraybuffer":case"blob":const w=new Uint8Array(m.length);for(let x=0;x<m.length;x++)w[x]=m.charCodeAt(x);b==="blob"?v=new Blob([w.buffer],{type:f}):v=w.buffer;break;case"document":v=new DOMParser().parseFromString(m,f);break;case"json":v=JSON.parse(m);break;default:v=m;break}setTimeout(function(){e&&e(v),s.manager.itemEnd(t)},0)}catch(v){setTimeout(function(){i&&i(v),s.manager.itemError(t),s.manager.itemEnd(t)},0)}}else{en[t]=[],en[t].push({onLoad:e,onProgress:n,onError:i}),d=new XMLHttpRequest,d.open("GET",t,!0),d.addEventListener("load",function(f){const g=this.response,m=en[t];if(delete en[t],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),ar.add(t,g);for(let v=0,b=m.length;v<b;v++){const w=m[v];w.onLoad&&w.onLoad(g)}s.manager.itemEnd(t)}else{for(let v=0,b=m.length;v<b;v++){const w=m[v];w.onError&&w.onError(f)}s.manager.itemError(t),s.manager.itemEnd(t)}},!1),d.addEventListener("progress",function(f){const g=en[t];for(let m=0,v=g.length;m<v;m++){const b=g[m];b.onProgress&&b.onProgress(f)}},!1),d.addEventListener("error",function(f){const g=en[t];delete en[t];for(let m=0,v=g.length;m<v;m++){const b=g[m];b.onError&&b.onError(f)}s.manager.itemError(t),s.manager.itemEnd(t)},!1),d.addEventListener("abort",function(f){const g=en[t];delete en[t];for(let m=0,v=g.length;m<v;m++){const b=g[m];b.onError&&b.onError(f)}s.manager.itemError(t),s.manager.itemEnd(t)},!1),this.responseType!==void 0&&(d.responseType=this.responseType),this.withCredentials!==void 0&&(d.withCredentials=this.withCredentials),d.overrideMimeType&&d.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const f in this.requestHeader)d.setRequestHeader(f,this.requestHeader[f]);d.send(null)}return s.manager.itemStart(t),d}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class nu extends qn{constructor(t){super(t)}load(t,e,n,i){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,l=ar.get(t);if(l!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(l),s.manager.itemEnd(t)},0),l;const h=bs("img");function u(){h.removeEventListener("load",u,!1),h.removeEventListener("error",d,!1),ar.add(t,this),e&&e(this),s.manager.itemEnd(t)}function d(f){h.removeEventListener("load",u,!1),h.removeEventListener("error",d,!1),i&&i(f),s.manager.itemError(t),s.manager.itemEnd(t)}return h.addEventListener("load",u,!1),h.addEventListener("error",d,!1),t.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(h.crossOrigin=this.crossOrigin),s.manager.itemStart(t),h.src=t,h}}class Cb extends qn{constructor(t){super(t)}load(t,e,n,i){const s=new Bs,l=new nu(this.manager);l.setCrossOrigin(this.crossOrigin),l.setPath(this.path);let h=0;function u(d){l.load(t[d],function(f){s.images[d]=f,h++,h===6&&(s.needsUpdate=!0,e&&e(s))},void 0,i)}for(let d=0;d<t.length;++d)u(d);return s}}class Ab extends qn{constructor(t){super(t)}load(t,e,n,i){const s=new xe,l=new nu(this.manager);return l.setCrossOrigin(this.crossOrigin),l.setPath(this.path),l.load(t,function(h){s.image=h,s.needsUpdate=!0,e!==void 0&&e(s)},n,i),s}}class un extends $t{constructor(t,e=1){super();this.type="Light",this.color=new Ct(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}un.prototype.isLight=!0;class Pb extends un{constructor(t,e,n){super(t,n);this.type="HemisphereLight",this.position.copy($t.DefaultUp),this.updateMatrix(),this.groundColor=new Ct(e)}copy(t){return un.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}Pb.prototype.isHemisphereLight=!0;const iu=new It,ru=new L,su=new L;class Ya{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new tt(512,512),this.map=null,this.mapPass=null,this.matrix=new It,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Os,this._frameExtents=new tt(1,1),this._viewportCount=1,this._viewports=[new Qt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;ru.setFromMatrixPosition(t.matrixWorld),e.position.copy(ru),su.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(su),e.updateMatrixWorld(),iu.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(iu),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class ou extends Ya{constructor(){super(new Be(50,1,.5,500));this.focus=1}updateMatrices(t){const e=this.camera,n=Xo*2*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,s=t.distance||e.far;(n!==e.fov||i!==e.aspect||s!==e.far)&&(e.fov=n,e.aspect=i,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}ou.prototype.isSpotLightShadow=!0;class Lb extends un{constructor(t,e,n=0,i=Math.PI/3,s=0,l=1){super(t,e);this.type="SpotLight",this.position.copy($t.DefaultUp),this.updateMatrix(),this.target=new $t,this.distance=n,this.angle=i,this.penumbra=s,this.decay=l,this.shadow=new ou}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Lb.prototype.isSpotLight=!0;const au=new It,Yr=new L,Za=new L;class lu extends Ya{constructor(){super(new Be(90,1,.5,500));this._frameExtents=new tt(4,2),this._viewportCount=6,this._viewports=[new Qt(2,1,1,1),new Qt(0,1,1,1),new Qt(3,1,1,1),new Qt(1,1,1,1),new Qt(3,0,1,1),new Qt(1,0,1,1)],this._cubeDirections=[new L(1,0,0),new L(-1,0,0),new L(0,0,1),new L(0,0,-1),new L(0,1,0),new L(0,-1,0)],this._cubeUps=[new L(0,1,0),new L(0,1,0),new L(0,1,0),new L(0,1,0),new L(0,0,1),new L(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,s=t.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),Yr.setFromMatrixPosition(t.matrixWorld),n.position.copy(Yr),Za.copy(n.position),Za.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(Za),n.updateMatrixWorld(),i.makeTranslation(-Yr.x,-Yr.y,-Yr.z),au.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(au)}}lu.prototype.isPointLightShadow=!0;class Rb extends un{constructor(t,e,n=0,i=1){super(t,e);this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new lu}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}Rb.prototype.isPointLight=!0;class cu extends Ya{constructor(){super(new wa(-5,5,5,-5,.5,500))}}cu.prototype.isDirectionalLightShadow=!0;class Db extends un{constructor(t,e){super(t,e);this.type="DirectionalLight",this.position.copy($t.DefaultUp),this.updateMatrix(),this.target=new $t,this.shadow=new cu}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Db.prototype.isDirectionalLight=!0;class Ib extends un{constructor(t,e){super(t,e);this.type="AmbientLight"}}Ib.prototype.isAmbientLight=!0;class Nb extends un{constructor(t,e,n=10,i=10){super(t,e);this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}Nb.prototype.isRectAreaLight=!0;class hu{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new L)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,s=t.z,l=this.coefficients;return e.copy(l[0]).multiplyScalar(.282095),e.addScaledVector(l[1],.488603*i),e.addScaledVector(l[2],.488603*s),e.addScaledVector(l[3],.488603*n),e.addScaledVector(l[4],1.092548*(n*i)),e.addScaledVector(l[5],1.092548*(i*s)),e.addScaledVector(l[6],.315392*(3*s*s-1)),e.addScaledVector(l[7],1.092548*(n*s)),e.addScaledVector(l[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,s=t.z,l=this.coefficients;return e.copy(l[0]).multiplyScalar(.886227),e.addScaledVector(l[1],2*.511664*i),e.addScaledVector(l[2],2*.511664*s),e.addScaledVector(l[3],2*.511664*n),e.addScaledVector(l[4],2*.429043*n*i),e.addScaledVector(l[5],2*.429043*i*s),e.addScaledVector(l[6],.743125*s*s-.247708),e.addScaledVector(l[7],2*.429043*n*s),e.addScaledVector(l[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+i*3);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+i*3);return t}static getBasisAt(t,e){const n=t.x,i=t.y,s=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*s,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*s,e[6]=.315392*(3*s*s-1),e[7]=1.092548*n*s,e[8]=.546274*(n*n-i*i)}}hu.prototype.isSphericalHarmonics3=!0;class $a extends un{constructor(t=new hu,e=1){super(void 0,e);this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}$a.prototype.isLightProbe=!0;class kb{static decodeText(t){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.substr(0,e+1)}}class Fb extends ae{constructor(){super();this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}Fb.prototype.isInstancedBufferGeometry=!0;class Bb extends qn{constructor(t){super(t);typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,l=ar.get(t);if(l!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(l),s.manager.itemEnd(t)},0),l;const h={};h.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",h.headers=this.requestHeader,fetch(t,h).then(function(u){return u.blob()}).then(function(u){return createImageBitmap(u,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(u){ar.add(t,u),e&&e(u),s.manager.itemEnd(t)}).catch(function(u){i&&i(u),s.manager.itemError(t),s.manager.itemEnd(t)}),s.manager.itemStart(t)}}Bb.prototype.isImageBitmapLoader=!0;let ro;const Vb={getContext:function(){return ro===void 0&&(ro=new(window.AudioContext||window.webkitAudioContext)),ro},setContext:function(o){ro=o}};class Ob extends qn{constructor(t){super(t)}load(t,e,n,i){const s=this,l=new Tb(this.manager);l.setResponseType("arraybuffer"),l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(t,function(h){try{const u=h.slice(0);Vb.getContext().decodeAudioData(u,function(f){e(f)})}catch(u){i?i(u):console.error(u),s.manager.itemError(t)}},n,i)}}class zb extends $a{constructor(t,e,n=1){super(void 0,n);const i=new Ct().set(t),s=new Ct().set(e),l=new L(i.r,i.g,i.b),h=new L(s.r,s.g,s.b),u=Math.sqrt(Math.PI),d=u*Math.sqrt(.75);this.sh.coefficients[0].copy(l).add(h).multiplyScalar(u),this.sh.coefficients[1].copy(l).sub(h).multiplyScalar(d)}}zb.prototype.isHemisphereLightProbe=!0;class Ub extends $a{constructor(t,e=1){super(void 0,e);const n=new Ct().set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}Ub.prototype.isAmbientLightProbe=!0;class Hb extends $t{constructor(t){super();this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}class Gb{constructor(t,e,n){this.binding=t,this.valueSize=n;let i,s,l;switch(e){case"quaternion":i=this._slerp,s=this._slerpAdditive,l=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,s=this._select,l=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,s=this._lerpAdditive,l=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=s,this._setIdentity=l,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,s=t*i+i;let l=this.cumulativeWeight;if(l===0){for(let h=0;h!==i;++h)n[s+h]=n[h];l=e}else{l+=e;const h=e/l;this._mixBufferRegion(n,s,0,h,i)}this.cumulativeWeight=l}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,s=this.cumulativeWeight,l=this.cumulativeWeightAdditive,h=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const u=e*this._origIndex;this._mixBufferRegion(n,i,u,1-s,e)}l>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let u=e,d=e+e;u!==d;++u)if(n[u]!==n[u+e]){h.setValue(n,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let s=n,l=i;s!==l;++s)e[s]=e[i+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,s){if(i>=.5)for(let l=0;l!==s;++l)t[e+l]=t[n+l]}_slerp(t,e,n,i){Me.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,s){const l=this._workIndex*s;Me.multiplyQuaternionsFlat(t,l,t,e,t,n),Me.slerpFlat(t,e,t,e,t,l,i)}_lerp(t,e,n,i,s){const l=1-i;for(let h=0;h!==s;++h){const u=e+h;t[u]=t[u]*l+t[n+h]*i}}_lerpAdditive(t,e,n,i,s){for(let l=0;l!==s;++l){const h=e+l;t[h]=t[h]+t[n+l]*i}}}const Ka="\\[\\]\\.:\\/",Wb=new RegExp("["+Ka+"]","g"),Ja="[^"+Ka+"]",qb="[^"+Ka.replace("\\.","")+"]",jb=/((?:WC+[\/:])*)/.source.replace("WC",Ja),Xb=/(WCOD+)?/.source.replace("WCOD",qb),Yb=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Ja),Zb=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Ja),$b=new RegExp("^"+jb+Xb+Yb+Zb+"$"),Kb=["material","materials","bones"];class Jb{constructor(t,e,n){const i=n||Kt.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=n.length;i!==s;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}}class Kt{constructor(t,e,n){this.path=e,this.parsedPath=n||Kt.parseTrackName(e),this.node=Kt.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new Kt.Composite(t,e,n):new Kt(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(Wb,"")}static parseTrackName(t){const e=$b.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const s=n.nodeName.substring(i+1);Kb.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(!e||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(n!==void 0)return n}if(t.children){const n=function(s){for(let l=0;l<s.length;l++){const h=s[l];if(h.name===e||h.uuid===e)return h;const u=n(h.children);if(u)return u}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let s=e.propertyIndex;if(t||(t=Kt.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let d=e.objectIndex;switch(n){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let f=0;f<t.length;f++)if(t[f].name===d){d=f;break}break;default:if(t[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[n]}if(d!==void 0){if(t[d]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[d]}}const l=t[i];if(l===void 0){const d=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+d+"."+i+" but it wasn't found.",t);return}let h=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?h=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(h=this.Versioning.MatrixWorldNeedsUpdate);let u=this.BindingType.Direct;if(s!==void 0){if(i==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(t.geometry.isBufferGeometry){if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[s]!==void 0&&(s=t.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}u=this.BindingType.ArrayElement,this.resolvedProperty=l,this.propertyIndex=s}else l.fromArray!==void 0&&l.toArray!==void 0?(u=this.BindingType.HasFromToArray,this.resolvedProperty=l):Array.isArray(l)?(u=this.BindingType.EntireArray,this.resolvedProperty=l):this.propertyName=i;this.getValue=this.GetterByBindingType[u],this.setValue=this.SetterByBindingTypeAndVersioning[u][h]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Kt.Composite=Jb;Kt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Kt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Kt.prototype.GetterByBindingType=[Kt.prototype._getValue_direct,Kt.prototype._getValue_array,Kt.prototype._getValue_arrayElement,Kt.prototype._getValue_toArray];Kt.prototype.SetterByBindingTypeAndVersioning=[[Kt.prototype._setValue_direct,Kt.prototype._setValue_direct_setNeedsUpdate,Kt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Kt.prototype._setValue_array,Kt.prototype._setValue_array_setNeedsUpdate,Kt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Kt.prototype._setValue_arrayElement,Kt.prototype._setValue_arrayElement_setNeedsUpdate,Kt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Kt.prototype._setValue_fromArray,Kt.prototype._setValue_fromArray_setNeedsUpdate,Kt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Qb{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const s=e.tracks,l=s.length,h=new Array(l),u={endingStart:Ci,endingEnd:Ci};for(let d=0;d!==l;++d){const f=s[d].createInterpolant(null);h[d]=f,f.settings=u}this._interpolantSettings=u,this._interpolants=h,this._propertyBindings=new Array(l),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Dm,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const i=this._clip.duration,s=t._clip.duration,l=s/i,h=i/s;t.warp(1,l,e),this.warp(h,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,s=i.time,l=this.timeScale;let h=this._timeScaleInterpolant;h===null&&(h=i._lendControlInterpolant(),this._timeScaleInterpolant=h);const u=h.parameterPositions,d=h.sampleValues;return u[0]=s,u[1]=s+n,d[0]=t/l,d[1]=e/l,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled){this._updateWeight(t);return}const s=this._startTime;if(s!==null){const u=(t-s)*n;if(u<0||n===0)return;this._startTime=null,e=n*u}e*=this._updateTimeScale(t);const l=this._updateTime(e),h=this._updateWeight(t);if(h>0){const u=this._interpolants,d=this._propertyBindings;switch(this.blendMode){case fc:for(let f=0,g=u.length;f!==g;++f)u[f].evaluate(l),d[f].accumulateAdditive(h);break;case Ho:default:for(let f=0,g=u.length;f!==g;++f)u[f].evaluate(l),d[f].accumulate(i,h)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,s=this._loopCount;const l=n===Im;if(t===0)return s===-1?i:l&&(s&1)==1?e-i:i;if(n===Rm){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else if(i<0)i=0;else{this.time=i;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(s===-1&&(t>=0?(s=0,this._setEndings(!0,this.repetitions===0,l)):this._setEndings(this.repetitions===0,!0,l)),i>=e||i<0){const h=Math.floor(i/e);i-=e*h,s+=Math.abs(h);const u=this.repetitions-s;if(u<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(u===1){const d=t<0;this._setEndings(d,!d,l)}else this._setEndings(!1,!1,l);this._loopCount=s,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:h})}}else this.time=i;if(l&&(s&1)==1)return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=Ai,i.endingEnd=Ai):(t?i.endingStart=this.zeroSlopeAtStart?Ai:Ci:i.endingStart=_s,e?i.endingEnd=this.zeroSlopeAtEnd?Ai:Ci:i.endingEnd=_s)}_scheduleFading(t,e,n){const i=this._mixer,s=i.time;let l=this._weightInterpolant;l===null&&(l=i._lendControlInterpolant(),this._weightInterpolant=l);const h=l.parameterPositions,u=l.sampleValues;return h[0]=s,u[0]=e,h[1]=s+t,u[1]=n,this}}class ty extends Rn{constructor(t){super();this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,s=i.length,l=t._propertyBindings,h=t._interpolants,u=n.uuid,d=this._bindingsByRootAndName;let f=d[u];f===void 0&&(f={},d[u]=f);for(let g=0;g!==s;++g){const m=i[g],v=m.name;let b=f[v];if(b!==void 0)l[g]=b;else{if(b=l[g],b!==void 0){b._cacheIndex===null&&(++b.referenceCount,this._addInactiveBinding(b,u,v));continue}const w=e&&e._propertyBindings[g].binding.parsedPath;b=new Gb(Kt.create(n,v,w),m.ValueTypeName,m.getValueSize()),++b.referenceCount,this._addInactiveBinding(b,u,v),l[g]=b}h[g].resultBuffer=b.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const n=(t._localRoot||this._root).uuid,i=t._clip.uuid,s=this._actionsByClip[i];this._bindAction(t,s&&s.knownActions[0]),this._addInactiveAction(t,i,n)}const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const s=e[n];s.useCount++==0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const s=e[n];--s.useCount==0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,s=this._actionsByClip;let l=s[e];if(l===void 0)l={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,s[e]=l;else{const h=l.knownActions;t._byClipCacheIndex=h.length,h.push(t)}t._cacheIndex=i.length,i.push(t),l.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const s=t._clip.uuid,l=this._actionsByClip,h=l[s],u=h.knownActions,d=u[u.length-1],f=t._byClipCacheIndex;d._byClipCacheIndex=f,u[f]=d,u.pop(),t._byClipCacheIndex=null;const g=h.actionByRoot,m=(t._localRoot||this._root).uuid;delete g[m],u.length===0&&delete l[s],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const s=e[n];--s.referenceCount==0&&this._removeInactiveBinding(s)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,s=this._bindings;let l=i[e];l===void 0&&(l={},i[e]=l),l[n]=t,t._cacheIndex=s.length,s.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,s=n.path,l=this._bindingsByRootAndName,h=l[i],u=e[e.length-1],d=t._cacheIndex;u._cacheIndex=d,e[d]=u,e.pop(),delete h[s],Object.keys(h).length===0&&delete l[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,s=e[i];t._cacheIndex=i,e[i]=t,s._cacheIndex=n,e[n]=s}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return n===void 0&&(n=new Qh(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,s=e[i];t.__cacheIndex=i,e[i]=t,s.__cacheIndex=n,e[n]=s}clipAction(t,e,n){const i=e||this._root,s=i.uuid;let l=typeof t=="string"?eu.findByName(i,t):t;const h=l!==null?l.uuid:t,u=this._actionsByClip[h];let d=null;if(n===void 0&&(l!==null?n=l.blendMode:n=Ho),u!==void 0){const g=u.actionByRoot[s];if(g!==void 0&&g.blendMode===n)return g;d=u.knownActions[0],l===null&&(l=d._clip)}if(l===null)return null;const f=new Qb(this,l,e,n);return this._bindAction(f,d),this._addInactiveAction(f,h,s),f}existingAction(t,e){const n=e||this._root,i=n.uuid,s=typeof t=="string"?eu.findByName(n,t):t,l=s?s.uuid:t,h=this._actionsByClip[l];return h!==void 0&&h.actionByRoot[i]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let n=e-1;n>=0;--n)t[n].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,s=Math.sign(t),l=this._accuIndex^=1;for(let d=0;d!==n;++d)e[d]._update(i,t,s,l);const h=this._bindings,u=this._nActiveBindings;for(let d=0;d!==u;++d)h[d].apply(l);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,s=i[n];if(s!==void 0){const l=s.knownActions;for(let h=0,u=l.length;h!==u;++h){const d=l[h];this._deactivateAction(d);const f=d._cacheIndex,g=e[e.length-1];d._cacheIndex=null,d._byClipCacheIndex=null,g._cacheIndex=f,e[f]=g,e.pop(),this._removeInactiveBindingsForAction(d)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const l in n){const h=n[l].actionByRoot,u=h[e];u!==void 0&&(this._deactivateAction(u),this._removeInactiveAction(u))}const i=this._bindingsByRootAndName,s=i[e];if(s!==void 0)for(const l in s){const h=s[l];h.restoreOriginalState(),this._removeInactiveBinding(h)}}uncacheAction(t,e){const n=this.existingAction(t,e);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}ty.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class ey extends Nr{constructor(t,e,n=1){super(t,e);this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}ey.prototype.isInstancedInterleavedBuffer=!0;class uu{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(ke(e/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class ny extends $t{constructor(t){super();this.material=t,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}ny.prototype.isImmediateRenderObject=!0;const jn=new L,so=new It,Qa=new It;class iy extends ka{constructor(t){const e=du(t),n=new ae,i=[],s=[],l=new Ct(0,0,1),h=new Ct(0,1,0);for(let d=0;d<e.length;d++){const f=e[d];f.parent&&f.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),s.push(l.r,l.g,l.b),s.push(h.r,h.g,h.b))}n.setAttribute("position",new me(i,3)),n.setAttribute("color",new me(s,3));const u=new zr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,u);this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");Qa.copy(this.root.matrixWorld).invert();for(let s=0,l=0;s<e.length;s++){const h=e[s];h.parent&&h.parent.isBone&&(so.multiplyMatrices(Qa,h.matrixWorld),jn.setFromMatrixPosition(so),i.setXYZ(l,jn.x,jn.y,jn.z),so.multiplyMatrices(Qa,h.parent.matrixWorld),jn.setFromMatrixPosition(so),i.setXYZ(l+1,jn.x,jn.y,jn.z),l+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function du(o){const t=[];o&&o.isBone&&t.push(o);for(let e=0;e<o.children.length;e++)t.push.apply(t,du(o.children[e]));return t}class ry extends ka{constructor(t=10,e=10,n=4473924,i=8947848){n=new Ct(n),i=new Ct(i);const s=e/2,l=t/e,h=t/2,u=[],d=[];for(let m=0,v=0,b=-h;m<=e;m++,b+=l){u.push(-h,0,b,h,0,b),u.push(b,0,-h,b,0,h);const w=m===s?n:i;w.toArray(d,v),v+=3,w.toArray(d,v),v+=3,w.toArray(d,v),v+=3,w.toArray(d,v),v+=3}const f=new ae;f.setAttribute("position",new me(u,3)),f.setAttribute("color",new me(d,3));const g=new zr({vertexColors:!0,toneMapped:!1});super(f,g);this.type="GridHelper"}}const sy=new Float32Array(1);new Int32Array(sy.buffer);Ye.create=function(o,t){return console.log("THREE.Curve.create() has been deprecated"),o.prototype=Object.create(Ye.prototype),o.prototype.constructor=o,o.prototype.getPoint=t,o};Wa.prototype.fromPoints=function(o){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(o)};ry.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};iy.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};qn.prototype.extractUrlBase=function(o){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),kb.extractUrlBase(o)};qn.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};Ke.prototype.center=function(o){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(o)};Ke.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Ke.prototype.isIntersectionBox=function(o){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(o)};Ke.prototype.isIntersectionSphere=function(o){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(o)};Ke.prototype.size=function(o){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(o)};ki.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Os.prototype.setFromMatrix=function(o){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(o)};_e.prototype.flattenToArrayOffset=function(o,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(o,t)};_e.prototype.multiplyVector3=function(o){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),o.applyMatrix3(this)};_e.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};_e.prototype.applyToBufferAttribute=function(o){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),o.applyMatrix3(this)};_e.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};_e.prototype.getInverse=function(o){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(o).invert()};It.prototype.extractPosition=function(o){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(o)};It.prototype.flattenToArrayOffset=function(o,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(o,t)};It.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new L().setFromMatrixColumn(this,3)};It.prototype.setRotationFromQuaternion=function(o){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(o)};It.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};It.prototype.multiplyVector3=function(o){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};It.prototype.multiplyVector4=function(o){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};It.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};It.prototype.rotateAxis=function(o){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),o.transformDirection(this)};It.prototype.crossVector=function(o){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};It.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};It.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};It.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};It.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};It.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};It.prototype.applyToBufferAttribute=function(o){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};It.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};It.prototype.makeFrustum=function(o,t,e,n,i,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(o,t,n,e,i,s)};It.prototype.getInverse=function(o){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(o).invert()};bn.prototype.isIntersectionLine=function(o){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(o)};Me.prototype.multiplyVector3=function(o){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),o.applyQuaternion(this)};Me.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};Fi.prototype.isIntersectionBox=function(o){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(o)};Fi.prototype.isIntersectionPlane=function(o){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(o)};Fi.prototype.isIntersectionSphere=function(o){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(o)};ue.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};ue.prototype.barycoordFromPoint=function(o,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(o,t)};ue.prototype.midpoint=function(o){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(o)};ue.prototypenormal=function(o){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(o)};ue.prototype.plane=function(o){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(o)};ue.barycoordFromPoint=function(o,t,e,n,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),ue.getBarycoord(o,t,e,n,i)};ue.normal=function(o,t,e,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),ue.getNormal(o,t,e,n)};Gr.prototype.extractAllPoints=function(o){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(o)};Gr.prototype.extrude=function(o){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new rr(this,o)};Gr.prototype.makeGeometry=function(o){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Xa(this,o)};tt.prototype.fromAttribute=function(o,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,t,e)};tt.prototype.distanceToManhattan=function(o){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(o)};tt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};L.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};L.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};L.prototype.getPositionFromMatrix=function(o){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(o)};L.prototype.getScaleFromMatrix=function(o){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(o)};L.prototype.getColumnFromMatrix=function(o,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,o)};L.prototype.applyProjection=function(o){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(o)};L.prototype.fromAttribute=function(o,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,t,e)};L.prototype.distanceToManhattan=function(o){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(o)};L.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Qt.prototype.fromAttribute=function(o,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,t,e)};Qt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};$t.prototype.getChildByName=function(o){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(o)};$t.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};$t.prototype.translate=function(o,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,o)};$t.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};$t.prototype.applyMatrix=function(o){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(o)};Object.defineProperties($t.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(o){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=o}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Fe.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(Fe.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Nm},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Ph.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Be.prototype.setLens=function(o,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(o)};Object.defineProperties(un.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(o){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=o}},shadowCameraLeft:{set:function(o){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=o}},shadowCameraRight:{set:function(o){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=o}},shadowCameraTop:{set:function(o){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=o}},shadowCameraBottom:{set:function(o){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=o}},shadowCameraNear:{set:function(o){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=o}},shadowCameraFar:{set:function(o){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=o}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(o){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=o}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(o){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=o}},shadowMapHeight:{set:function(o){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=o}}});Object.defineProperties(pe.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===xs},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(xs)}}});pe.prototype.setDynamic=function(o){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(o===!0?xs:Er),this};pe.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},pe.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};ae.prototype.addIndex=function(o){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(o)};ae.prototype.addAttribute=function(o,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(o,new pe(arguments[1],arguments[2]))):o==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(o,t)};ae.prototype.addDrawCall=function(o,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(o,t)};ae.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};ae.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};ae.prototype.removeAttribute=function(o){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(o)};ae.prototype.applyMatrix=function(o){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(o)};Object.defineProperties(ae.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Nr.prototype.setDynamic=function(o){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(o===!0?xs:Er),this};Nr.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};rr.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};rr.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};rr.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};bh.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(Se.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Ct}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(o){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=o===Xl}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(o){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=o}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(ai.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(o){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=o}}});te.prototype.clearTarget=function(o,t,e,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(o),this.clear(t,e,n)};te.prototype.animate=function(o){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(o)};te.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};te.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};te.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};te.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};te.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};te.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};te.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};te.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};te.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};te.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};te.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};te.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};te.prototype.enableScissorTest=function(o){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(o)};te.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};te.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};te.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};te.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};te.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};te.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};te.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};te.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};te.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};te.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(te.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(o){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=o}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(o){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=o}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(o){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=o===!0?ri:we}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(_h.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(an.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(o){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=o}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(o){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=o}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(o){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=o}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(o){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=o}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(o){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=o}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(o){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=o}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(o){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=o}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(o){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=o}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(o){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=o}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(o){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=o}}});Hb.prototype.load=function(o){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return new Ob().load(o,function(n){t.setBuffer(n)}),this};xa.prototype.updateCubeMap=function(o,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(o,t)};xa.prototype.clear=function(o,t,e,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(o,t,e,n)};Ri.crossOrigin=void 0;Ri.loadTexture=function(o,t,e,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new Ab;i.setCrossOrigin(this.crossOrigin);const s=i.load(o,e,void 0,n);return t&&(s.mapping=t),s};Ri.loadTextureCube=function(o,t,e,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new Cb;i.setCrossOrigin(this.crossOrigin);const s=i.load(o,e,void 0,n);return t&&(s.mapping=t),s};Ri.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Ri.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Wl}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Wl);const pu={type:"change"},tl={type:"start"},el={type:"end"};class ly extends Rn{constructor(t,e){super();e===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new L,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:bi.ROTATE,MIDDLE:bi.DOLLY,RIGHT:bi.PAN},this.touches={ONE:yi.ROTATE,TWO:yi.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return h.phi},this.getAzimuthalAngle=function(){return h.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(D){D.addEventListener("keydown",_t),this._domElementKeyEvents=D},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(pu),n.update(),s=i.NONE},this.update=function(){const D=new L,ot=new Me().setFromUnitVectors(t.up,new L(0,1,0)),Ot=ot.clone().invert(),zt=new L,ie=new Me,Zt=2*Math.PI;return function(){const Re=n.object.position;D.copy(Re).sub(n.target),D.applyQuaternion(ot),h.setFromVector3(D),n.autoRotate&&s===i.NONE&&nt(T()),n.enableDamping?(h.theta+=u.theta*n.dampingFactor,h.phi+=u.phi*n.dampingFactor):(h.theta+=u.theta,h.phi+=u.phi);let Ce=n.minAzimuthAngle,Ae=n.maxAzimuthAngle;return isFinite(Ce)&&isFinite(Ae)&&(Ce<-Math.PI?Ce+=Zt:Ce>Math.PI&&(Ce-=Zt),Ae<-Math.PI?Ae+=Zt:Ae>Math.PI&&(Ae-=Zt),Ce<=Ae?h.theta=Math.max(Ce,Math.min(Ae,h.theta)):h.theta=h.theta>(Ce+Ae)/2?Math.max(Ce,h.theta):Math.min(Ae,h.theta)),h.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,h.phi)),h.makeSafe(),h.radius*=d,h.radius=Math.max(n.minDistance,Math.min(n.maxDistance,h.radius)),n.enableDamping===!0?n.target.addScaledVector(f,n.dampingFactor):n.target.add(f),D.setFromSpherical(h),D.applyQuaternion(Ot),Re.copy(n.target).add(D),n.object.lookAt(n.target),n.enableDamping===!0?(u.theta*=1-n.dampingFactor,u.phi*=1-n.dampingFactor,f.multiplyScalar(1-n.dampingFactor)):(u.set(0,0,0),f.set(0,0,0)),d=1,g||zt.distanceToSquared(n.object.position)>l||8*(1-ie.dot(n.object.quaternion))>l?(n.dispatchEvent(pu),zt.copy(n.object.position),ie.copy(n.object.quaternion),g=!1,!0):!1}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",Et),n.domElement.removeEventListener("pointerdown",lt),n.domElement.removeEventListener("pointercancel",A),n.domElement.removeEventListener("wheel",it),n.domElement.removeEventListener("pointermove",Mt),n.domElement.removeEventListener("pointerup",dt),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",_t)};const n=this,i={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=i.NONE;const l=1e-6,h=new uu,u=new uu;let d=1;const f=new L;let g=!1;const m=new tt,v=new tt,b=new tt,w=new tt,M=new tt,x=new tt,_=new tt,R=new tt,C=new tt,P=[],N={};function T(){return 2*Math.PI/60/60*n.autoRotateSpeed}function H(){return Math.pow(.95,n.zoomSpeed)}function nt(D){u.theta-=D}function Y(D){u.phi-=D}const k=function(){const D=new L;return function(Ot,zt){D.setFromMatrixColumn(zt,0),D.multiplyScalar(-Ot),f.add(D)}}(),ht=function(){const D=new L;return function(Ot,zt){n.screenSpacePanning===!0?D.setFromMatrixColumn(zt,1):(D.setFromMatrixColumn(zt,0),D.crossVectors(n.object.up,D)),D.multiplyScalar(Ot),f.add(D)}}(),G=function(){const D=new L;return function(Ot,zt){const ie=n.domElement;if(n.object.isPerspectiveCamera){const Zt=n.object.position;D.copy(Zt).sub(n.target);let be=D.length();be*=Math.tan(n.object.fov/2*Math.PI/180),k(2*Ot*be/ie.clientHeight,n.object.matrix),ht(2*zt*be/ie.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(k(Ot*(n.object.right-n.object.left)/n.object.zoom/ie.clientWidth,n.object.matrix),ht(zt*(n.object.top-n.object.bottom)/n.object.zoom/ie.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function j(D){n.object.isPerspectiveCamera?d/=D:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*D)),n.object.updateProjectionMatrix(),g=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function W(D){n.object.isPerspectiveCamera?d*=D:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/D)),n.object.updateProjectionMatrix(),g=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function B(D){m.set(D.clientX,D.clientY)}function X(D){_.set(D.clientX,D.clientY)}function at(D){w.set(D.clientX,D.clientY)}function yt(D){v.set(D.clientX,D.clientY),b.subVectors(v,m).multiplyScalar(n.rotateSpeed);const ot=n.domElement;nt(2*Math.PI*b.x/ot.clientHeight),Y(2*Math.PI*b.y/ot.clientHeight),m.copy(v),n.update()}function bt(D){R.set(D.clientX,D.clientY),C.subVectors(R,_),C.y>0?j(H()):C.y<0&&W(H()),_.copy(R),n.update()}function mt(D){M.set(D.clientX,D.clientY),x.subVectors(M,w).multiplyScalar(n.panSpeed),G(x.x,x.y),w.copy(M),n.update()}function vt(D){D.deltaY<0?W(H()):D.deltaY>0&&j(H()),n.update()}function K(D){let ot=!1;switch(D.code){case n.keys.UP:G(0,n.keyPanSpeed),ot=!0;break;case n.keys.BOTTOM:G(0,-n.keyPanSpeed),ot=!0;break;case n.keys.LEFT:G(n.keyPanSpeed,0),ot=!0;break;case n.keys.RIGHT:G(-n.keyPanSpeed,0),ot=!0;break}ot&&(D.preventDefault(),n.update())}function st(){if(P.length===1)m.set(P[0].pageX,P[0].pageY);else{const D=.5*(P[0].pageX+P[1].pageX),ot=.5*(P[0].pageY+P[1].pageY);m.set(D,ot)}}function wt(){if(P.length===1)w.set(P[0].pageX,P[0].pageY);else{const D=.5*(P[0].pageX+P[1].pageX),ot=.5*(P[0].pageY+P[1].pageY);w.set(D,ot)}}function q(){const D=P[0].pageX-P[1].pageX,ot=P[0].pageY-P[1].pageY,Ot=Math.sqrt(D*D+ot*ot);_.set(0,Ot)}function Tt(){n.enableZoom&&q(),n.enablePan&&wt()}function At(){n.enableZoom&&q(),n.enableRotate&&st()}function ut(D){if(P.length==1)v.set(D.pageX,D.pageY);else{const Ot=gt(D),zt=.5*(D.pageX+Ot.x),ie=.5*(D.pageY+Ot.y);v.set(zt,ie)}b.subVectors(v,m).multiplyScalar(n.rotateSpeed);const ot=n.domElement;nt(2*Math.PI*b.x/ot.clientHeight),Y(2*Math.PI*b.y/ot.clientHeight),m.copy(v)}function xt(D){if(P.length===1)M.set(D.pageX,D.pageY);else{const ot=gt(D),Ot=.5*(D.pageX+ot.x),zt=.5*(D.pageY+ot.y);M.set(Ot,zt)}x.subVectors(M,w).multiplyScalar(n.panSpeed),G(x.x,x.y),w.copy(M)}function kt(D){const ot=gt(D),Ot=D.pageX-ot.x,zt=D.pageY-ot.y,ie=Math.sqrt(Ot*Ot+zt*zt);R.set(0,ie),C.set(0,Math.pow(R.y/_.y,n.zoomSpeed)),j(C.y),_.copy(R)}function $(D){n.enableZoom&&kt(D),n.enablePan&&xt(D)}function et(D){n.enableZoom&&kt(D),n.enableRotate&&ut(D)}function lt(D){n.enabled!==!1&&(P.length===0&&(n.domElement.setPointerCapture(D.pointerId),n.domElement.addEventListener("pointermove",Mt),n.domElement.addEventListener("pointerup",dt)),F(D),D.pointerType==="touch"?Lt(D):E(D))}function Mt(D){n.enabled!==!1&&(D.pointerType==="touch"?St(D):Z(D))}function dt(D){n.enabled!==!1&&(D.pointerType==="touch"?Nt():rt(),pt(D),P.length===0&&(n.domElement.releasePointerCapture(D.pointerId),n.domElement.removeEventListener("pointermove",Mt),n.domElement.removeEventListener("pointerup",dt)))}function A(D){pt(D)}function E(D){let ot;switch(D.button){case 0:ot=n.mouseButtons.LEFT;break;case 1:ot=n.mouseButtons.MIDDLE;break;case 2:ot=n.mouseButtons.RIGHT;break;default:ot=-1}switch(ot){case bi.DOLLY:if(n.enableZoom===!1)return;X(D),s=i.DOLLY;break;case bi.ROTATE:if(D.ctrlKey||D.metaKey||D.shiftKey){if(n.enablePan===!1)return;at(D),s=i.PAN}else{if(n.enableRotate===!1)return;B(D),s=i.ROTATE}break;case bi.PAN:if(D.ctrlKey||D.metaKey||D.shiftKey){if(n.enableRotate===!1)return;B(D),s=i.ROTATE}else{if(n.enablePan===!1)return;at(D),s=i.PAN}break;default:s=i.NONE}s!==i.NONE&&n.dispatchEvent(tl)}function Z(D){if(n.enabled!==!1)switch(s){case i.ROTATE:if(n.enableRotate===!1)return;yt(D);break;case i.DOLLY:if(n.enableZoom===!1)return;bt(D);break;case i.PAN:if(n.enablePan===!1)return;mt(D);break}}function rt(D){n.dispatchEvent(el),s=i.NONE}function it(D){n.enabled===!1||n.enableZoom===!1||s!==i.NONE&&s!==i.ROTATE||(D.preventDefault(),n.dispatchEvent(tl),vt(D),n.dispatchEvent(el))}function _t(D){n.enabled===!1||n.enablePan===!1||K(D)}function Lt(D){switch(J(D),P.length){case 1:switch(n.touches.ONE){case yi.ROTATE:if(n.enableRotate===!1)return;st(),s=i.TOUCH_ROTATE;break;case yi.PAN:if(n.enablePan===!1)return;wt(),s=i.TOUCH_PAN;break;default:s=i.NONE}break;case 2:switch(n.touches.TWO){case yi.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;Tt(),s=i.TOUCH_DOLLY_PAN;break;case yi.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;At(),s=i.TOUCH_DOLLY_ROTATE;break;default:s=i.NONE}break;default:s=i.NONE}s!==i.NONE&&n.dispatchEvent(tl)}function St(D){switch(J(D),s){case i.TOUCH_ROTATE:if(n.enableRotate===!1)return;ut(D),n.update();break;case i.TOUCH_PAN:if(n.enablePan===!1)return;xt(D),n.update();break;case i.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;$(D),n.update();break;case i.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;et(D),n.update();break;default:s=i.NONE}}function Nt(D){n.dispatchEvent(el),s=i.NONE}function Et(D){n.enabled!==!1&&D.preventDefault()}function F(D){P.push(D)}function pt(D){delete N[D.pointerId];for(let ot=0;ot<P.length;ot++)if(P[ot].pointerId==D.pointerId){P.splice(ot,1);return}}function J(D){let ot=N[D.pointerId];ot===void 0&&(ot=new tt,N[D.pointerId]=ot),ot.set(D.pageX,D.pageY)}function gt(D){const ot=D.pointerId===P[0].pointerId?P[1]:P[0];return N[ot.pointerId]}n.domElement.addEventListener("contextmenu",Et),n.domElement.addEventListener("pointerdown",lt),n.domElement.addEventListener("pointercancel",A),n.domElement.addEventListener("wheel",it,{passive:!1}),this.update()}}var oy=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{},fu={exports:{}};/*! Tweakpane 3.0.5 (c) 2016 cocopon, licensed under the MIT license. */(function(o,t){(function(e,n){n(t)})(oy,function(e){class n{constructor(r){const[a,p]=r.split("-"),y=a.split(".");this.major=parseInt(y[0],10),this.minor=parseInt(y[1],10),this.patch=parseInt(y[2],10),this.prerelease=p!=null?p:null}toString(){const r=[this.major,this.minor,this.patch].join(".");return this.prerelease!==null?[r,this.prerelease].join("-"):r}}class i{constructor(r){this.controller_=r}get disabled(){return this.controller_.viewProps.get("disabled")}set disabled(r){this.controller_.viewProps.set("disabled",r)}get hidden(){return this.controller_.viewProps.get("hidden")}set hidden(r){this.controller_.viewProps.set("hidden",r)}dispose(){this.controller_.viewProps.set("disposed",!0)}}class s{constructor(r){this.target=r}}class l extends s{constructor(r,a,p,y){super(r);this.value=a,this.presetKey=p,this.last=y!=null?y:!0}}class h extends s{constructor(r,a,p){super(r);this.value=a,this.presetKey=p}}class u extends s{constructor(r,a){super(r);this.expanded=a}}function d(c){return c}function f(c){return c==null}function g(c,r){if(c.length!==r.length)return!1;for(let a=0;a<c.length;a++)if(c[a]!==r[a])return!1;return!0}const m={alreadydisposed:()=>"View has been already disposed",invalidparams:c=>`Invalid parameters for '${c.name}'`,nomatchingcontroller:c=>`No matching controller for '${c.key}'`,nomatchingview:c=>`No matching view for '${JSON.stringify(c.params)}'`,notbindable:()=>"Value is not bindable",propertynotfound:c=>`Property '${c.name}' not found`,shouldneverhappen:()=>"This error should never happen"};class v{constructor(r){var a;this.message=(a=m[r.type](d(r.context)))!==null&&a!==void 0?a:"Unexpected error",this.name=this.constructor.name,this.stack=new Error(this.message).stack,this.type=r.type}static alreadyDisposed(){return new v({type:"alreadydisposed"})}static notBindable(){return new v({type:"notbindable"})}static propertyNotFound(r){return new v({type:"propertynotfound",context:{name:r}})}static shouldNeverHappen(){return new v({type:"shouldneverhappen"})}}class b{constructor(r,a,p){this.obj_=r,this.key_=a,this.presetKey_=p!=null?p:a}static isBindable(r){return!(r===null||typeof r!="object")}get key(){return this.key_}get presetKey(){return this.presetKey_}read(){return this.obj_[this.key_]}write(r){this.obj_[this.key_]=r}writeProperty(r,a){const p=this.read();if(!b.isBindable(p))throw v.notBindable();if(!(r in p))throw v.propertyNotFound(r);p[r]=a}}class w extends i{get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}get title(){var r;return(r=this.controller_.valueController.props.get("title"))!==null&&r!==void 0?r:""}set title(r){this.controller_.valueController.props.set("title",r)}on(r,a){const p=a.bind(this);return this.controller_.valueController.emitter.on(r,()=>{p(new s(this))}),this}}class M{constructor(){this.observers_={}}on(r,a){let p=this.observers_[r];return p||(p=this.observers_[r]=[]),p.push({handler:a}),this}off(r,a){const p=this.observers_[r];return p&&(this.observers_[r]=p.filter(y=>y.handler!==a)),this}emit(r,a){const p=this.observers_[r];!p||p.forEach(y=>{y.handler(a)})}}const x="tp";function _(c){return(a,p)=>[x,"-",c,"v",a?`_${a}`:"",p?`-${p}`:""].join("")}function R(c,r){return a=>r(c(a))}function C(c){return c.rawValue}function P(c,r){c.emitter.on("change",R(C,r)),r(c.rawValue)}function N(c,r,a){P(c.value(r),a)}function T(c,r,a){a?c.classList.add(r):c.classList.remove(r)}function H(c,r){return a=>{T(c,r,a)}}function nt(c,r){P(c,a=>{r.textContent=a!=null?a:""})}const Y=_("btn");class k{constructor(r,a){this.element=r.createElement("div"),this.element.classList.add(Y()),a.viewProps.bindClassModifiers(this.element);const p=r.createElement("button");p.classList.add(Y("b")),a.viewProps.bindDisabled(p),this.element.appendChild(p),this.buttonElement=p;const y=r.createElement("div");y.classList.add(Y("t")),nt(a.props.value("title"),y),this.buttonElement.appendChild(y)}}class ht{constructor(r,a){this.emitter=new M,this.onClick_=this.onClick_.bind(this),this.props=a.props,this.viewProps=a.viewProps,this.view=new k(r,{props:this.props,viewProps:this.viewProps}),this.view.buttonElement.addEventListener("click",this.onClick_)}onClick_(){this.emitter.emit("click",{sender:this})}}class G{constructor(r,a){var p;this.constraint_=a==null?void 0:a.constraint,this.equals_=(p=a==null?void 0:a.equals)!==null&&p!==void 0?p:(y,I)=>y===I,this.emitter=new M,this.rawValue_=r}get constraint(){return this.constraint_}get rawValue(){return this.rawValue_}set rawValue(r){this.setRawValue(r,{forceEmit:!1,last:!0})}setRawValue(r,a){const p=a!=null?a:{forceEmit:!1,last:!0},y=this.constraint_?this.constraint_.constrain(r):r;!!this.equals_(this.rawValue_,y)&&!p.forceEmit||(this.emitter.emit("beforechange",{sender:this}),this.rawValue_=y,this.emitter.emit("change",{options:p,rawValue:y,sender:this}))}}class j{constructor(r){this.emitter=new M,this.value_=r}get rawValue(){return this.value_}set rawValue(r){this.setRawValue(r,{forceEmit:!1,last:!0})}setRawValue(r,a){const p=a!=null?a:{forceEmit:!1,last:!0};this.value_===r&&!p.forceEmit||(this.emitter.emit("beforechange",{sender:this}),this.value_=r,this.emitter.emit("change",{options:p,rawValue:this.value_,sender:this}))}}function W(c,r){const a=r==null?void 0:r.constraint,p=r==null?void 0:r.equals;return!a&&!p?new j(c):new G(c,r)}class B{constructor(r){this.emitter=new M,this.valMap_=r;for(const a in this.valMap_)this.valMap_[a].emitter.on("change",()=>{this.emitter.emit("change",{key:a,sender:this})})}static createCore(r){return Object.keys(r).reduce((p,y)=>Object.assign(p,{[y]:W(r[y])}),{})}static fromObject(r){const a=this.createCore(r);return new B(a)}get(r){return this.valMap_[r].rawValue}set(r,a){this.valMap_[r].rawValue=a}value(r){return this.valMap_[r]}}function X(c,r){const p=Object.keys(r).reduce((y,I)=>{if(y===void 0)return;const ct=r[I](c[I]);return ct.succeeded?Object.assign(Object.assign({},y),{[I]:ct.value}):void 0},{});return d(p)}function at(c,r){return c.reduce((a,p)=>{if(a===void 0)return;const y=r(p);if(!(!y.succeeded||y.value===void 0))return[...a,y.value]},[])}function yt(c){return c===null?!1:typeof c=="object"}function bt(c){return r=>a=>{if(!r&&a===void 0)return{succeeded:!1,value:void 0};if(r&&a===void 0)return{succeeded:!0,value:void 0};const p=c(a);return p!==void 0?{succeeded:!0,value:p}:{succeeded:!1,value:void 0}}}function mt(c){return{custom:r=>bt(r)(c),boolean:bt(r=>typeof r=="boolean"?r:void 0)(c),number:bt(r=>typeof r=="number"?r:void 0)(c),string:bt(r=>typeof r=="string"?r:void 0)(c),function:bt(r=>typeof r=="function"?r:void 0)(c),constant:r=>bt(a=>a===r?r:void 0)(c),raw:bt(r=>r)(c),object:r=>bt(a=>{if(!!yt(a))return X(a,r)})(c),array:r=>bt(a=>{if(!!Array.isArray(a))return at(a,r)})(c)}}const vt={optional:mt(!0),required:mt(!1)};function K(c,r){const a=vt.required.object(r)(c);return a.succeeded?a.value:void 0}function st(c){return c&&c.parentElement&&c.parentElement.removeChild(c),null}function wt(){return["veryfirst","first","last","verylast"]}const q=_(""),Tt={veryfirst:"vfst",first:"fst",last:"lst",verylast:"vlst"};class At{constructor(r){this.parent_=null,this.blade=r.blade,this.view=r.view,this.viewProps=r.viewProps;const a=this.view.element;this.blade.value("positions").emitter.on("change",()=>{wt().forEach(p=>{a.classList.remove(q(void 0,Tt[p]))}),this.blade.get("positions").forEach(p=>{a.classList.add(q(void 0,Tt[p]))})}),this.viewProps.handleDispose(()=>{st(a)})}get parent(){return this.parent_}}const ut="http://www.w3.org/2000/svg";function xt(c){c.offsetHeight}function kt(c,r){const a=c.style.transition;c.style.transition="none",r(),c.style.transition=a}function $(c){return c.ontouchstart!==void 0}function et(){return new Function("return this")()}function lt(){return d(et()).document}function Mt(){return"document"in et()}function dt(c){return Mt()?c.getContext("2d"):null}const A={check:'<path d="M2 8l4 4l8 -8"/>',dropdown:'<path d="M5 7h6l-3 3 z"/>',p2dpad:'<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'};function E(c,r){const a=c.createElementNS(ut,"svg");return a.innerHTML=A[r],a}function Z(c,r,a){c.insertBefore(r,c.children[a])}function rt(c){c.parentElement&&c.parentElement.removeChild(c)}function it(c){for(;c.children.length>0;)c.removeChild(c.children[0])}function _t(c){for(;c.childNodes.length>0;)c.removeChild(c.childNodes[0])}function Lt(c){return c.relatedTarget?d(c.relatedTarget):"explicitOriginalTarget"in c?c.explicitOriginalTarget:null}const St=_("lbl");function Nt(c,r){const a=c.createDocumentFragment();return r.split(`
`).map(y=>c.createTextNode(y)).forEach((y,I)=>{I>0&&a.appendChild(c.createElement("br")),a.appendChild(y)}),a}class Et{constructor(r,a){this.element=r.createElement("div"),this.element.classList.add(St()),a.viewProps.bindClassModifiers(this.element);const p=r.createElement("div");p.classList.add(St("l")),N(a.props,"label",I=>{f(I)?this.element.classList.add(St(void 0,"nol")):(this.element.classList.remove(St(void 0,"nol")),_t(p),p.appendChild(Nt(r,I)))}),this.element.appendChild(p),this.labelElement=p;const y=r.createElement("div");y.classList.add(St("v")),this.element.appendChild(y),this.valueElement=y}}class F extends At{constructor(r,a){const p=a.valueController.viewProps;super(Object.assign(Object.assign({},a),{view:new Et(r,{props:a.props,viewProps:p}),viewProps:p}));this.props=a.props,this.valueController=a.valueController,this.view.valueElement.appendChild(this.valueController.view.element)}}const pt={id:"button",type:"blade",accept(c){const r=vt,a=K(c,{title:r.required.string,view:r.required.constant("button"),label:r.optional.string});return a?{params:a}:null},controller(c){return new F(c.document,{blade:c.blade,props:B.fromObject({label:c.params.label}),valueController:new ht(c.document,{props:B.fromObject({title:c.params.title}),viewProps:c.viewProps})})},api(c){return!(c.controller instanceof F)||!(c.controller.valueController instanceof ht)?null:new w(c.controller)}};class J extends At{constructor(r){super(r);this.value=r.value}}function gt(){return new B({positions:W([],{equals:g})})}class D extends B{constructor(r){super(r)}static create(r){const a={completed:!0,expanded:r,expandedHeight:null,shouldFixHeight:!1,temporaryExpanded:null},p=B.createCore(a);return new D(p)}get styleExpanded(){var r;return(r=this.get("temporaryExpanded"))!==null&&r!==void 0?r:this.get("expanded")}get styleHeight(){if(!this.styleExpanded)return"0";const r=this.get("expandedHeight");return this.get("shouldFixHeight")&&!f(r)?`${r}px`:"auto"}bindExpandedClass(r,a){N(this,"expanded",()=>{this.styleExpanded?r.classList.add(a):r.classList.remove(a)})}}function ot(c,r){let a=0;return kt(r,()=>{c.set("expandedHeight",null),c.set("temporaryExpanded",!0),xt(r),a=r.clientHeight,c.set("temporaryExpanded",null),xt(r)}),a}function Ot(c,r){r.style.height=c.styleHeight}function zt(c,r){c.value("expanded").emitter.on("beforechange",()=>{c.set("completed",!1),f(c.get("expandedHeight"))&&c.set("expandedHeight",ot(c,r)),c.set("shouldFixHeight",!0),xt(r)}),c.emitter.on("change",()=>{Ot(c,r)}),Ot(c,r),r.addEventListener("transitionend",a=>{a.propertyName==="height"&&(c.set("shouldFixHeight",!1),c.set("expandedHeight",null),c.set("completed",!0))})}class ie extends i{constructor(r,a){super(r);this.rackApi_=a}}function Zt(c,r){return c.addBlade(Object.assign(Object.assign({},r),{view:"button"}))}function be(c,r){return c.addBlade(Object.assign(Object.assign({},r),{view:"folder"}))}function Re(c,r){const a=r||{};return c.addBlade(Object.assign(Object.assign({},a),{view:"separator"}))}function Ce(c,r){return c.addBlade(Object.assign(Object.assign({},r),{view:"tab"}))}class Ae{constructor(r){this.emitter=new M,this.items_=[],this.cache_=new Set,this.onSubListAdd_=this.onSubListAdd_.bind(this),this.onSubListRemove_=this.onSubListRemove_.bind(this),this.extract_=r}get items(){return this.items_}allItems(){return Array.from(this.cache_)}find(r){for(const a of this.allItems())if(r(a))return a;return null}includes(r){return this.cache_.has(r)}add(r,a){if(this.includes(r))throw v.shouldNeverHappen();const p=a!==void 0?a:this.items_.length;this.items_.splice(p,0,r),this.cache_.add(r);const y=this.extract_(r);y&&(y.emitter.on("add",this.onSubListAdd_),y.emitter.on("remove",this.onSubListRemove_),y.allItems().forEach(I=>{this.cache_.add(I)})),this.emitter.emit("add",{index:p,item:r,root:this,target:this})}remove(r){const a=this.items_.indexOf(r);if(a<0)return;this.items_.splice(a,1),this.cache_.delete(r);const p=this.extract_(r);p&&(p.emitter.off("add",this.onSubListAdd_),p.emitter.off("remove",this.onSubListRemove_)),this.emitter.emit("remove",{index:a,item:r,root:this,target:this})}onSubListAdd_(r){this.cache_.add(r.item),this.emitter.emit("add",{index:r.index,item:r.item,root:this,target:r.target})}onSubListRemove_(r){this.cache_.delete(r.item),this.emitter.emit("remove",{index:r.index,item:r.item,root:this,target:r.target})}}class ci extends i{constructor(r){super(r);this.onBindingChange_=this.onBindingChange_.bind(this),this.emitter_=new M,this.controller_.binding.emitter.on("change",this.onBindingChange_)}get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}on(r,a){const p=a.bind(this);return this.emitter_.on(r,y=>{p(y.event)}),this}refresh(){this.controller_.binding.read()}onBindingChange_(r){const a=r.sender.target.read();this.emitter_.emit("change",{event:new l(this,d(a),this.controller_.binding.target.presetKey,r.options.last)})}}class Ve extends F{constructor(r,a){super(r,a);this.binding=a.binding}}class Ze extends i{constructor(r){super(r);this.onBindingUpdate_=this.onBindingUpdate_.bind(this),this.emitter_=new M,this.controller_.binding.emitter.on("update",this.onBindingUpdate_)}get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}on(r,a){const p=a.bind(this);return this.emitter_.on(r,y=>{p(y.event)}),this}refresh(){this.controller_.binding.read()}onBindingUpdate_(r){const a=r.sender.target.read();this.emitter_.emit("update",{event:new h(this,d(a),this.controller_.binding.target.presetKey)})}}class $e extends F{constructor(r,a){super(r,a);this.binding=a.binding,this.viewProps.bindDisabled(this.binding.ticker),this.viewProps.handleDispose(()=>{this.binding.dispose()})}}function Zr(c){return c instanceof hi?c.apiSet_:c instanceof ie?c.rackApi_.apiSet_:null}function Xn(c,r){const a=c.find(p=>p.controller_===r);if(!a)throw v.shouldNeverHappen();return a}function Yn(c,r,a){if(!b.isBindable(c))throw v.notBindable();return new b(c,r,a)}class hi extends i{constructor(r,a){super(r);this.onRackAdd_=this.onRackAdd_.bind(this),this.onRackRemove_=this.onRackRemove_.bind(this),this.onRackInputChange_=this.onRackInputChange_.bind(this),this.onRackMonitorUpdate_=this.onRackMonitorUpdate_.bind(this),this.emitter_=new M,this.apiSet_=new Ae(Zr),this.pool_=a;const p=this.controller_.rack;p.emitter.on("add",this.onRackAdd_),p.emitter.on("remove",this.onRackRemove_),p.emitter.on("inputchange",this.onRackInputChange_),p.emitter.on("monitorupdate",this.onRackMonitorUpdate_),p.children.forEach(y=>{this.setUpApi_(y)})}get children(){return this.controller_.rack.children.map(r=>Xn(this.apiSet_,r))}addInput(r,a,p){const y=p||{},I=this.controller_.view.element.ownerDocument,V=this.pool_.createInput(I,Yn(r,a,y.presetKey),y),ct=new ci(V);return this.add(ct,y.index)}addMonitor(r,a,p){const y=p||{},I=this.controller_.view.element.ownerDocument,V=this.pool_.createMonitor(I,Yn(r,a),y),ct=new Ze(V);return d(this.add(ct,y.index))}addFolder(r){return be(this,r)}addButton(r){return Zt(this,r)}addSeparator(r){return Re(this,r)}addTab(r){return Ce(this,r)}add(r,a){this.controller_.rack.add(r.controller_,a);const p=this.apiSet_.find(y=>y.controller_===r.controller_);return p&&this.apiSet_.remove(p),this.apiSet_.add(r),r}remove(r){this.controller_.rack.remove(r.controller_)}addBlade(r){const a=this.controller_.view.element.ownerDocument,p=this.pool_.createBlade(a,r),y=this.pool_.createBladeApi(p);return this.add(y,r.index)}on(r,a){const p=a.bind(this);return this.emitter_.on(r,y=>{p(y.event)}),this}setUpApi_(r){this.apiSet_.find(p=>p.controller_===r)||this.apiSet_.add(this.pool_.createBladeApi(r))}onRackAdd_(r){this.setUpApi_(r.bladeController)}onRackRemove_(r){if(r.isRoot){const a=Xn(this.apiSet_,r.bladeController);this.apiSet_.remove(a)}}onRackInputChange_(r){const a=r.bladeController;if(a instanceof Ve){const p=Xn(this.apiSet_,a),y=a.binding;this.emitter_.emit("change",{event:new l(p,d(y.target.read()),y.target.presetKey,r.options.last)})}else if(a instanceof J){const p=Xn(this.apiSet_,a);this.emitter_.emit("change",{event:new l(p,a.value.rawValue,void 0,r.options.last)})}}onRackMonitorUpdate_(r){if(!(r.bladeController instanceof $e))throw v.shouldNeverHappen();const a=Xn(this.apiSet_,r.bladeController),p=r.bladeController.binding;this.emitter_.emit("update",{event:new h(a,d(p.target.read()),p.target.presetKey)})}}class Zn extends ie{constructor(r,a){super(r,new hi(r.rackController,a));this.emitter_=new M,this.controller_.foldable.value("expanded").emitter.on("change",p=>{this.emitter_.emit("fold",{event:new u(this,p.sender.rawValue)})}),this.rackApi_.on("change",p=>{this.emitter_.emit("change",{event:p})}),this.rackApi_.on("update",p=>{this.emitter_.emit("update",{event:p})})}get expanded(){return this.controller_.foldable.get("expanded")}set expanded(r){this.controller_.foldable.set("expanded",r)}get title(){return this.controller_.props.get("title")}set title(r){this.controller_.props.set("title",r)}get children(){return this.rackApi_.children}addInput(r,a,p){return this.rackApi_.addInput(r,a,p)}addMonitor(r,a,p){return this.rackApi_.addMonitor(r,a,p)}addFolder(r){return this.rackApi_.addFolder(r)}addButton(r){return this.rackApi_.addButton(r)}addSeparator(r){return this.rackApi_.addSeparator(r)}addTab(r){return this.rackApi_.addTab(r)}add(r,a){return this.rackApi_.add(r,a)}remove(r){this.rackApi_.remove(r)}addBlade(r){return this.rackApi_.addBlade(r)}on(r,a){const p=a.bind(this);return this.emitter_.on(r,y=>{p(y.event)}),this}}class ui extends At{constructor(r){super({blade:r.blade,view:r.view,viewProps:r.rackController.viewProps});this.rackController=r.rackController}}class $r{constructor(r,a){const p=_(a.viewName);this.element=r.createElement("div"),this.element.classList.add(p()),a.viewProps.bindClassModifiers(this.element)}}function oo(c,r){for(let a=0;a<c.length;a++){const p=c[a];if(p instanceof Ve&&p.binding===r)return p}return null}function ao(c,r){for(let a=0;a<c.length;a++){const p=c[a];if(p instanceof $e&&p.binding===r)return p}return null}function S(c,r){for(let a=0;a<c.length;a++){const p=c[a];if(p instanceof J&&p.value===r)return p}return null}function O(c){return c instanceof Q?c.rack:c instanceof ui?c.rackController.rack:null}function U(c){const r=O(c);return r?r.bcSet_:null}class z{constructor(r){var a;this.onBladePositionsChange_=this.onBladePositionsChange_.bind(this),this.onSetAdd_=this.onSetAdd_.bind(this),this.onSetRemove_=this.onSetRemove_.bind(this),this.onChildDispose_=this.onChildDispose_.bind(this),this.onChildPositionsChange_=this.onChildPositionsChange_.bind(this),this.onChildInputChange_=this.onChildInputChange_.bind(this),this.onChildMonitorUpdate_=this.onChildMonitorUpdate_.bind(this),this.onChildValueChange_=this.onChildValueChange_.bind(this),this.onChildViewPropsChange_=this.onChildViewPropsChange_.bind(this),this.onDescendantLayout_=this.onDescendantLayout_.bind(this),this.onDescendantInputChange_=this.onDescendantInputChange_.bind(this),this.onDescendantMonitorUpdate_=this.onDescendantMonitorUpdate_.bind(this),this.emitter=new M,this.blade_=r!=null?r:null,(a=this.blade_)===null||a===void 0||a.value("positions").emitter.on("change",this.onBladePositionsChange_),this.bcSet_=new Ae(U),this.bcSet_.emitter.on("add",this.onSetAdd_),this.bcSet_.emitter.on("remove",this.onSetRemove_)}get children(){return this.bcSet_.items}add(r,a){r.parent&&r.parent.remove(r),r.parent_=this,this.bcSet_.add(r,a)}remove(r){r.parent_=null,this.bcSet_.remove(r)}find(r){return d(this.bcSet_.allItems().filter(a=>a instanceof r))}onSetAdd_(r){this.updatePositions_();const a=r.target===r.root;if(this.emitter.emit("add",{bladeController:r.item,index:r.index,isRoot:a,sender:this}),!a)return;const p=r.item;if(p.viewProps.emitter.on("change",this.onChildViewPropsChange_),p.blade.value("positions").emitter.on("change",this.onChildPositionsChange_),p.viewProps.handleDispose(this.onChildDispose_),p instanceof Ve)p.binding.emitter.on("change",this.onChildInputChange_);else if(p instanceof $e)p.binding.emitter.on("update",this.onChildMonitorUpdate_);else if(p instanceof J)p.value.emitter.on("change",this.onChildValueChange_);else{const y=O(p);if(y){const I=y.emitter;I.on("layout",this.onDescendantLayout_),I.on("inputchange",this.onDescendantInputChange_),I.on("monitorupdate",this.onDescendantMonitorUpdate_)}}}onSetRemove_(r){this.updatePositions_();const a=r.target===r.root;if(this.emitter.emit("remove",{bladeController:r.item,isRoot:a,sender:this}),!a)return;const p=r.item;if(p instanceof Ve)p.binding.emitter.off("change",this.onChildInputChange_);else if(p instanceof $e)p.binding.emitter.off("update",this.onChildMonitorUpdate_);else if(p instanceof J)p.value.emitter.off("change",this.onChildValueChange_);else{const y=O(p);if(y){const I=y.emitter;I.off("layout",this.onDescendantLayout_),I.off("inputchange",this.onDescendantInputChange_),I.off("monitorupdate",this.onDescendantMonitorUpdate_)}}}updatePositions_(){const r=this.bcSet_.items.filter(y=>!y.viewProps.get("hidden")),a=r[0],p=r[r.length-1];this.bcSet_.items.forEach(y=>{const I=[];y===a&&(I.push("first"),(!this.blade_||this.blade_.get("positions").includes("veryfirst"))&&I.push("veryfirst")),y===p&&(I.push("last"),(!this.blade_||this.blade_.get("positions").includes("verylast"))&&I.push("verylast")),y.blade.set("positions",I)})}onChildPositionsChange_(){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onChildViewPropsChange_(r){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onChildDispose_(){this.bcSet_.items.filter(a=>a.viewProps.get("disposed")).forEach(a=>{this.bcSet_.remove(a)})}onChildInputChange_(r){const a=oo(this.find(Ve),r.sender);if(!a)throw v.shouldNeverHappen();this.emitter.emit("inputchange",{bladeController:a,options:r.options,sender:this})}onChildMonitorUpdate_(r){const a=ao(this.find($e),r.sender);if(!a)throw v.shouldNeverHappen();this.emitter.emit("monitorupdate",{bladeController:a,sender:this})}onChildValueChange_(r){const a=S(this.find(J),r.sender);if(!a)throw v.shouldNeverHappen();this.emitter.emit("inputchange",{bladeController:a,options:r.options,sender:this})}onDescendantLayout_(r){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onDescendantInputChange_(r){this.emitter.emit("inputchange",{bladeController:r.bladeController,options:r.options,sender:this})}onDescendantMonitorUpdate_(r){this.emitter.emit("monitorupdate",{bladeController:r.bladeController,sender:this})}onBladePositionsChange_(){this.updatePositions_()}}class Q extends At{constructor(r,a){super(Object.assign(Object.assign({},a),{view:new $r(r,{viewName:"brk",viewProps:a.viewProps})}));this.onRackAdd_=this.onRackAdd_.bind(this),this.onRackRemove_=this.onRackRemove_.bind(this);const p=new z(a.root?void 0:a.blade);p.emitter.on("add",this.onRackAdd_),p.emitter.on("remove",this.onRackRemove_),this.rack=p,this.viewProps.handleDispose(()=>{for(let y=this.rack.children.length-1;y>=0;y--)this.rack.children[y].viewProps.set("disposed",!0)})}onRackAdd_(r){!r.isRoot||Z(this.view.element,r.bladeController.view.element,r.index)}onRackRemove_(r){!r.isRoot||rt(r.bladeController.view.element)}}const Ft=_("cnt");class Rt{constructor(r,a){this.className_=_(a.viewName||"fld"),this.element=r.createElement("div"),this.element.classList.add(this.className_(),Ft()),a.viewProps.bindClassModifiers(this.element),this.foldable_=a.foldable,this.foldable_.bindExpandedClass(this.element,this.className_(void 0,"expanded")),N(this.foldable_,"completed",H(this.element,this.className_(void 0,"cpl")));const p=r.createElement("button");p.classList.add(this.className_("b")),N(a.props,"title",ct=>{f(ct)?this.element.classList.add(this.className_(void 0,"not")):this.element.classList.remove(this.className_(void 0,"not"))}),a.viewProps.bindDisabled(p),this.element.appendChild(p),this.buttonElement=p;const y=r.createElement("div");y.classList.add(this.className_("t")),nt(a.props.value("title"),y),this.buttonElement.appendChild(y),this.titleElement=y;const I=r.createElement("div");I.classList.add(this.className_("m")),this.buttonElement.appendChild(I);const V=a.containerElement;V.classList.add(this.className_("c")),this.element.appendChild(V),this.containerElement=V}}class Pt extends ui{constructor(r,a){var p;const y=D.create((p=a.expanded)!==null&&p!==void 0?p:!0),I=new Q(r,{blade:a.blade,root:a.root,viewProps:a.viewProps});super(Object.assign(Object.assign({},a),{rackController:I,view:new Rt(r,{containerElement:I.view.element,foldable:y,props:a.props,viewName:a.root?"rot":void 0,viewProps:a.viewProps})}));this.onTitleClick_=this.onTitleClick_.bind(this),this.props=a.props,this.foldable=y,zt(this.foldable,this.view.containerElement),this.view.buttonElement.addEventListener("click",this.onTitleClick_)}get document(){return this.view.element.ownerDocument}onTitleClick_(){this.foldable.set("expanded",!this.foldable.get("expanded"))}}const Vt={id:"folder",type:"blade",accept(c){const r=vt,a=K(c,{title:r.required.string,view:r.required.constant("folder"),expanded:r.optional.boolean});return a?{params:a}:null},controller(c){return new Pt(c.document,{blade:c.blade,expanded:c.params.expanded,props:B.fromObject({title:c.params.title}),viewProps:c.viewProps})},api(c){return c.controller instanceof Pt?new Zn(c.controller,c.pool):null}};class Gt extends J{constructor(r,a){const p=a.valueController.viewProps;super(Object.assign(Object.assign({},a),{value:a.valueController.value,view:new Et(r,{props:a.props,viewProps:p}),viewProps:p}));this.props=a.props,this.valueController=a.valueController,this.view.valueElement.appendChild(this.valueController.view.element)}}class Ut extends i{}const qt=_("spr");class re{constructor(r,a){this.element=r.createElement("div"),this.element.classList.add(qt()),a.viewProps.bindClassModifiers(this.element);const p=r.createElement("hr");p.classList.add(qt("r")),this.element.appendChild(p)}}class nn extends At{constructor(r,a){super(Object.assign(Object.assign({},a),{view:new re(r,{viewProps:a.viewProps})}))}}const jt={id:"separator",type:"blade",accept(c){const a=K(c,{view:vt.required.constant("separator")});return a?{params:a}:null},controller(c){return new nn(c.document,{blade:c.blade,viewProps:c.viewProps})},api(c){return c.controller instanceof nn?new Ut(c.controller):null}},$n=_("");function Jt(c,r){return H(c,$n(void 0,r))}class ye extends B{constructor(r){super(r)}static create(r){var a,p;const y=r!=null?r:{},I={disabled:(a=y.disabled)!==null&&a!==void 0?a:!1,disposed:!1,hidden:(p=y.hidden)!==null&&p!==void 0?p:!1},V=B.createCore(I);return new ye(V)}bindClassModifiers(r){N(this,"disabled",Jt(r,"disabled")),N(this,"hidden",Jt(r,"hidden"))}bindDisabled(r){N(this,"disabled",a=>{r.disabled=a})}bindTabIndex(r){N(this,"disabled",a=>{r.tabIndex=a?-1:0})}handleDispose(r){this.value("disposed").emitter.on("change",a=>{a&&r()})}}const Oe=_("tbi");class dn{constructor(r,a){this.element=r.createElement("div"),this.element.classList.add(Oe()),a.viewProps.bindClassModifiers(this.element),N(a.props,"selected",I=>{I?this.element.classList.add(Oe(void 0,"sel")):this.element.classList.remove(Oe(void 0,"sel"))});const p=r.createElement("button");p.classList.add(Oe("b")),a.viewProps.bindDisabled(p),this.element.appendChild(p),this.buttonElement=p;const y=r.createElement("div");y.classList.add(Oe("t")),nt(a.props.value("title"),y),this.buttonElement.appendChild(y),this.titleElement=y}}class rn{constructor(r,a){this.emitter=new M,this.onClick_=this.onClick_.bind(this),this.props=a.props,this.viewProps=a.viewProps,this.view=new dn(r,{props:a.props,viewProps:a.viewProps}),this.view.buttonElement.addEventListener("click",this.onClick_)}onClick_(){this.emitter.emit("click",{sender:this})}}class ne{constructor(r,a){this.onItemClick_=this.onItemClick_.bind(this),this.ic_=new rn(r,{props:a.itemProps,viewProps:ye.create()}),this.ic_.emitter.on("click",this.onItemClick_),this.cc_=new Q(r,{blade:gt(),viewProps:ye.create()}),this.props=a.props,N(this.props,"selected",p=>{this.itemController.props.set("selected",p),this.contentController.viewProps.set("hidden",!p)})}get itemController(){return this.ic_}get contentController(){return this.cc_}onItemClick_(){this.props.set("selected",!0)}}class yn{constructor(r,a){this.controller_=r,this.rackApi_=a}get title(){var r;return(r=this.controller_.itemController.props.get("title"))!==null&&r!==void 0?r:""}set title(r){this.controller_.itemController.props.set("title",r)}get selected(){return this.controller_.props.get("selected")}set selected(r){this.controller_.props.set("selected",r)}get children(){return this.rackApi_.children}addButton(r){return this.rackApi_.addButton(r)}addFolder(r){return this.rackApi_.addFolder(r)}addSeparator(r){return this.rackApi_.addSeparator(r)}addTab(r){return this.rackApi_.addTab(r)}add(r,a){this.rackApi_.add(r,a)}remove(r){this.rackApi_.remove(r)}addInput(r,a,p){return this.rackApi_.addInput(r,a,p)}addMonitor(r,a,p){return this.rackApi_.addMonitor(r,a,p)}addBlade(r){return this.rackApi_.addBlade(r)}}class De extends ie{constructor(r,a){super(r,new hi(r.rackController,a));this.onPageAdd_=this.onPageAdd_.bind(this),this.onPageRemove_=this.onPageRemove_.bind(this),this.emitter_=new M,this.pageApiMap_=new Map,this.rackApi_.on("change",p=>{this.emitter_.emit("change",{event:p})}),this.rackApi_.on("update",p=>{this.emitter_.emit("update",{event:p})}),this.controller_.pageSet.emitter.on("add",this.onPageAdd_),this.controller_.pageSet.emitter.on("remove",this.onPageRemove_),this.controller_.pageSet.items.forEach(p=>{this.setUpPageApi_(p)})}get pages(){return this.controller_.pageSet.items.map(r=>{const a=this.pageApiMap_.get(r);if(!a)throw v.shouldNeverHappen();return a})}addPage(r){const a=this.controller_.view.element.ownerDocument,p=new ne(a,{itemProps:B.fromObject({selected:!1,title:r.title}),props:B.fromObject({selected:!1})});this.controller_.add(p,r.index);const y=this.pageApiMap_.get(p);if(!y)throw v.shouldNeverHappen();return y}removePage(r){this.controller_.remove(r)}on(r,a){const p=a.bind(this);return this.emitter_.on(r,y=>{p(y.event)}),this}setUpPageApi_(r){const a=this.rackApi_.apiSet_.find(y=>y.controller_===r.contentController);if(!a)throw v.shouldNeverHappen();const p=new yn(r,a);this.pageApiMap_.set(r,p)}onPageAdd_(r){this.setUpPageApi_(r.item)}onPageRemove_(r){if(!this.pageApiMap_.get(r.item))throw v.shouldNeverHappen();this.pageApiMap_.delete(r.item)}}const Kr=_("tab");class mu{constructor(r,a){this.element=r.createElement("div"),this.element.classList.add(Kr(),Ft()),a.viewProps.bindClassModifiers(this.element),P(a.empty,H(this.element,Kr(void 0,"nop")));const p=r.createElement("div");p.classList.add(Kr("i")),this.element.appendChild(p),this.itemsElement=p;const y=a.contentsElement;y.classList.add(Kr("c")),this.element.appendChild(y),this.contentsElement=y}}class nl extends ui{constructor(r,a){const p=new Q(r,{blade:a.blade,viewProps:a.viewProps}),y=W(!0);super({blade:a.blade,rackController:p,view:new mu(r,{contentsElement:p.view.element,empty:y,viewProps:a.viewProps})});this.onPageAdd_=this.onPageAdd_.bind(this),this.onPageRemove_=this.onPageRemove_.bind(this),this.onPageSelectedChange_=this.onPageSelectedChange_.bind(this),this.pageSet_=new Ae(()=>null),this.pageSet_.emitter.on("add",this.onPageAdd_),this.pageSet_.emitter.on("remove",this.onPageRemove_),this.empty_=y,this.applyPages_()}get pageSet(){return this.pageSet_}add(r,a){this.pageSet_.add(r,a!=null?a:this.pageSet_.items.length)}remove(r){this.pageSet_.remove(this.pageSet_.items[r])}applyPages_(){this.keepSelection_(),this.empty_.rawValue=this.pageSet_.items.length===0}onPageAdd_(r){const a=r.item;Z(this.view.itemsElement,a.itemController.view.element,r.index),this.rackController.rack.add(a.contentController,r.index),a.props.value("selected").emitter.on("change",this.onPageSelectedChange_),this.applyPages_()}onPageRemove_(r){const a=r.item;rt(a.itemController.view.element),this.rackController.rack.remove(a.contentController),a.props.value("selected").emitter.off("change",this.onPageSelectedChange_),this.applyPages_()}keepSelection_(){if(this.pageSet_.items.length===0)return;const r=this.pageSet_.items.findIndex(a=>a.props.get("selected"));r<0?this.pageSet_.items.forEach((a,p)=>{a.props.set("selected",p===0)}):this.pageSet_.items.forEach((a,p)=>{a.props.set("selected",p===r)})}onPageSelectedChange_(r){if(r.rawValue){const a=this.pageSet_.items.findIndex(p=>p.props.value("selected")===r.sender);this.pageSet_.items.forEach((p,y)=>{p.props.set("selected",y===a)})}else this.keepSelection_()}}const il={id:"tab",type:"blade",accept(c){const r=vt,a=K(c,{pages:r.required.array(r.required.object({title:r.required.string})),view:r.required.constant("tab")});return!a||a.pages.length===0?null:{params:a}},controller(c){const r=new nl(c.document,{blade:c.blade,viewProps:c.viewProps});return c.params.pages.forEach(a=>{const p=new ne(c.document,{itemProps:B.fromObject({selected:!1,title:a.title}),props:B.fromObject({selected:!1})});r.add(p)}),r},api(c){return c.controller instanceof nl?new De(c.controller,c.pool):null}};function gu(c,r){const a=c.accept(r.params);if(!a)return null;const p=vt.optional.boolean(r.params.disabled).value,y=vt.optional.boolean(r.params.hidden).value;return c.controller({blade:gt(),document:r.document,params:d(Object.assign(Object.assign({},a.params),{disabled:p,hidden:y})),viewProps:ye.create({disabled:p,hidden:y})})}class vu{constructor(){this.disabled=!1,this.emitter=new M}dispose(){}tick(){this.disabled||this.emitter.emit("tick",{sender:this})}}class _u{constructor(r,a){this.disabled_=!1,this.timerId_=null,this.onTick_=this.onTick_.bind(this),this.doc_=r,this.emitter=new M,this.interval_=a,this.setTimer_()}get disabled(){return this.disabled_}set disabled(r){this.disabled_=r,this.disabled_?this.clearTimer_():this.setTimer_()}dispose(){this.clearTimer_()}clearTimer_(){if(this.timerId_===null)return;const r=this.doc_.defaultView;r&&r.clearInterval(this.timerId_),this.timerId_=null}setTimer_(){if(this.clearTimer_(),this.interval_<=0)return;const r=this.doc_.defaultView;r&&(this.timerId_=r.setInterval(this.onTick_,this.interval_))}onTick_(){this.disabled_||this.emitter.emit("tick",{sender:this})}}class Kn{constructor(r){this.constraints=r}constrain(r){return this.constraints.reduce((a,p)=>p.constrain(a),r)}}function sn(c,r){if(c instanceof r)return c;if(c instanceof Kn){const a=c.constraints.reduce((p,y)=>p||(y instanceof r?y:null),null);if(a)return a}return null}class lr{constructor(r){this.options=r}constrain(r){const a=this.options;return a.length===0||a.filter(y=>y.value===r).length>0?r:a[0].value}}class ze{constructor(r){this.maxValue=r.max,this.minValue=r.min}constrain(r){let a=r;return f(this.minValue)||(a=Math.max(a,this.minValue)),f(this.maxValue)||(a=Math.min(a,this.maxValue)),a}}class Jn{constructor(r){this.step=r}constrain(r){return(r<0?-Math.round(-r/this.step):Math.round(r/this.step))*this.step}}const lo=_("lst");class xu{constructor(r,a){this.onValueChange_=this.onValueChange_.bind(this),this.props_=a.props,this.element=r.createElement("div"),this.element.classList.add(lo()),a.viewProps.bindClassModifiers(this.element);const p=r.createElement("select");p.classList.add(lo("s")),N(this.props_,"options",I=>{it(p),I.forEach((V,ct)=>{const Dt=r.createElement("option");Dt.dataset.index=String(ct),Dt.textContent=V.text,Dt.value=String(V.value),p.appendChild(Dt)})}),a.viewProps.bindDisabled(p),this.element.appendChild(p),this.selectElement=p;const y=r.createElement("div");y.classList.add(lo("m")),y.appendChild(E(r,"dropdown")),this.element.appendChild(y),a.value.emitter.on("change",this.onValueChange_),this.value_=a.value,this.update_()}update_(){this.selectElement.value=String(this.value_.rawValue)}onValueChange_(){this.update_()}}class cr{constructor(r,a){this.onSelectChange_=this.onSelectChange_.bind(this),this.props=a.props,this.value=a.value,this.viewProps=a.viewProps,this.view=new xu(r,{props:this.props,value:this.value,viewProps:this.viewProps}),this.view.selectElement.addEventListener("change",this.onSelectChange_)}onSelectChange_(r){const p=d(r.currentTarget).selectedOptions.item(0);if(!p)return;const y=Number(p.dataset.index);this.value.rawValue=this.props.get("options")[y].value}}const rl=_("pop");class bu{constructor(r,a){this.element=r.createElement("div"),this.element.classList.add(rl()),a.viewProps.bindClassModifiers(this.element),P(a.shows,H(this.element,rl(void 0,"v")))}}class sl{constructor(r,a){this.shows=W(!1),this.viewProps=a.viewProps,this.view=new bu(r,{shows:this.shows,viewProps:this.viewProps})}}const ol=_("txt");class yu{constructor(r,a){this.onChange_=this.onChange_.bind(this),this.element=r.createElement("div"),this.element.classList.add(ol()),a.viewProps.bindClassModifiers(this.element),this.props_=a.props,this.props_.emitter.on("change",this.onChange_);const p=r.createElement("input");p.classList.add(ol("i")),p.type="text",a.viewProps.bindDisabled(p),this.element.appendChild(p),this.inputElement=p,a.value.emitter.on("change",this.onChange_),this.value_=a.value,this.refresh()}refresh(){const r=this.props_.get("formatter");this.inputElement.value=r(this.value_.rawValue)}onChange_(){this.refresh()}}class Jr{constructor(r,a){this.onInputChange_=this.onInputChange_.bind(this),this.parser_=a.parser,this.props=a.props,this.value=a.value,this.viewProps=a.viewProps,this.view=new yu(r,{props:a.props,value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_)}onInputChange_(r){const p=d(r.currentTarget).value,y=this.parser_(p);f(y)||(this.value.rawValue=y),this.view.refresh()}}function wu(c){return String(c)}function al(c){return c==="false"?!1:!!c}function ll(c){return wu(c)}class Mu{constructor(r){this.text=r}evaluate(){return Number(this.text)}toString(){return this.text}}const Su={"**":(c,r)=>Math.pow(c,r),"*":(c,r)=>c*r,"/":(c,r)=>c/r,"%":(c,r)=>c%r,"+":(c,r)=>c+r,"-":(c,r)=>c-r,"<<":(c,r)=>c<<r,">>":(c,r)=>c>>r,">>>":(c,r)=>c>>>r,"&":(c,r)=>c&r,"^":(c,r)=>c^r,"|":(c,r)=>c|r};class Eu{constructor(r,a,p){this.left=a,this.operator=r,this.right=p}evaluate(){const r=Su[this.operator];if(!r)throw new Error(`unexpected binary operator: '${this.operator}`);return r(this.left.evaluate(),this.right.evaluate())}toString(){return["b(",this.left.toString(),this.operator,this.right.toString(),")"].join(" ")}}const Tu={"+":c=>c,"-":c=>-c,"~":c=>~c};class Cu{constructor(r,a){this.operator=r,this.expression=a}evaluate(){const r=Tu[this.operator];if(!r)throw new Error(`unexpected unary operator: '${this.operator}`);return r(this.expression.evaluate())}toString(){return["u(",this.operator,this.expression.toString(),")"].join(" ")}}function co(c){return(r,a)=>{for(let p=0;p<c.length;p++){const y=c[p](r,a);if(y!=="")return y}return""}}function hr(c,r){var a;const p=c.substr(r).match(/^\s+/);return(a=p&&p[0])!==null&&a!==void 0?a:""}function Au(c,r){const a=c.substr(r,1);return a.match(/^[1-9]$/)?a:""}function ur(c,r){var a;const p=c.substr(r).match(/^[0-9]+/);return(a=p&&p[0])!==null&&a!==void 0?a:""}function Pu(c,r){const a=ur(c,r);if(a!=="")return a;const p=c.substr(r,1);if(r+=1,p!=="-"&&p!=="+")return"";const y=ur(c,r);return y===""?"":p+y}function ho(c,r){const a=c.substr(r,1);if(r+=1,a.toLowerCase()!=="e")return"";const p=Pu(c,r);return p===""?"":a+p}function cl(c,r){const a=c.substr(r,1);if(a==="0")return a;const p=Au(c,r);return r+=p.length,p===""?"":p+ur(c,r)}function Lu(c,r){const a=cl(c,r);if(r+=a.length,a==="")return"";const p=c.substr(r,1);if(r+=p.length,p!==".")return"";const y=ur(c,r);return r+=y.length,a+p+y+ho(c,r)}function Ru(c,r){const a=c.substr(r,1);if(r+=a.length,a!==".")return"";const p=ur(c,r);return r+=p.length,p===""?"":a+p+ho(c,r)}function Du(c,r){const a=cl(c,r);return r+=a.length,a===""?"":a+ho(c,r)}const Iu=co([Lu,Ru,Du]);function Nu(c,r){var a;const p=c.substr(r).match(/^[01]+/);return(a=p&&p[0])!==null&&a!==void 0?a:""}function ku(c,r){const a=c.substr(r,2);if(r+=a.length,a.toLowerCase()!=="0b")return"";const p=Nu(c,r);return p===""?"":a+p}function Fu(c,r){var a;const p=c.substr(r).match(/^[0-7]+/);return(a=p&&p[0])!==null&&a!==void 0?a:""}function Bu(c,r){const a=c.substr(r,2);if(r+=a.length,a.toLowerCase()!=="0o")return"";const p=Fu(c,r);return p===""?"":a+p}function Vu(c,r){var a;const p=c.substr(r).match(/^[0-9a-f]+/i);return(a=p&&p[0])!==null&&a!==void 0?a:""}function Ou(c,r){const a=c.substr(r,2);if(r+=a.length,a.toLowerCase()!=="0x")return"";const p=Vu(c,r);return p===""?"":a+p}const zu=co([ku,Bu,Ou]),Uu=co([zu,Iu]);function Hu(c,r){const a=Uu(c,r);return r+=a.length,a===""?null:{evaluable:new Mu(a),cursor:r}}function Gu(c,r){const a=c.substr(r,1);if(r+=a.length,a!=="(")return null;const p=ul(c,r);if(!p)return null;r=p.cursor,r+=hr(c,r).length;const y=c.substr(r,1);return r+=y.length,y!==")"?null:{evaluable:p.evaluable,cursor:r}}function Wu(c,r){return Hu(c,r)||Gu(c,r)}function hl(c,r){const a=Wu(c,r);if(a)return a;const p=c.substr(r,1);if(r+=p.length,p!=="+"&&p!=="-"&&p!=="~")return null;const y=hl(c,r);return y?(r=y.cursor,{cursor:r,evaluable:new Cu(p,y.evaluable)}):null}function qu(c,r,a){a+=hr(r,a).length;const p=c.filter(y=>r.startsWith(y,a))[0];return p?(a+=p.length,a+=hr(r,a).length,{cursor:a,operator:p}):null}function ju(c,r){return(a,p)=>{const y=c(a,p);if(!y)return null;p=y.cursor;let I=y.evaluable;for(;;){const V=qu(r,a,p);if(!V)break;p=V.cursor;const ct=c(a,p);if(!ct)return null;p=ct.cursor,I=new Eu(V.operator,I,ct.evaluable)}return I?{cursor:p,evaluable:I}:null}}const Xu=[["**"],["*","/","%"],["+","-"],["<<",">>>",">>"],["&"],["^"],["|"]].reduce((c,r)=>ju(c,r),hl);function ul(c,r){return r+=hr(c,r).length,Xu(c,r)}function Yu(c){const r=ul(c,0);return!r||r.cursor+hr(c,r.cursor).length!==c.length?null:r.evaluable}function pn(c){var r;const a=Yu(c);return(r=a==null?void 0:a.evaluate())!==null&&r!==void 0?r:null}function dl(c){if(typeof c=="number")return c;if(typeof c=="string"){const r=pn(c);if(!f(r))return r}return 0}function Zu(c){return String(c)}function Ie(c){return r=>r.toFixed(Math.max(Math.min(c,20),0))}const $u=Ie(0);function Qr(c){return $u(c)+"%"}function pl(c){return String(c)}function uo(c){return c}function fl(c,r){for(;c.length<r;)c.push(void 0)}function Ku(c){const r=[];return fl(r,c),W(r)}function Ju(c){const r=c.indexOf(void 0);return d(r<0?c:c.slice(0,r))}function Qu(c,r){const a=[...Ju(c),r];return a.length>c.length?a.splice(0,a.length-c.length):fl(a,c.length),a}function dr({primary:c,secondary:r,forward:a,backward:p}){let y=!1;function I(V){y||(y=!0,V(),y=!1)}c.emitter.on("change",V=>{I(()=>{r.setRawValue(a(c,r),V.options)})}),r.emitter.on("change",V=>{I(()=>{c.setRawValue(p(c,r),V.options)}),I(()=>{r.setRawValue(a(c,r),V.options)})}),I(()=>{r.setRawValue(a(c,r),{forceEmit:!1,last:!0})})}function Ne(c,r){const a=c*(r.altKey?.1:1)*(r.shiftKey?10:1);return r.upKey?+a:r.downKey?-a:0}function pr(c){return{altKey:c.altKey,downKey:c.key==="ArrowDown",shiftKey:c.shiftKey,upKey:c.key==="ArrowUp"}}function fn(c){return{altKey:c.altKey,downKey:c.key==="ArrowLeft",shiftKey:c.shiftKey,upKey:c.key==="ArrowRight"}}function td(c){return c==="ArrowUp"||c==="ArrowDown"}function ml(c){return td(c)||c==="ArrowLeft"||c==="ArrowRight"}function po(c,r){const a=r.ownerDocument.defaultView,p=r.getBoundingClientRect();return{x:c.pageX-((a&&a.scrollX||0)+p.left),y:c.pageY-((a&&a.scrollY||0)+p.top)}}class Qn{constructor(r){this.lastTouch_=null,this.onDocumentMouseMove_=this.onDocumentMouseMove_.bind(this),this.onDocumentMouseUp_=this.onDocumentMouseUp_.bind(this),this.onMouseDown_=this.onMouseDown_.bind(this),this.onTouchEnd_=this.onTouchEnd_.bind(this),this.onTouchMove_=this.onTouchMove_.bind(this),this.onTouchStart_=this.onTouchStart_.bind(this),this.elem_=r,this.emitter=new M,r.addEventListener("touchstart",this.onTouchStart_),r.addEventListener("touchmove",this.onTouchMove_),r.addEventListener("touchend",this.onTouchEnd_),r.addEventListener("mousedown",this.onMouseDown_)}computePosition_(r){const a=this.elem_.getBoundingClientRect();return{bounds:{width:a.width,height:a.height},point:r?{x:r.x,y:r.y}:null}}onMouseDown_(r){var a;r.preventDefault(),(a=r.currentTarget)===null||a===void 0||a.focus();const p=this.elem_.ownerDocument;p.addEventListener("mousemove",this.onDocumentMouseMove_),p.addEventListener("mouseup",this.onDocumentMouseUp_),this.emitter.emit("down",{altKey:r.altKey,data:this.computePosition_(po(r,this.elem_)),sender:this,shiftKey:r.shiftKey})}onDocumentMouseMove_(r){this.emitter.emit("move",{altKey:r.altKey,data:this.computePosition_(po(r,this.elem_)),sender:this,shiftKey:r.shiftKey})}onDocumentMouseUp_(r){const a=this.elem_.ownerDocument;a.removeEventListener("mousemove",this.onDocumentMouseMove_),a.removeEventListener("mouseup",this.onDocumentMouseUp_),this.emitter.emit("up",{altKey:r.altKey,data:this.computePosition_(po(r,this.elem_)),sender:this,shiftKey:r.shiftKey})}onTouchStart_(r){r.preventDefault();const a=r.targetTouches.item(0),p=this.elem_.getBoundingClientRect();this.emitter.emit("down",{altKey:r.altKey,data:this.computePosition_(a?{x:a.clientX-p.left,y:a.clientY-p.top}:void 0),sender:this,shiftKey:r.shiftKey}),this.lastTouch_=a}onTouchMove_(r){const a=r.targetTouches.item(0),p=this.elem_.getBoundingClientRect();this.emitter.emit("move",{altKey:r.altKey,data:this.computePosition_(a?{x:a.clientX-p.left,y:a.clientY-p.top}:void 0),sender:this,shiftKey:r.shiftKey}),this.lastTouch_=a}onTouchEnd_(r){var a;const p=(a=r.targetTouches.item(0))!==null&&a!==void 0?a:this.lastTouch_,y=this.elem_.getBoundingClientRect();this.emitter.emit("up",{altKey:r.altKey,data:this.computePosition_(p?{x:p.clientX-y.left,y:p.clientY-y.top}:void 0),sender:this,shiftKey:r.shiftKey})}}function se(c,r,a,p,y){const I=(c-r)/(a-r);return p+I*(y-p)}function gl(c){return String(c.toFixed(10)).split(".")[1].replace(/0+$/,"").length}function oe(c,r,a){return Math.min(Math.max(c,r),a)}function fo(c,r){return(c%r+r)%r}const We=_("txt");class ed{constructor(r,a){this.onChange_=this.onChange_.bind(this),this.props_=a.props,this.props_.emitter.on("change",this.onChange_),this.element=r.createElement("div"),this.element.classList.add(We(),We(void 0,"num")),a.arrayPosition&&this.element.classList.add(We(void 0,a.arrayPosition)),a.viewProps.bindClassModifiers(this.element);const p=r.createElement("input");p.classList.add(We("i")),p.type="text",a.viewProps.bindDisabled(p),this.element.appendChild(p),this.inputElement=p,this.onDraggingChange_=this.onDraggingChange_.bind(this),this.dragging_=a.dragging,this.dragging_.emitter.on("change",this.onDraggingChange_),this.element.classList.add(We()),this.inputElement.classList.add(We("i"));const y=r.createElement("div");y.classList.add(We("k")),this.element.appendChild(y),this.knobElement=y;const I=r.createElementNS(ut,"svg");I.classList.add(We("g")),this.knobElement.appendChild(I);const V=r.createElementNS(ut,"path");V.classList.add(We("gb")),I.appendChild(V),this.guideBodyElem_=V;const ct=r.createElementNS(ut,"path");ct.classList.add(We("gh")),I.appendChild(ct),this.guideHeadElem_=ct;const Dt=r.createElement("div");Dt.classList.add(_("tt")()),this.knobElement.appendChild(Dt),this.tooltipElem_=Dt,a.value.emitter.on("change",this.onChange_),this.value=a.value,this.refresh()}onDraggingChange_(r){if(r.rawValue===null){this.element.classList.remove(We(void 0,"drg"));return}this.element.classList.add(We(void 0,"drg"));const a=r.rawValue/this.props_.get("draggingScale"),p=a+(a>0?-1:a<0?1:0),y=oe(-p,-4,4);this.guideHeadElem_.setAttributeNS(null,"d",[`M ${p+y},0 L${p},4 L${p+y},8`,`M ${a},-1 L${a},9`].join(" ")),this.guideBodyElem_.setAttributeNS(null,"d",`M 0,4 L${a},4`);const I=this.props_.get("formatter");this.tooltipElem_.textContent=I(this.value.rawValue),this.tooltipElem_.style.left=`${a}px`}refresh(){const r=this.props_.get("formatter");this.inputElement.value=r(this.value.rawValue)}onChange_(){this.refresh()}}class fr{constructor(r,a){this.originRawValue_=0,this.onInputChange_=this.onInputChange_.bind(this),this.onInputKeyDown_=this.onInputKeyDown_.bind(this),this.onInputKeyUp_=this.onInputKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.baseStep_=a.baseStep,this.parser_=a.parser,this.props=a.props,this.value=a.value,this.viewProps=a.viewProps,this.dragging_=W(null),this.view=new ed(r,{arrayPosition:a.arrayPosition,dragging:this.dragging_,props:this.props,value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_),this.view.inputElement.addEventListener("keydown",this.onInputKeyDown_),this.view.inputElement.addEventListener("keyup",this.onInputKeyUp_);const p=new Qn(this.view.knobElement);p.emitter.on("down",this.onPointerDown_),p.emitter.on("move",this.onPointerMove_),p.emitter.on("up",this.onPointerUp_)}onInputChange_(r){const p=d(r.currentTarget).value,y=this.parser_(p);f(y)||(this.value.rawValue=y),this.view.refresh()}onInputKeyDown_(r){const a=Ne(this.baseStep_,pr(r));a!==0&&this.value.setRawValue(this.value.rawValue+a,{forceEmit:!1,last:!1})}onInputKeyUp_(r){Ne(this.baseStep_,pr(r))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}onPointerDown_(){this.originRawValue_=this.value.rawValue,this.dragging_.rawValue=0}computeDraggingValue_(r){if(!r.point)return null;const a=r.point.x-r.bounds.width/2;return this.originRawValue_+a*this.props.get("draggingScale")}onPointerMove_(r){const a=this.computeDraggingValue_(r.data);a!==null&&(this.value.setRawValue(a,{forceEmit:!1,last:!1}),this.dragging_.rawValue=this.value.rawValue-this.originRawValue_)}onPointerUp_(r){const a=this.computeDraggingValue_(r.data);a!==null&&(this.value.setRawValue(a,{forceEmit:!0,last:!0}),this.dragging_.rawValue=null)}}const mo=_("sld");class nd{constructor(r,a){this.onChange_=this.onChange_.bind(this),this.props_=a.props,this.props_.emitter.on("change",this.onChange_),this.element=r.createElement("div"),this.element.classList.add(mo()),a.viewProps.bindClassModifiers(this.element);const p=r.createElement("div");p.classList.add(mo("t")),a.viewProps.bindTabIndex(p),this.element.appendChild(p),this.trackElement=p;const y=r.createElement("div");y.classList.add(mo("k")),this.trackElement.appendChild(y),this.knobElement=y,a.value.emitter.on("change",this.onChange_),this.value=a.value,this.update_()}update_(){const r=oe(se(this.value.rawValue,this.props_.get("minValue"),this.props_.get("maxValue"),0,100),0,100);this.knobElement.style.width=`${r}%`}onChange_(){this.update_()}}class id{constructor(r,a){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDownOrMove_=this.onPointerDownOrMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.baseStep_=a.baseStep,this.value=a.value,this.viewProps=a.viewProps,this.props=a.props,this.view=new nd(r,{props:this.props,value:this.value,viewProps:this.viewProps}),this.ptHandler_=new Qn(this.view.trackElement),this.ptHandler_.emitter.on("down",this.onPointerDownOrMove_),this.ptHandler_.emitter.on("move",this.onPointerDownOrMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.trackElement.addEventListener("keydown",this.onKeyDown_),this.view.trackElement.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(r,a){!r.point||this.value.setRawValue(se(oe(r.point.x,0,r.bounds.width),0,r.bounds.width,this.props.get("minValue"),this.props.get("maxValue")),a)}onPointerDownOrMove_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerUp_(r){this.handlePointerEvent_(r.data,{forceEmit:!0,last:!0})}onKeyDown_(r){const a=Ne(this.baseStep_,fn(r));a!==0&&this.value.setRawValue(this.value.rawValue+a,{forceEmit:!1,last:!1})}onKeyUp_(r){Ne(this.baseStep_,fn(r))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const go=_("sldtxt");class rd{constructor(r,a){this.element=r.createElement("div"),this.element.classList.add(go());const p=r.createElement("div");p.classList.add(go("s")),this.sliderView_=a.sliderView,p.appendChild(this.sliderView_.element),this.element.appendChild(p);const y=r.createElement("div");y.classList.add(go("t")),this.textView_=a.textView,y.appendChild(this.textView_.element),this.element.appendChild(y)}}class vo{constructor(r,a){this.value=a.value,this.viewProps=a.viewProps,this.sliderC_=new id(r,{baseStep:a.baseStep,props:a.sliderProps,value:a.value,viewProps:this.viewProps}),this.textC_=new fr(r,{baseStep:a.baseStep,parser:a.parser,props:a.textProps,value:a.value,viewProps:a.viewProps}),this.view=new rd(r,{sliderView:this.sliderC_.view,textView:this.textC_.view})}get sliderController(){return this.sliderC_}get textController(){return this.textC_}}function mr(c,r){c.write(r)}function ts(c){const r=vt;if(Array.isArray(c))return r.required.array(r.required.object({text:r.required.string,value:r.required.raw}))(c).value;if(typeof c=="object")return r.required.raw(c).value}function vl(c){if(c==="inline"||c==="popup")return c}function wn(c){const r=vt;return r.required.object({max:r.optional.number,min:r.optional.number,step:r.optional.number})(c).value}function _l(c){if(Array.isArray(c))return c;const r=[];return Object.keys(c).forEach(a=>{r.push({text:a,value:c[a]})}),r}function _o(c){return f(c)?null:new lr(_l(d(c)))}function xo(c){const r=c?sn(c,lr):null;return r?r.options:null}function sd(c){const r=c?sn(c,Jn):null;return r?r.step:null}function es(c,r){const a=c&&sn(c,Jn);return a?gl(a.step):Math.max(gl(r),2)}function di(c){const r=sd(c);return r!=null?r:1}function pi(c,r){var a;const p=c&&sn(c,Jn),y=Math.abs((a=p==null?void 0:p.step)!==null&&a!==void 0?a:r);return y===0?.1:Math.pow(10,Math.floor(Math.log10(y))-1)}const ns=_("ckb");class od{constructor(r,a){this.onValueChange_=this.onValueChange_.bind(this),this.element=r.createElement("div"),this.element.classList.add(ns()),a.viewProps.bindClassModifiers(this.element);const p=r.createElement("label");p.classList.add(ns("l")),this.element.appendChild(p);const y=r.createElement("input");y.classList.add(ns("i")),y.type="checkbox",p.appendChild(y),this.inputElement=y,a.viewProps.bindDisabled(this.inputElement);const I=r.createElement("div");I.classList.add(ns("w")),p.appendChild(I);const V=E(r,"check");I.appendChild(V),a.value.emitter.on("change",this.onValueChange_),this.value=a.value,this.update_()}update_(){this.inputElement.checked=this.value.rawValue}onValueChange_(){this.update_()}}class ad{constructor(r,a){this.onInputChange_=this.onInputChange_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.view=new od(r,{value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_)}onInputChange_(r){const a=d(r.currentTarget);this.value.rawValue=a.checked}}function ld(c){const r=[],a=_o(c.options);return a&&r.push(a),new Kn(r)}const cd={id:"input-bool",type:"input",accept:(c,r)=>{if(typeof c!="boolean")return null;const p=K(r,{options:vt.optional.custom(ts)});return p?{initialValue:c,params:p}:null},binding:{reader:c=>al,constraint:c=>ld(c.params),writer:c=>mr},controller:c=>{var r;const a=c.document,p=c.value,y=c.constraint;return y&&sn(y,lr)?new cr(a,{props:B.fromObject({options:(r=xo(y))!==null&&r!==void 0?r:[]}),value:p,viewProps:c.viewProps}):new ad(a,{value:p,viewProps:c.viewProps})}},ti=_("col");class hd{constructor(r,a){this.element=r.createElement("div"),this.element.classList.add(ti()),a.foldable.bindExpandedClass(this.element,ti(void 0,"expanded")),N(a.foldable,"completed",H(this.element,ti(void 0,"cpl")));const p=r.createElement("div");p.classList.add(ti("h")),this.element.appendChild(p);const y=r.createElement("div");y.classList.add(ti("s")),p.appendChild(y),this.swatchElement=y;const I=r.createElement("div");if(I.classList.add(ti("t")),p.appendChild(I),this.textElement=I,a.pickerLayout==="inline"){const V=r.createElement("div");V.classList.add(ti("p")),this.element.appendChild(V),this.pickerElement=V}else this.pickerElement=null}}function ud(c,r,a){const p=oe(c/255,0,1),y=oe(r/255,0,1),I=oe(a/255,0,1),V=Math.max(p,y,I),ct=Math.min(p,y,I),Dt=V-ct;let Bt=0,Xt=0;const Yt=(ct+V)/2;return Dt!==0&&(Xt=Dt/(1-Math.abs(V+ct-1)),p===V?Bt=(y-I)/Dt:y===V?Bt=2+(I-p)/Dt:Bt=4+(p-y)/Dt,Bt=Bt/6+(Bt<0?1:0)),[Bt*360,Xt*100,Yt*100]}function dd(c,r,a){const p=(c%360+360)%360,y=oe(r/100,0,1),I=oe(a/100,0,1),V=(1-Math.abs(2*I-1))*y,ct=V*(1-Math.abs(p/60%2-1)),Dt=I-V/2;let Bt,Xt,Yt;return p>=0&&p<60?[Bt,Xt,Yt]=[V,ct,0]:p>=60&&p<120?[Bt,Xt,Yt]=[ct,V,0]:p>=120&&p<180?[Bt,Xt,Yt]=[0,V,ct]:p>=180&&p<240?[Bt,Xt,Yt]=[0,ct,V]:p>=240&&p<300?[Bt,Xt,Yt]=[ct,0,V]:[Bt,Xt,Yt]=[V,0,ct],[(Bt+Dt)*255,(Xt+Dt)*255,(Yt+Dt)*255]}function pd(c,r,a){const p=oe(c/255,0,1),y=oe(r/255,0,1),I=oe(a/255,0,1),V=Math.max(p,y,I),ct=Math.min(p,y,I),Dt=V-ct;let Bt;Dt===0?Bt=0:V===p?Bt=60*(((y-I)/Dt%6+6)%6):V===y?Bt=60*((I-p)/Dt+2):Bt=60*((p-y)/Dt+4);const Xt=V===0?0:Dt/V,Yt=V;return[Bt,Xt*100,Yt*100]}function xl(c,r,a){const p=fo(c,360),y=oe(r/100,0,1),I=oe(a/100,0,1),V=I*y,ct=V*(1-Math.abs(p/60%2-1)),Dt=I-V;let Bt,Xt,Yt;return p>=0&&p<60?[Bt,Xt,Yt]=[V,ct,0]:p>=60&&p<120?[Bt,Xt,Yt]=[ct,V,0]:p>=120&&p<180?[Bt,Xt,Yt]=[0,V,ct]:p>=180&&p<240?[Bt,Xt,Yt]=[0,ct,V]:p>=240&&p<300?[Bt,Xt,Yt]=[ct,0,V]:[Bt,Xt,Yt]=[V,0,ct],[(Bt+Dt)*255,(Xt+Dt)*255,(Yt+Dt)*255]}function fd(c,r,a){const p=a+r*(100-Math.abs(2*a-100))/(2*100);return[c,p!==0?r*(100-Math.abs(2*a-100))/p:0,a+r*(100-Math.abs(2*a-100))/(2*100)]}function md(c,r,a){const p=100-Math.abs(a*(200-r)/100-100);return[c,p!==0?r*a/p:0,a*(200-r)/(2*100)]}function fi(c){return[c[0],c[1],c[2]]}function bl(c,r){return[c[0],c[1],c[2],r]}const gd={hsl:{hsl:(c,r,a)=>[c,r,a],hsv:fd,rgb:dd},hsv:{hsl:md,hsv:(c,r,a)=>[c,r,a],rgb:xl},rgb:{hsl:ud,hsv:pd,rgb:(c,r,a)=>[c,r,a]}};function vd(c,r,a){return gd[r][a](...c)}const _d={hsl:c=>{var r;return[fo(c[0],360),oe(c[1],0,100),oe(c[2],0,100),oe((r=c[3])!==null&&r!==void 0?r:1,0,1)]},hsv:c=>{var r;return[fo(c[0],360),oe(c[1],0,100),oe(c[2],0,100),oe((r=c[3])!==null&&r!==void 0?r:1,0,1)]},rgb:c=>{var r;return[oe(c[0],0,255),oe(c[1],0,255),oe(c[2],0,255),oe((r=c[3])!==null&&r!==void 0?r:1,0,1)]}};function is(c,r){return typeof c!="object"||f(c)?!1:r in c&&typeof c[r]=="number"}class Wt{constructor(r,a){this.mode_=a,this.comps_=_d[a](r)}static black(){return new Wt([0,0,0],"rgb")}static fromObject(r){const a="a"in r?[r.r,r.g,r.b,r.a]:[r.r,r.g,r.b];return new Wt(a,"rgb")}static toRgbaObject(r){return r.toRgbaObject()}static isRgbColorObject(r){return is(r,"r")&&is(r,"g")&&is(r,"b")}static isRgbaColorObject(r){return this.isRgbColorObject(r)&&is(r,"a")}static isColorObject(r){return this.isRgbColorObject(r)}static equals(r,a){if(r.mode_!==a.mode_)return!1;const p=r.comps_,y=a.comps_;for(let I=0;I<p.length;I++)if(p[I]!==y[I])return!1;return!0}get mode(){return this.mode_}getComponents(r){return bl(vd(fi(this.comps_),this.mode_,r||this.mode_),this.comps_[3])}toRgbaObject(){const r=this.getComponents("rgb");return{r:r[0],g:r[1],b:r[2],a:r[3]}}}const Mn=_("colp");class xd{constructor(r,a){this.alphaViews_=null,this.element=r.createElement("div"),this.element.classList.add(Mn());const p=r.createElement("div");p.classList.add(Mn("hsv"));const y=r.createElement("div");y.classList.add(Mn("sv")),this.svPaletteView_=a.svPaletteView,y.appendChild(this.svPaletteView_.element),p.appendChild(y);const I=r.createElement("div");I.classList.add(Mn("h")),this.hPaletteView_=a.hPaletteView,I.appendChild(this.hPaletteView_.element),p.appendChild(I),this.element.appendChild(p);const V=r.createElement("div");if(V.classList.add(Mn("rgb")),this.textView_=a.textView,V.appendChild(this.textView_.element),this.element.appendChild(V),a.alphaViews){this.alphaViews_={palette:a.alphaViews.palette,text:a.alphaViews.text};const ct=r.createElement("div");ct.classList.add(Mn("a"));const Dt=r.createElement("div");Dt.classList.add(Mn("ap")),Dt.appendChild(this.alphaViews_.palette.element),ct.appendChild(Dt);const Bt=r.createElement("div");Bt.classList.add(Mn("at")),Bt.appendChild(this.alphaViews_.text.element),ct.appendChild(Bt),this.element.appendChild(ct)}}get allFocusableElements(){const r=[this.svPaletteView_.element,this.hPaletteView_.element,this.textView_.modeSelectElement,...this.textView_.textViews.map(a=>a.inputElement)];return this.alphaViews_&&r.push(this.alphaViews_.palette.element,this.alphaViews_.text.inputElement),r}}function bo(c){const r=vt;return K(c,{alpha:r.optional.boolean,expanded:r.optional.boolean,picker:r.optional.custom(vl)})}function ei(c){return c?.1:1}function qe(c,r){const a=c.match(/^(.+)%$/);return Math.min(a?parseFloat(a[1])*.01*r:parseFloat(c),r)}const bd={deg:c=>c,grad:c=>c*360/400,rad:c=>c*360/(2*Math.PI),turn:c=>c*360};function yl(c){const r=c.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);if(!r)return parseFloat(c);const a=parseFloat(r[1]),p=r[2];return bd[p](a)}const yo={"func.rgb":c=>{const r=c.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!r)return null;const a=[qe(r[1],255),qe(r[2],255),qe(r[3],255)];return isNaN(a[0])||isNaN(a[1])||isNaN(a[2])?null:new Wt(a,"rgb")},"func.rgba":c=>{const r=c.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!r)return null;const a=[qe(r[1],255),qe(r[2],255),qe(r[3],255),qe(r[4],1)];return isNaN(a[0])||isNaN(a[1])||isNaN(a[2])||isNaN(a[3])?null:new Wt(a,"rgb")},"func.hsl":c=>{const r=c.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!r)return null;const a=[yl(r[1]),qe(r[2],100),qe(r[3],100)];return isNaN(a[0])||isNaN(a[1])||isNaN(a[2])?null:new Wt(a,"hsl")},"func.hsla":c=>{const r=c.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!r)return null;const a=[yl(r[1]),qe(r[2],100),qe(r[3],100),qe(r[4],1)];return isNaN(a[0])||isNaN(a[1])||isNaN(a[2])||isNaN(a[3])?null:new Wt(a,"hsl")},"hex.rgb":c=>{const r=c.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);if(r)return new Wt([parseInt(r[1]+r[1],16),parseInt(r[2]+r[2],16),parseInt(r[3]+r[3],16)],"rgb");const a=c.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);return a?new Wt([parseInt(a[1],16),parseInt(a[2],16),parseInt(a[3],16)],"rgb"):null},"hex.rgba":c=>{const r=c.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);if(r)return new Wt([parseInt(r[1]+r[1],16),parseInt(r[2]+r[2],16),parseInt(r[3]+r[3],16),se(parseInt(r[4]+r[4],16),0,255,0,1)],"rgb");const a=c.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);return a?new Wt([parseInt(a[1],16),parseInt(a[2],16),parseInt(a[3],16),se(parseInt(a[4],16),0,255,0,1)],"rgb"):null}};function rs(c){return Object.keys(yo).reduce((a,p)=>a||(yo[p](c)?p:null),null)}const ss=c=>{const r=rs(c);return r?yo[r](c):null};function yd(c){return c==="func.hsla"||c==="func.rgba"||c==="hex.rgba"}function wd(c){if(typeof c=="string"){const r=ss(c);if(r)return r}return Wt.black()}function wl(c){const r=oe(Math.floor(c),0,255).toString(16);return r.length===1?`0${r}`:r}function wo(c,r="#"){const a=fi(c.getComponents("rgb")).map(wl).join("");return`${r}${a}`}function os(c,r="#"){const a=c.getComponents("rgb"),p=[a[0],a[1],a[2],a[3]*255].map(wl).join("");return`${r}${p}`}function Ml(c){const r=Ie(0);return`rgb(${fi(c.getComponents("rgb")).map(p=>r(p)).join(", ")})`}function as(c){const r=Ie(2),a=Ie(0);return`rgba(${c.getComponents("rgb").map((y,I)=>(I===3?r:a)(y)).join(", ")})`}function Md(c){const r=[Ie(0),Qr,Qr];return`hsl(${fi(c.getComponents("hsl")).map((p,y)=>r[y](p)).join(", ")})`}function Sd(c){const r=[Ie(0),Qr,Qr,Ie(2)];return`hsla(${c.getComponents("hsl").map((p,y)=>r[y](p)).join(", ")})`}const Ed={"func.hsl":Md,"func.hsla":Sd,"func.rgb":Ml,"func.rgba":as,"hex.rgb":wo,"hex.rgba":os};function Sl(c){return Ed[c]}const gr=_("apl");class Td{constructor(r,a){this.onValueChange_=this.onValueChange_.bind(this),this.value=a.value,this.value.emitter.on("change",this.onValueChange_),this.element=r.createElement("div"),this.element.classList.add(gr()),a.viewProps.bindTabIndex(this.element);const p=r.createElement("div");p.classList.add(gr("b")),this.element.appendChild(p);const y=r.createElement("div");y.classList.add(gr("c")),p.appendChild(y),this.colorElem_=y;const I=r.createElement("div");I.classList.add(gr("m")),this.element.appendChild(I),this.markerElem_=I;const V=r.createElement("div");V.classList.add(gr("p")),this.markerElem_.appendChild(V),this.previewElem_=V,this.update_()}update_(){const r=this.value.rawValue,a=r.getComponents("rgb"),p=new Wt([a[0],a[1],a[2],0],"rgb"),y=new Wt([a[0],a[1],a[2],255],"rgb"),I=["to right",as(p),as(y)];this.colorElem_.style.background=`linear-gradient(${I.join(",")})`,this.previewElem_.style.backgroundColor=as(r);const V=se(a[3],0,1,0,100);this.markerElem_.style.left=`${V}%`}onValueChange_(){this.update_()}}class Cd{constructor(r,a){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.view=new Td(r,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new Qn(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(r,a){if(!r.point)return;const p=r.point.x/r.bounds.width,y=this.value.rawValue,[I,V,ct]=y.getComponents("hsv");this.value.setRawValue(new Wt([I,V,ct,p],"hsv"),a)}onPointerDown_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerMove_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerUp_(r){this.handlePointerEvent_(r.data,{forceEmit:!0,last:!0})}onKeyDown_(r){const a=Ne(ei(!0),fn(r));if(a===0)return;const p=this.value.rawValue,[y,I,V,ct]=p.getComponents("hsv");this.value.setRawValue(new Wt([y,I,V,ct+a],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(r){Ne(ei(!0),fn(r))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const mi=_("coltxt");function Ad(c){const r=c.createElement("select"),a=[{text:"RGB",value:"rgb"},{text:"HSL",value:"hsl"},{text:"HSV",value:"hsv"}];return r.appendChild(a.reduce((p,y)=>{const I=c.createElement("option");return I.textContent=y.text,I.value=y.value,p.appendChild(I),p},c.createDocumentFragment())),r}class Pd{constructor(r,a){this.element=r.createElement("div"),this.element.classList.add(mi());const p=r.createElement("div");p.classList.add(mi("m")),this.modeElem_=Ad(r),this.modeElem_.classList.add(mi("ms")),p.appendChild(this.modeSelectElement);const y=r.createElement("div");y.classList.add(mi("mm")),y.appendChild(E(r,"dropdown")),p.appendChild(y),this.element.appendChild(p);const I=r.createElement("div");I.classList.add(mi("w")),this.element.appendChild(I),this.textsElem_=I,this.textViews_=a.textViews,this.applyTextViews_(),P(a.colorMode,V=>{this.modeElem_.value=V})}get modeSelectElement(){return this.modeElem_}get textViews(){return this.textViews_}set textViews(r){this.textViews_=r,this.applyTextViews_()}applyTextViews_(){it(this.textsElem_);const r=this.element.ownerDocument;this.textViews_.forEach(a=>{const p=r.createElement("div");p.classList.add(mi("c")),p.appendChild(a.element),this.textsElem_.appendChild(p)})}}const Ld=Ie(0),Rd={rgb:()=>new ze({min:0,max:255}),hsl:c=>c===0?new ze({min:0,max:360}):new ze({min:0,max:100}),hsv:c=>c===0?new ze({min:0,max:360}):new ze({min:0,max:100})};function Mo(c,r,a){return new fr(c,{arrayPosition:a===0?"fst":a===3-1?"lst":"mid",baseStep:ei(!1),parser:r.parser,props:B.fromObject({draggingScale:1,formatter:Ld}),value:W(0,{constraint:Rd[r.colorMode](a)}),viewProps:r.viewProps})}class Dd{constructor(r,a){this.onModeSelectChange_=this.onModeSelectChange_.bind(this),this.parser_=a.parser,this.value=a.value,this.viewProps=a.viewProps,this.colorMode=W(this.value.rawValue.mode),this.ccs_=this.createComponentControllers_(r),this.view=new Pd(r,{colorMode:this.colorMode,textViews:[this.ccs_[0].view,this.ccs_[1].view,this.ccs_[2].view]}),this.view.modeSelectElement.addEventListener("change",this.onModeSelectChange_)}createComponentControllers_(r){const a={colorMode:this.colorMode.rawValue,parser:this.parser_,viewProps:this.viewProps},p=[Mo(r,a,0),Mo(r,a,1),Mo(r,a,2)];return p.forEach((y,I)=>{dr({primary:this.value,secondary:y.value,forward:V=>V.rawValue.getComponents(this.colorMode.rawValue)[I],backward:(V,ct)=>{const Dt=this.colorMode.rawValue,Bt=V.rawValue.getComponents(Dt);return Bt[I]=ct.rawValue,new Wt(bl(fi(Bt),Bt[3]),Dt)}})}),p}onModeSelectChange_(r){const a=r.currentTarget;this.colorMode.rawValue=a.value,this.ccs_=this.createComponentControllers_(this.view.element.ownerDocument),this.view.textViews=[this.ccs_[0].view,this.ccs_[1].view,this.ccs_[2].view]}}const So=_("hpl");class Id{constructor(r,a){this.onValueChange_=this.onValueChange_.bind(this),this.value=a.value,this.value.emitter.on("change",this.onValueChange_),this.element=r.createElement("div"),this.element.classList.add(So()),a.viewProps.bindTabIndex(this.element);const p=r.createElement("div");p.classList.add(So("c")),this.element.appendChild(p);const y=r.createElement("div");y.classList.add(So("m")),this.element.appendChild(y),this.markerElem_=y,this.update_()}update_(){const r=this.value.rawValue,[a]=r.getComponents("hsv");this.markerElem_.style.backgroundColor=Ml(new Wt([a,100,100],"hsv"));const p=se(a,0,360,0,100);this.markerElem_.style.left=`${p}%`}onValueChange_(){this.update_()}}class Nd{constructor(r,a){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.view=new Id(r,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new Qn(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(r,a){if(!r.point)return;const p=se(r.point.x,0,r.bounds.width,0,360),y=this.value.rawValue,[,I,V,ct]=y.getComponents("hsv");this.value.setRawValue(new Wt([p,I,V,ct],"hsv"),a)}onPointerDown_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerMove_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerUp_(r){this.handlePointerEvent_(r.data,{forceEmit:!0,last:!0})}onKeyDown_(r){const a=Ne(ei(!1),fn(r));if(a===0)return;const p=this.value.rawValue,[y,I,V,ct]=p.getComponents("hsv");this.value.setRawValue(new Wt([y+a,I,V,ct],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(r){Ne(ei(!1),fn(r))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const Eo=_("svp"),El=64;class kd{constructor(r,a){this.onValueChange_=this.onValueChange_.bind(this),this.value=a.value,this.value.emitter.on("change",this.onValueChange_),this.element=r.createElement("div"),this.element.classList.add(Eo()),a.viewProps.bindTabIndex(this.element);const p=r.createElement("canvas");p.height=El,p.width=El,p.classList.add(Eo("c")),this.element.appendChild(p),this.canvasElement=p;const y=r.createElement("div");y.classList.add(Eo("m")),this.element.appendChild(y),this.markerElem_=y,this.update_()}update_(){const r=dt(this.canvasElement);if(!r)return;const p=this.value.rawValue.getComponents("hsv"),y=this.canvasElement.width,I=this.canvasElement.height,V=r.getImageData(0,0,y,I),ct=V.data;for(let Xt=0;Xt<I;Xt++)for(let Yt=0;Yt<y;Yt++){const ni=se(Yt,0,y,0,100),_r=se(Xt,0,I,100,0),xr=xl(p[0],ni,_r),xi=(Xt*y+Yt)*4;ct[xi]=xr[0],ct[xi+1]=xr[1],ct[xi+2]=xr[2],ct[xi+3]=255}r.putImageData(V,0,0);const Dt=se(p[1],0,100,0,100);this.markerElem_.style.left=`${Dt}%`;const Bt=se(p[2],0,100,100,0);this.markerElem_.style.top=`${Bt}%`}onValueChange_(){this.update_()}}class Fd{constructor(r,a){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.view=new kd(r,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new Qn(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(r,a){if(!r.point)return;const p=se(r.point.x,0,r.bounds.width,0,100),y=se(r.point.y,0,r.bounds.height,100,0),[I,,,V]=this.value.rawValue.getComponents("hsv");this.value.setRawValue(new Wt([I,p,y,V],"hsv"),a)}onPointerDown_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerMove_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerUp_(r){this.handlePointerEvent_(r.data,{forceEmit:!0,last:!0})}onKeyDown_(r){ml(r.key)&&r.preventDefault();const[a,p,y,I]=this.value.rawValue.getComponents("hsv"),V=ei(!1),ct=Ne(V,fn(r)),Dt=Ne(V,pr(r));ct===0&&Dt===0||this.value.setRawValue(new Wt([a,p+ct,y+Dt,I],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(r){const a=ei(!1),p=Ne(a,fn(r)),y=Ne(a,pr(r));p===0&&y===0||this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}class Bd{constructor(r,a){this.value=a.value,this.viewProps=a.viewProps,this.hPaletteC_=new Nd(r,{value:this.value,viewProps:this.viewProps}),this.svPaletteC_=new Fd(r,{value:this.value,viewProps:this.viewProps}),this.alphaIcs_=a.supportsAlpha?{palette:new Cd(r,{value:this.value,viewProps:this.viewProps}),text:new fr(r,{parser:pn,baseStep:.1,props:B.fromObject({draggingScale:.01,formatter:Ie(2)}),value:W(0,{constraint:new ze({min:0,max:1})}),viewProps:this.viewProps})}:null,this.alphaIcs_&&dr({primary:this.value,secondary:this.alphaIcs_.text.value,forward:p=>p.rawValue.getComponents()[3],backward:(p,y)=>{const I=p.rawValue.getComponents();return I[3]=y.rawValue,new Wt(I,p.rawValue.mode)}}),this.textC_=new Dd(r,{parser:pn,value:this.value,viewProps:this.viewProps}),this.view=new xd(r,{alphaViews:this.alphaIcs_?{palette:this.alphaIcs_.palette.view,text:this.alphaIcs_.text.view}:null,hPaletteView:this.hPaletteC_.view,supportsAlpha:a.supportsAlpha,svPaletteView:this.svPaletteC_.view,textView:this.textC_.view})}get textController(){return this.textC_}}const To=_("colsw");class Vd{constructor(r,a){this.onValueChange_=this.onValueChange_.bind(this),a.value.emitter.on("change",this.onValueChange_),this.value=a.value,this.element=r.createElement("div"),this.element.classList.add(To()),a.viewProps.bindClassModifiers(this.element);const p=r.createElement("div");p.classList.add(To("sw")),this.element.appendChild(p),this.swatchElem_=p;const y=r.createElement("button");y.classList.add(To("b")),a.viewProps.bindDisabled(y),this.element.appendChild(y),this.buttonElement=y,this.update_()}update_(){const r=this.value.rawValue;this.swatchElem_.style.backgroundColor=os(r)}onValueChange_(){this.update_()}}class Od{constructor(r,a){this.value=a.value,this.viewProps=a.viewProps,this.view=new Vd(r,{value:this.value,viewProps:this.viewProps})}}class Co{constructor(r,a){this.onButtonBlur_=this.onButtonBlur_.bind(this),this.onButtonClick_=this.onButtonClick_.bind(this),this.onPopupChildBlur_=this.onPopupChildBlur_.bind(this),this.onPopupChildKeydown_=this.onPopupChildKeydown_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.foldable_=D.create(a.expanded),this.swatchC_=new Od(r,{value:this.value,viewProps:this.viewProps});const p=this.swatchC_.view.buttonElement;p.addEventListener("blur",this.onButtonBlur_),p.addEventListener("click",this.onButtonClick_),this.textC_=new Jr(r,{parser:a.parser,props:B.fromObject({formatter:a.formatter}),value:this.value,viewProps:this.viewProps}),this.view=new hd(r,{foldable:this.foldable_,pickerLayout:a.pickerLayout}),this.view.swatchElement.appendChild(this.swatchC_.view.element),this.view.textElement.appendChild(this.textC_.view.element),this.popC_=a.pickerLayout==="popup"?new sl(r,{viewProps:this.viewProps}):null;const y=new Bd(r,{supportsAlpha:a.supportsAlpha,value:this.value,viewProps:this.viewProps});y.view.allFocusableElements.forEach(I=>{I.addEventListener("blur",this.onPopupChildBlur_),I.addEventListener("keydown",this.onPopupChildKeydown_)}),this.pickerC_=y,this.popC_?(this.view.element.appendChild(this.popC_.view.element),this.popC_.view.element.appendChild(y.view.element),dr({primary:this.foldable_.value("expanded"),secondary:this.popC_.shows,forward:I=>I.rawValue,backward:(I,V)=>V.rawValue})):this.view.pickerElement&&(this.view.pickerElement.appendChild(this.pickerC_.view.element),zt(this.foldable_,this.view.pickerElement))}get textController(){return this.textC_}onButtonBlur_(r){if(!this.popC_)return;const a=this.view.element,p=d(r.relatedTarget);(!p||!a.contains(p))&&(this.popC_.shows.rawValue=!1)}onButtonClick_(){this.foldable_.set("expanded",!this.foldable_.get("expanded")),this.foldable_.get("expanded")&&this.pickerC_.view.allFocusableElements[0].focus()}onPopupChildBlur_(r){if(!this.popC_)return;const a=this.popC_.view.element,p=Lt(r);p&&a.contains(p)||p&&p===this.swatchC_.view.buttonElement&&!$(a.ownerDocument)||(this.popC_.shows.rawValue=!1)}onPopupChildKeydown_(r){this.popC_?r.key==="Escape"&&(this.popC_.shows.rawValue=!1):this.view.pickerElement&&r.key==="Escape"&&this.swatchC_.view.buttonElement.focus()}}function zd(c){return Wt.isColorObject(c)?Wt.fromObject(c):Wt.black()}function Ud(c){return fi(c.getComponents("rgb")).reduce((r,a)=>r<<8|Math.floor(a)&255,0)}function Hd(c){return c.getComponents("rgb").reduce((r,a,p)=>{const y=Math.floor(p===3?a*255:a)&255;return r<<8|y},0)>>>0}function Gd(c){return new Wt([c>>16&255,c>>8&255,c&255],"rgb")}function Wd(c){return new Wt([c>>24&255,c>>16&255,c>>8&255,se(c&255,0,255,0,1)],"rgb")}function qd(c){return typeof c!="number"?Wt.black():Gd(c)}function jd(c){return typeof c!="number"?Wt.black():Wd(c)}function Xd(c){const r=Sl(c);return(a,p)=>{mr(a,r(p))}}function Yd(c){const r=c?Hd:Ud;return(a,p)=>{mr(a,r(p))}}function Zd(c,r){const a=r.toRgbaObject();c.writeProperty("r",a.r),c.writeProperty("g",a.g),c.writeProperty("b",a.b),c.writeProperty("a",a.a)}function $d(c,r){const a=r.toRgbaObject();c.writeProperty("r",a.r),c.writeProperty("g",a.g),c.writeProperty("b",a.b)}function Kd(c){return c?Zd:$d}function Ao(c){return"alpha"in c&&c.alpha===!0}function Jd(c){return c?r=>os(r,"0x"):r=>wo(r,"0x")}const Qd={id:"input-color-number",type:"input",accept:(c,r)=>{if(typeof c!="number"||!("view"in r)||r.view!=="color")return null;const a=bo(r);return a?{initialValue:c,params:a}:null},binding:{reader:c=>Ao(c.params)?jd:qd,equals:Wt.equals,writer:c=>Yd(Ao(c.params))},controller:c=>{const r=Ao(c.params),a="expanded"in c.params?c.params.expanded:void 0,p="picker"in c.params?c.params.picker:void 0;return new Co(c.document,{expanded:a!=null?a:!1,formatter:Jd(r),parser:ss,pickerLayout:p!=null?p:"popup",supportsAlpha:r,value:c.value,viewProps:c.viewProps})}};function tp(c){return Wt.isRgbaColorObject(c)}const ep={id:"input-color-object",type:"input",accept:(c,r)=>{if(!Wt.isColorObject(c))return null;const a=bo(r);return a?{initialValue:c,params:a}:null},binding:{reader:c=>zd,equals:Wt.equals,writer:c=>Kd(tp(c.initialValue))},controller:c=>{const r=Wt.isRgbaColorObject(c.initialValue),a="expanded"in c.params?c.params.expanded:void 0,p="picker"in c.params?c.params.picker:void 0,y=r?os:wo;return new Co(c.document,{expanded:a!=null?a:!1,formatter:y,parser:ss,pickerLayout:p!=null?p:"popup",supportsAlpha:r,value:c.value,viewProps:c.viewProps})}},np={id:"input-color-string",type:"input",accept:(c,r)=>{if(typeof c!="string"||"view"in r&&r.view==="text"||!rs(c))return null;const p=bo(r);return p?{initialValue:c,params:p}:null},binding:{reader:c=>wd,equals:Wt.equals,writer:c=>{const r=rs(c.initialValue);if(!r)throw v.shouldNeverHappen();return Xd(r)}},controller:c=>{const r=rs(c.initialValue);if(!r)throw v.shouldNeverHappen();const a=Sl(r),p="expanded"in c.params?c.params.expanded:void 0,y="picker"in c.params?c.params.picker:void 0;return new Co(c.document,{expanded:p!=null?p:!1,formatter:a,parser:ss,pickerLayout:y!=null?y:"popup",supportsAlpha:yd(r),value:c.value,viewProps:c.viewProps})}};class Sn{constructor(r){this.components=r.components,this.asm_=r.assembly}constrain(r){const a=this.asm_.toComponents(r).map((p,y)=>{var I,V;return(V=(I=this.components[y])===null||I===void 0?void 0:I.constrain(p))!==null&&V!==void 0?V:p});return this.asm_.fromComponents(a)}}const Tl=_("pndtxt");class ip{constructor(r,a){this.textViews=a.textViews,this.element=r.createElement("div"),this.element.classList.add(Tl()),this.textViews.forEach(p=>{const y=r.createElement("div");y.classList.add(Tl("a")),y.appendChild(p.element),this.element.appendChild(y)})}}function rp(c,r,a){return new fr(c,{arrayPosition:a===0?"fst":a===r.axes.length-1?"lst":"mid",baseStep:r.axes[a].baseStep,parser:r.parser,props:r.axes[a].textProps,value:W(0,{constraint:r.axes[a].constraint}),viewProps:r.viewProps})}class Po{constructor(r,a){this.value=a.value,this.viewProps=a.viewProps,this.acs_=a.axes.map((p,y)=>rp(r,a,y)),this.acs_.forEach((p,y)=>{dr({primary:this.value,secondary:p.value,forward:I=>a.assembly.toComponents(I.rawValue)[y],backward:(I,V)=>{const ct=a.assembly.toComponents(I.rawValue);return ct[y]=V.rawValue,a.assembly.fromComponents(ct)}})}),this.view=new ip(r,{textViews:this.acs_.map(p=>p.view)})}}function sp(c){return"step"in c&&!f(c.step)?new Jn(c.step):null}function op(c){return"max"in c&&!f(c.max)||"min"in c&&!f(c.min)?new ze({max:c.max,min:c.min}):null}function ap(c){const r=[],a=sp(c);a&&r.push(a);const p=op(c);p&&r.push(p);const y=_o(c.options);return y&&r.push(y),new Kn(r)}function lp(c){const r=c?sn(c,ze):null;return r?[r.minValue,r.maxValue]:[void 0,void 0]}function cp(c){const[r,a]=lp(c);return[r!=null?r:0,a!=null?a:100]}const hp={id:"input-number",type:"input",accept:(c,r)=>{if(typeof c!="number")return null;const a=vt,p=K(r,{format:a.optional.function,max:a.optional.number,min:a.optional.number,options:a.optional.custom(ts),step:a.optional.number});return p?{initialValue:c,params:p}:null},binding:{reader:c=>dl,constraint:c=>ap(c.params),writer:c=>mr},controller:c=>{var r,a;const p=c.value,y=c.constraint;if(y&&sn(y,lr))return new cr(c.document,{props:B.fromObject({options:(r=xo(y))!==null&&r!==void 0?r:[]}),value:p,viewProps:c.viewProps});const I=(a="format"in c.params?c.params.format:void 0)!==null&&a!==void 0?a:Ie(es(y,p.rawValue));if(y&&sn(y,ze)){const[V,ct]=cp(y);return new vo(c.document,{baseStep:di(y),parser:pn,sliderProps:B.fromObject({maxValue:ct,minValue:V}),textProps:B.fromObject({draggingScale:pi(y,p.rawValue),formatter:I}),value:p,viewProps:c.viewProps})}return new fr(c.document,{baseStep:di(y),parser:pn,props:B.fromObject({draggingScale:pi(y,p.rawValue),formatter:I}),value:p,viewProps:c.viewProps})}};class En{constructor(r=0,a=0){this.x=r,this.y=a}getComponents(){return[this.x,this.y]}static isObject(r){if(f(r))return!1;const a=r.x,p=r.y;return!(typeof a!="number"||typeof p!="number")}static equals(r,a){return r.x===a.x&&r.y===a.y}toObject(){return{x:this.x,y:this.y}}}const Cl={toComponents:c=>c.getComponents(),fromComponents:c=>new En(...c)},gi=_("p2d");class up{constructor(r,a){this.element=r.createElement("div"),this.element.classList.add(gi()),a.viewProps.bindClassModifiers(this.element),P(a.expanded,H(this.element,gi(void 0,"expanded")));const p=r.createElement("div");p.classList.add(gi("h")),this.element.appendChild(p);const y=r.createElement("button");y.classList.add(gi("b")),y.appendChild(E(r,"p2dpad")),a.viewProps.bindDisabled(y),p.appendChild(y),this.buttonElement=y;const I=r.createElement("div");if(I.classList.add(gi("t")),p.appendChild(I),this.textElement=I,a.pickerLayout==="inline"){const V=r.createElement("div");V.classList.add(gi("p")),this.element.appendChild(V),this.pickerElement=V}else this.pickerElement=null}}const Tn=_("p2dp");class dp{constructor(r,a){this.onFoldableChange_=this.onFoldableChange_.bind(this),this.onValueChange_=this.onValueChange_.bind(this),this.invertsY_=a.invertsY,this.maxValue_=a.maxValue,this.element=r.createElement("div"),this.element.classList.add(Tn()),a.layout==="popup"&&this.element.classList.add(Tn(void 0,"p"));const p=r.createElement("div");p.classList.add(Tn("p")),a.viewProps.bindTabIndex(p),this.element.appendChild(p),this.padElement=p;const y=r.createElementNS(ut,"svg");y.classList.add(Tn("g")),this.padElement.appendChild(y),this.svgElem_=y;const I=r.createElementNS(ut,"line");I.classList.add(Tn("ax")),I.setAttributeNS(null,"x1","0"),I.setAttributeNS(null,"y1","50%"),I.setAttributeNS(null,"x2","100%"),I.setAttributeNS(null,"y2","50%"),this.svgElem_.appendChild(I);const V=r.createElementNS(ut,"line");V.classList.add(Tn("ax")),V.setAttributeNS(null,"x1","50%"),V.setAttributeNS(null,"y1","0"),V.setAttributeNS(null,"x2","50%"),V.setAttributeNS(null,"y2","100%"),this.svgElem_.appendChild(V);const ct=r.createElementNS(ut,"line");ct.classList.add(Tn("l")),ct.setAttributeNS(null,"x1","50%"),ct.setAttributeNS(null,"y1","50%"),this.svgElem_.appendChild(ct),this.lineElem_=ct;const Dt=r.createElement("div");Dt.classList.add(Tn("m")),this.padElement.appendChild(Dt),this.markerElem_=Dt,a.value.emitter.on("change",this.onValueChange_),this.value=a.value,this.update_()}get allFocusableElements(){return[this.padElement]}update_(){const[r,a]=this.value.rawValue.getComponents(),p=this.maxValue_,y=se(r,-p,+p,0,100),I=se(a,-p,+p,0,100),V=this.invertsY_?100-I:I;this.lineElem_.setAttributeNS(null,"x2",`${y}%`),this.lineElem_.setAttributeNS(null,"y2",`${V}%`),this.markerElem_.style.left=`${y}%`,this.markerElem_.style.top=`${V}%`}onValueChange_(){this.update_()}onFoldableChange_(){this.update_()}}function Al(c,r,a){return[Ne(r[0],fn(c)),Ne(r[1],pr(c))*(a?1:-1)]}class pp{constructor(r,a){this.onPadKeyDown_=this.onPadKeyDown_.bind(this),this.onPadKeyUp_=this.onPadKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.baseSteps_=a.baseSteps,this.maxValue_=a.maxValue,this.invertsY_=a.invertsY,this.view=new dp(r,{invertsY:this.invertsY_,layout:a.layout,maxValue:this.maxValue_,value:this.value,viewProps:this.viewProps}),this.ptHandler_=new Qn(this.view.padElement),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.padElement.addEventListener("keydown",this.onPadKeyDown_),this.view.padElement.addEventListener("keyup",this.onPadKeyUp_)}handlePointerEvent_(r,a){if(!r.point)return;const p=this.maxValue_,y=se(r.point.x,0,r.bounds.width,-p,+p),I=se(this.invertsY_?r.bounds.height-r.point.y:r.point.y,0,r.bounds.height,-p,+p);this.value.setRawValue(new En(y,I),a)}onPointerDown_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerMove_(r){this.handlePointerEvent_(r.data,{forceEmit:!1,last:!1})}onPointerUp_(r){this.handlePointerEvent_(r.data,{forceEmit:!0,last:!0})}onPadKeyDown_(r){ml(r.key)&&r.preventDefault();const[a,p]=Al(r,this.baseSteps_,this.invertsY_);a===0&&p===0||this.value.setRawValue(new En(this.value.rawValue.x+a,this.value.rawValue.y+p),{forceEmit:!1,last:!1})}onPadKeyUp_(r){const[a,p]=Al(r,this.baseSteps_,this.invertsY_);a===0&&p===0||this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}class fp{constructor(r,a){var p,y;this.onPopupChildBlur_=this.onPopupChildBlur_.bind(this),this.onPopupChildKeydown_=this.onPopupChildKeydown_.bind(this),this.onPadButtonBlur_=this.onPadButtonBlur_.bind(this),this.onPadButtonClick_=this.onPadButtonClick_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.foldable_=D.create(a.expanded),this.popC_=a.pickerLayout==="popup"?new sl(r,{viewProps:this.viewProps}):null;const I=new pp(r,{baseSteps:[a.axes[0].baseStep,a.axes[1].baseStep],invertsY:a.invertsY,layout:a.pickerLayout,maxValue:a.maxValue,value:this.value,viewProps:this.viewProps});I.view.allFocusableElements.forEach(V=>{V.addEventListener("blur",this.onPopupChildBlur_),V.addEventListener("keydown",this.onPopupChildKeydown_)}),this.pickerC_=I,this.textC_=new Po(r,{assembly:Cl,axes:a.axes,parser:a.parser,value:this.value,viewProps:this.viewProps}),this.view=new up(r,{expanded:this.foldable_.value("expanded"),pickerLayout:a.pickerLayout,viewProps:this.viewProps}),this.view.textElement.appendChild(this.textC_.view.element),(p=this.view.buttonElement)===null||p===void 0||p.addEventListener("blur",this.onPadButtonBlur_),(y=this.view.buttonElement)===null||y===void 0||y.addEventListener("click",this.onPadButtonClick_),this.popC_?(this.view.element.appendChild(this.popC_.view.element),this.popC_.view.element.appendChild(this.pickerC_.view.element),dr({primary:this.foldable_.value("expanded"),secondary:this.popC_.shows,forward:V=>V.rawValue,backward:(V,ct)=>ct.rawValue})):this.view.pickerElement&&(this.view.pickerElement.appendChild(this.pickerC_.view.element),zt(this.foldable_,this.view.pickerElement))}onPadButtonBlur_(r){if(!this.popC_)return;const a=this.view.element,p=d(r.relatedTarget);(!p||!a.contains(p))&&(this.popC_.shows.rawValue=!1)}onPadButtonClick_(){this.foldable_.set("expanded",!this.foldable_.get("expanded")),this.foldable_.get("expanded")&&this.pickerC_.view.allFocusableElements[0].focus()}onPopupChildBlur_(r){if(!this.popC_)return;const a=this.popC_.view.element,p=Lt(r);p&&a.contains(p)||p&&p===this.view.buttonElement&&!$(a.ownerDocument)||(this.popC_.shows.rawValue=!1)}onPopupChildKeydown_(r){this.popC_?r.key==="Escape"&&(this.popC_.shows.rawValue=!1):this.view.pickerElement&&r.key==="Escape"&&this.view.buttonElement.focus()}}function mp(c){return En.isObject(c)?new En(c.x,c.y):new En}function gp(c,r){c.writeProperty("x",r.x),c.writeProperty("y",r.y)}function Pl(c){if(!c)return;const r=[];return f(c.step)||r.push(new Jn(c.step)),(!f(c.max)||!f(c.min))&&r.push(new ze({max:c.max,min:c.min})),new Kn(r)}function vp(c){return new Sn({assembly:Cl,components:[Pl("x"in c?c.x:void 0),Pl("y"in c?c.y:void 0)]})}function Ll(c,r){const a=c&&sn(c,ze);if(a)return Math.max(Math.abs(a.minValue||0),Math.abs(a.maxValue||0));const p=di(c);return Math.max(Math.abs(p)*10,Math.abs(r)*10)}function _p(c,r){const a=r instanceof Sn?r.components[0]:void 0,p=r instanceof Sn?r.components[1]:void 0,y=Ll(a,c.x),I=Ll(p,c.y);return Math.max(y,I)}function Rl(c,r){return{baseStep:di(r),constraint:r,textProps:B.fromObject({draggingScale:pi(r,c),formatter:Ie(es(r,c))})}}function xp(c){if(!("y"in c))return!1;const r=c.y;return r&&"inverted"in r?!!r.inverted:!1}const bp={id:"input-point2d",type:"input",accept:(c,r)=>{if(!En.isObject(c))return null;const a=vt,p=K(r,{expanded:a.optional.boolean,picker:a.optional.custom(vl),x:a.optional.custom(wn),y:a.optional.object({inverted:a.optional.boolean,max:a.optional.number,min:a.optional.number,step:a.optional.number})});return p?{initialValue:c,params:p}:null},binding:{reader:c=>mp,constraint:c=>vp(c.params),equals:En.equals,writer:c=>gp},controller:c=>{const r=c.document,a=c.value,p=c.constraint;if(!(p instanceof Sn))throw v.shouldNeverHappen();const y="expanded"in c.params?c.params.expanded:void 0,I="picker"in c.params?c.params.picker:void 0;return new fp(r,{axes:[Rl(a.rawValue.x,p.components[0]),Rl(a.rawValue.y,p.components[1])],expanded:y!=null?y:!1,invertsY:xp(c.params),maxValue:_p(a.rawValue,p),parser:pn,pickerLayout:I!=null?I:"popup",value:a,viewProps:c.viewProps})}};class vi{constructor(r=0,a=0,p=0){this.x=r,this.y=a,this.z=p}getComponents(){return[this.x,this.y,this.z]}static isObject(r){if(f(r))return!1;const a=r.x,p=r.y,y=r.z;return!(typeof a!="number"||typeof p!="number"||typeof y!="number")}static equals(r,a){return r.x===a.x&&r.y===a.y&&r.z===a.z}toObject(){return{x:this.x,y:this.y,z:this.z}}}const Dl={toComponents:c=>c.getComponents(),fromComponents:c=>new vi(...c)};function yp(c){return vi.isObject(c)?new vi(c.x,c.y,c.z):new vi}function wp(c,r){c.writeProperty("x",r.x),c.writeProperty("y",r.y),c.writeProperty("z",r.z)}function Lo(c){if(!c)return;const r=[];return f(c.step)||r.push(new Jn(c.step)),(!f(c.max)||!f(c.min))&&r.push(new ze({max:c.max,min:c.min})),new Kn(r)}function Mp(c){return new Sn({assembly:Dl,components:[Lo("x"in c?c.x:void 0),Lo("y"in c?c.y:void 0),Lo("z"in c?c.z:void 0)]})}function Ro(c,r){return{baseStep:di(r),constraint:r,textProps:B.fromObject({draggingScale:pi(r,c),formatter:Ie(es(r,c))})}}const Sp={id:"input-point3d",type:"input",accept:(c,r)=>{if(!vi.isObject(c))return null;const a=vt,p=K(r,{x:a.optional.custom(wn),y:a.optional.custom(wn),z:a.optional.custom(wn)});return p?{initialValue:c,params:p}:null},binding:{reader:c=>yp,constraint:c=>Mp(c.params),equals:vi.equals,writer:c=>wp},controller:c=>{const r=c.value,a=c.constraint;if(!(a instanceof Sn))throw v.shouldNeverHappen();return new Po(c.document,{assembly:Dl,axes:[Ro(r.rawValue.x,a.components[0]),Ro(r.rawValue.y,a.components[1]),Ro(r.rawValue.z,a.components[2])],parser:pn,value:r,viewProps:c.viewProps})}};class _i{constructor(r=0,a=0,p=0,y=0){this.x=r,this.y=a,this.z=p,this.w=y}getComponents(){return[this.x,this.y,this.z,this.w]}static isObject(r){if(f(r))return!1;const a=r.x,p=r.y,y=r.z,I=r.w;return!(typeof a!="number"||typeof p!="number"||typeof y!="number"||typeof I!="number")}static equals(r,a){return r.x===a.x&&r.y===a.y&&r.z===a.z&&r.w===a.w}toObject(){return{x:this.x,y:this.y,z:this.z,w:this.w}}}const Il={toComponents:c=>c.getComponents(),fromComponents:c=>new _i(...c)};function Ep(c){return _i.isObject(c)?new _i(c.x,c.y,c.z,c.w):new _i}function Tp(c,r){c.writeProperty("x",r.x),c.writeProperty("y",r.y),c.writeProperty("z",r.z),c.writeProperty("w",r.w)}function ls(c){if(!c)return;const r=[];return f(c.step)||r.push(new Jn(c.step)),(!f(c.max)||!f(c.min))&&r.push(new ze({max:c.max,min:c.min})),new Kn(r)}function Cp(c){return new Sn({assembly:Il,components:[ls("x"in c?c.x:void 0),ls("y"in c?c.y:void 0),ls("z"in c?c.z:void 0),ls("w"in c?c.w:void 0)]})}function Ap(c,r){return{baseStep:di(r),constraint:r,textProps:B.fromObject({draggingScale:pi(r,c),formatter:Ie(es(r,c))})}}const Pp={id:"input-point4d",type:"input",accept:(c,r)=>{if(!_i.isObject(c))return null;const a=vt,p=K(r,{x:a.optional.custom(wn),y:a.optional.custom(wn),z:a.optional.custom(wn),w:a.optional.custom(wn)});return p?{initialValue:c,params:p}:null},binding:{reader:c=>Ep,constraint:c=>Cp(c.params),equals:_i.equals,writer:c=>Tp},controller:c=>{const r=c.value,a=c.constraint;if(!(a instanceof Sn))throw v.shouldNeverHappen();return new Po(c.document,{assembly:Il,axes:r.rawValue.getComponents().map((p,y)=>Ap(p,a.components[y])),parser:pn,value:r,viewProps:c.viewProps})}};function Lp(c){const r=[],a=_o(c.options);return a&&r.push(a),new Kn(r)}const Rp={id:"input-string",type:"input",accept:(c,r)=>{if(typeof c!="string")return null;const p=K(r,{options:vt.optional.custom(ts)});return p?{initialValue:c,params:p}:null},binding:{reader:c=>pl,constraint:c=>Lp(c.params),writer:c=>mr},controller:c=>{var r;const a=c.document,p=c.value,y=c.constraint;return y&&sn(y,lr)?new cr(a,{props:B.fromObject({options:(r=xo(y))!==null&&r!==void 0?r:[]}),value:p,viewProps:c.viewProps}):new Jr(a,{parser:I=>I,props:B.fromObject({formatter:uo}),value:p,viewProps:c.viewProps})}},vr={monitor:{defaultInterval:200,defaultLineCount:3}},Nl=_("mll");class Dp{constructor(r,a){this.onValueUpdate_=this.onValueUpdate_.bind(this),this.formatter_=a.formatter,this.element=r.createElement("div"),this.element.classList.add(Nl()),a.viewProps.bindClassModifiers(this.element);const p=r.createElement("textarea");p.classList.add(Nl("i")),p.style.height=`calc(var(--bld-us) * ${a.lineCount})`,p.readOnly=!0,a.viewProps.bindDisabled(p),this.element.appendChild(p),this.textareaElem_=p,a.value.emitter.on("change",this.onValueUpdate_),this.value=a.value,this.update_()}update_(){const r=this.textareaElem_,a=r.scrollTop===r.scrollHeight-r.clientHeight,p=[];this.value.rawValue.forEach(y=>{y!==void 0&&p.push(this.formatter_(y))}),r.textContent=p.join(`
`),a&&(r.scrollTop=r.scrollHeight)}onValueUpdate_(){this.update_()}}class Do{constructor(r,a){this.value=a.value,this.viewProps=a.viewProps,this.view=new Dp(r,{formatter:a.formatter,lineCount:a.lineCount,value:this.value,viewProps:this.viewProps})}}const kl=_("sgl");class Ip{constructor(r,a){this.onValueUpdate_=this.onValueUpdate_.bind(this),this.formatter_=a.formatter,this.element=r.createElement("div"),this.element.classList.add(kl()),a.viewProps.bindClassModifiers(this.element);const p=r.createElement("input");p.classList.add(kl("i")),p.readOnly=!0,p.type="text",a.viewProps.bindDisabled(p),this.element.appendChild(p),this.inputElement=p,a.value.emitter.on("change",this.onValueUpdate_),this.value=a.value,this.update_()}update_(){const r=this.value.rawValue,a=r[r.length-1];this.inputElement.value=a!==void 0?this.formatter_(a):""}onValueUpdate_(){this.update_()}}class Io{constructor(r,a){this.value=a.value,this.viewProps=a.viewProps,this.view=new Ip(r,{formatter:a.formatter,value:this.value,viewProps:this.viewProps})}}const Np={id:"monitor-bool",type:"monitor",accept:(c,r)=>{if(typeof c!="boolean")return null;const p=K(r,{lineCount:vt.optional.number});return p?{initialValue:c,params:p}:null},binding:{reader:c=>al},controller:c=>{var r;return c.value.rawValue.length===1?new Io(c.document,{formatter:ll,value:c.value,viewProps:c.viewProps}):new Do(c.document,{formatter:ll,lineCount:(r=c.params.lineCount)!==null&&r!==void 0?r:vr.monitor.defaultLineCount,value:c.value,viewProps:c.viewProps})}};class kp{constructor(){this.emitter=new M,this.index_=-1}get index(){return this.index_}set index(r){this.index_!==r&&(this.index_=r,this.emitter.emit("change",{index:r,sender:this}))}}const Cn=_("grl");class Fp{constructor(r,a){this.onCursorChange_=this.onCursorChange_.bind(this),this.onValueUpdate_=this.onValueUpdate_.bind(this),this.element=r.createElement("div"),this.element.classList.add(Cn()),a.viewProps.bindClassModifiers(this.element),this.formatter_=a.formatter,this.minValue_=a.minValue,this.maxValue_=a.maxValue,this.cursor_=a.cursor,this.cursor_.emitter.on("change",this.onCursorChange_);const p=r.createElementNS(ut,"svg");p.classList.add(Cn("g")),p.style.height=`calc(var(--bld-us) * ${a.lineCount})`,this.element.appendChild(p),this.svgElem_=p;const y=r.createElementNS(ut,"polyline");this.svgElem_.appendChild(y),this.lineElem_=y;const I=r.createElement("div");I.classList.add(Cn("t"),_("tt")()),this.element.appendChild(I),this.tooltipElem_=I,a.value.emitter.on("change",this.onValueUpdate_),this.value=a.value,this.update_()}get graphElement(){return this.svgElem_}update_(){const r=this.svgElem_.getBoundingClientRect(),a=this.value.rawValue.length-1,p=this.minValue_,y=this.maxValue_,I=[];this.value.rawValue.forEach((Xt,Yt)=>{if(Xt===void 0)return;const ni=se(Yt,0,a,0,r.width),_r=se(Xt,p,y,r.height,0);I.push([ni,_r].join(","))}),this.lineElem_.setAttributeNS(null,"points",I.join(" "));const V=this.tooltipElem_,ct=this.value.rawValue[this.cursor_.index];if(ct===void 0){V.classList.remove(Cn("t","a"));return}const Dt=se(this.cursor_.index,0,a,0,r.width),Bt=se(ct,p,y,r.height,0);V.style.left=`${Dt}px`,V.style.top=`${Bt}px`,V.textContent=`${this.formatter_(ct)}`,V.classList.contains(Cn("t","a"))||(V.classList.add(Cn("t","a"),Cn("t","in")),xt(V),V.classList.remove(Cn("t","in")))}onValueUpdate_(){this.update_()}onCursorChange_(){this.update_()}}class Bp{constructor(r,a){if(this.onGraphMouseMove_=this.onGraphMouseMove_.bind(this),this.onGraphMouseLeave_=this.onGraphMouseLeave_.bind(this),this.onGraphPointerDown_=this.onGraphPointerDown_.bind(this),this.onGraphPointerMove_=this.onGraphPointerMove_.bind(this),this.onGraphPointerUp_=this.onGraphPointerUp_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.cursor_=new kp,this.view=new Fp(r,{cursor:this.cursor_,formatter:a.formatter,lineCount:a.lineCount,maxValue:a.maxValue,minValue:a.minValue,value:this.value,viewProps:this.viewProps}),!$(r))this.view.element.addEventListener("mousemove",this.onGraphMouseMove_),this.view.element.addEventListener("mouseleave",this.onGraphMouseLeave_);else{const p=new Qn(this.view.element);p.emitter.on("down",this.onGraphPointerDown_),p.emitter.on("move",this.onGraphPointerMove_),p.emitter.on("up",this.onGraphPointerUp_)}}onGraphMouseLeave_(){this.cursor_.index=-1}onGraphMouseMove_(r){const a=this.view.element.getBoundingClientRect();this.cursor_.index=Math.floor(se(r.offsetX,0,a.width,0,this.value.rawValue.length))}onGraphPointerDown_(r){this.onGraphPointerMove_(r)}onGraphPointerMove_(r){if(!r.data.point){this.cursor_.index=-1;return}this.cursor_.index=Math.floor(se(r.data.point.x,0,r.data.bounds.width,0,this.value.rawValue.length))}onGraphPointerUp_(){this.cursor_.index=-1}}function No(c){return"format"in c&&!f(c.format)?c.format:Ie(2)}function Vp(c){var r;return c.value.rawValue.length===1?new Io(c.document,{formatter:No(c.params),value:c.value,viewProps:c.viewProps}):new Do(c.document,{formatter:No(c.params),lineCount:(r=c.params.lineCount)!==null&&r!==void 0?r:vr.monitor.defaultLineCount,value:c.value,viewProps:c.viewProps})}function Op(c){var r,a,p;return new Bp(c.document,{formatter:No(c.params),lineCount:(r=c.params.lineCount)!==null&&r!==void 0?r:vr.monitor.defaultLineCount,maxValue:(a="max"in c.params?c.params.max:null)!==null&&a!==void 0?a:100,minValue:(p="min"in c.params?c.params.min:null)!==null&&p!==void 0?p:0,value:c.value,viewProps:c.viewProps})}function Fl(c){return"view"in c&&c.view==="graph"}const zp={id:"monitor-number",type:"monitor",accept:(c,r)=>{if(typeof c!="number")return null;const a=vt,p=K(r,{format:a.optional.function,lineCount:a.optional.number,max:a.optional.number,min:a.optional.number,view:a.optional.string});return p?{initialValue:c,params:p}:null},binding:{defaultBufferSize:c=>Fl(c)?64:1,reader:c=>dl},controller:c=>Fl(c.params)?Op(c):Vp(c)},Up={id:"monitor-string",type:"monitor",accept:(c,r)=>{if(typeof c!="string")return null;const a=vt,p=K(r,{lineCount:a.optional.number,multiline:a.optional.boolean});return p?{initialValue:c,params:p}:null},binding:{reader:c=>pl},controller:c=>{var r;const a=c.value;return a.rawValue.length>1||"multiline"in c.params&&c.params.multiline?new Do(c.document,{formatter:uo,lineCount:(r=c.params.lineCount)!==null&&r!==void 0?r:vr.monitor.defaultLineCount,value:a,viewProps:c.viewProps}):new Io(c.document,{formatter:uo,value:a,viewProps:c.viewProps})}};class Hp{constructor(r){this.onValueChange_=this.onValueChange_.bind(this),this.reader=r.reader,this.writer=r.writer,this.emitter=new M,this.value=r.value,this.value.emitter.on("change",this.onValueChange_),this.target=r.target,this.read()}read(){const r=this.target.read();r!==void 0&&(this.value.rawValue=this.reader(r))}write_(r){this.writer(this.target,r)}onValueChange_(r){this.write_(r.rawValue),this.emitter.emit("change",{options:r.options,rawValue:r.rawValue,sender:this})}}function Gp(c,r){const a=c.accept(r.target.read(),r.params);if(f(a))return null;const p=vt,y={target:r.target,initialValue:a.initialValue,params:a.params},I=c.binding.reader(y),V=c.binding.constraint?c.binding.constraint(y):void 0,ct=W(I(a.initialValue),{constraint:V,equals:c.binding.equals}),Dt=new Hp({reader:I,target:r.target,value:ct,writer:c.binding.writer(y)}),Bt=p.optional.boolean(r.params.disabled).value,Xt=p.optional.boolean(r.params.hidden).value,Yt=c.controller({constraint:V,document:r.document,initialValue:a.initialValue,params:a.params,value:Dt.value,viewProps:ye.create({disabled:Bt,hidden:Xt})}),ni=p.optional.string(r.params.label).value;return new Ve(r.document,{binding:Dt,blade:gt(),props:B.fromObject({label:ni||r.target.key}),valueController:Yt})}class Wp{constructor(r){this.onTick_=this.onTick_.bind(this),this.reader_=r.reader,this.target=r.target,this.emitter=new M,this.value=r.value,this.ticker=r.ticker,this.ticker.emitter.on("tick",this.onTick_),this.read()}dispose(){this.ticker.dispose()}read(){const r=this.target.read();if(r===void 0)return;const a=this.value.rawValue,p=this.reader_(r);this.value.rawValue=Qu(a,p),this.emitter.emit("update",{rawValue:p,sender:this})}onTick_(r){this.read()}}function qp(c,r){return r===0?new vu:new _u(c,r!=null?r:vr.monitor.defaultInterval)}function jp(c,r){var a,p,y;const I=vt,V=c.accept(r.target.read(),r.params);if(f(V))return null;const ct={target:r.target,initialValue:V.initialValue,params:V.params},Dt=c.binding.reader(ct),Bt=(p=(a=I.optional.number(r.params.bufferSize).value)!==null&&a!==void 0?a:c.binding.defaultBufferSize&&c.binding.defaultBufferSize(V.params))!==null&&p!==void 0?p:1,Xt=I.optional.number(r.params.interval).value,Yt=new Wp({reader:Dt,target:r.target,ticker:qp(r.document,Xt),value:Ku(Bt)}),ni=I.optional.boolean(r.params.disabled).value,_r=I.optional.boolean(r.params.hidden).value,xr=c.controller({document:r.document,params:V.params,value:Yt.value,viewProps:ye.create({disabled:ni,hidden:_r})}),xi=(y=I.optional.string(r.params.label).value)!==null&&y!==void 0?y:r.target.key;return new $e(r.document,{binding:Yt,blade:gt(),props:B.fromObject({label:xi}),valueController:xr})}class Xp{constructor(){this.pluginsMap_={blades:[],inputs:[],monitors:[]}}getAll(){return[...this.pluginsMap_.blades,...this.pluginsMap_.inputs,...this.pluginsMap_.monitors]}register(r){r.type==="blade"?this.pluginsMap_.blades.unshift(r):r.type==="input"?this.pluginsMap_.inputs.unshift(r):r.type==="monitor"&&this.pluginsMap_.monitors.unshift(r)}createInput(r,a,p){const y=a.read();if(f(y))throw new v({context:{key:a.key},type:"nomatchingcontroller"});const I=this.pluginsMap_.inputs.reduce((V,ct)=>V||Gp(ct,{document:r,target:a,params:p}),null);if(I)return I;throw new v({context:{key:a.key},type:"nomatchingcontroller"})}createMonitor(r,a,p){const y=this.pluginsMap_.monitors.reduce((I,V)=>I||jp(V,{document:r,params:p,target:a}),null);if(y)return y;throw new v({context:{key:a.key},type:"nomatchingcontroller"})}createBlade(r,a){const p=this.pluginsMap_.blades.reduce((y,I)=>y||gu(I,{document:r,params:a}),null);if(!p)throw new v({type:"nomatchingview",context:{params:a}});return p}createBladeApi(r){if(r instanceof Ve)return new ci(r);if(r instanceof $e)return new Ze(r);if(r instanceof Q)return new hi(r,this);const a=this.pluginsMap_.blades.reduce((p,y)=>p||y.api({controller:r,pool:this}),null);if(!a)throw v.shouldNeverHappen();return a}}function Yp(){const c=new Xp;return[bp,Sp,Pp,Rp,hp,np,ep,Qd,cd,Np,Up,zp,pt,Vt,jt,il].forEach(r=>{c.register(r)}),c}class Bl extends i{constructor(r){super(r);this.emitter_=new M,this.controller_.valueController.value.emitter.on("change",a=>{this.emitter_.emit("change",{event:new l(this,a.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}get options(){return this.controller_.valueController.props.get("options")}set options(r){this.controller_.valueController.props.set("options",r)}get value(){return this.controller_.valueController.value.rawValue}set value(r){this.controller_.valueController.value.rawValue=r}on(r,a){const p=a.bind(this);return this.emitter_.on(r,y=>{p(y.event)}),this}}class Vl extends i{constructor(r){super(r);this.emitter_=new M,this.controller_.valueController.value.emitter.on("change",a=>{this.emitter_.emit("change",{event:new l(this,a.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}get maxValue(){return this.controller_.valueController.sliderController.props.get("maxValue")}set maxValue(r){this.controller_.valueController.sliderController.props.set("maxValue",r)}get minValue(){return this.controller_.valueController.sliderController.props.get("minValue")}set minValue(r){this.controller_.valueController.sliderController.props.set("minValue",r)}get value(){return this.controller_.valueController.value.rawValue}set value(r){this.controller_.valueController.value.rawValue=r}on(r,a){const p=a.bind(this);return this.emitter_.on(r,y=>{p(y.event)}),this}}class Ol extends i{constructor(r){super(r);this.emitter_=new M,this.controller_.valueController.value.emitter.on("change",a=>{this.emitter_.emit("change",{event:new l(this,a.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(r){this.controller_.props.set("label",r)}get formatter(){return this.controller_.valueController.props.get("formatter")}set formatter(r){this.controller_.valueController.props.set("formatter",r)}get value(){return this.controller_.valueController.value.rawValue}set value(r){this.controller_.valueController.value.rawValue=r}on(r,a){const p=a.bind(this);return this.emitter_.on(r,y=>{p(y.event)}),this}}const Zp=function(){return{id:"list",type:"blade",accept(c){const r=vt,a=K(c,{options:r.required.custom(ts),value:r.required.raw,view:r.required.constant("list"),label:r.optional.string});return a?{params:a}:null},controller(c){const r=new cr(c.document,{props:B.fromObject({options:_l(c.params.options)}),value:W(c.params.value),viewProps:c.viewProps});return new Gt(c.document,{blade:c.blade,props:B.fromObject({label:c.params.label}),valueController:r})},api(c){return!(c.controller instanceof Gt)||!(c.controller.valueController instanceof cr)?null:new Bl(c.controller)}}}();function $p(c){return c.reduce((r,a)=>Object.assign(r,{[a.presetKey]:a.read()}),{})}function Kp(c,r){c.forEach(a=>{const p=r[a.presetKey];p!==void 0&&a.write(p)})}class Jp extends Zn{constructor(r,a){super(r,a)}get element(){return this.controller_.view.element}importPreset(r){const a=this.controller_.rackController.rack.find(Ve).map(p=>p.binding.target);Kp(a,r),this.refresh()}exportPreset(){const r=this.controller_.rackController.rack.find(Ve).map(a=>a.binding.target);return $p(r)}refresh(){this.controller_.rackController.rack.find(Ve).forEach(r=>{r.binding.read()}),this.controller_.rackController.rack.find($e).forEach(r=>{r.binding.read()})}}class Qp extends Pt{constructor(r,a){super(r,{expanded:a.expanded,blade:a.blade,props:a.props,root:!0,viewProps:a.viewProps})}}const tf={id:"slider",type:"blade",accept(c){const r=vt,a=K(c,{max:r.required.number,min:r.required.number,view:r.required.constant("slider"),format:r.optional.function,label:r.optional.string,value:r.optional.number});return a?{params:a}:null},controller(c){var r,a;const p=(r=c.params.value)!==null&&r!==void 0?r:0,y=new vo(c.document,{baseStep:1,parser:pn,sliderProps:B.fromObject({maxValue:c.params.max,minValue:c.params.min}),textProps:B.fromObject({draggingScale:pi(void 0,p),formatter:(a=c.params.format)!==null&&a!==void 0?a:Zu}),value:W(p),viewProps:c.viewProps});return new Gt(c.document,{blade:c.blade,props:B.fromObject({label:c.params.label}),valueController:y})},api(c){return!(c.controller instanceof Gt)||!(c.controller.valueController instanceof vo)?null:new Vl(c.controller)}},ef=function(){return{id:"text",type:"blade",accept(c){const r=vt,a=K(c,{parse:r.required.function,value:r.required.raw,view:r.required.constant("text"),format:r.optional.function,label:r.optional.string});return a?{params:a}:null},controller(c){var r;const a=new Jr(c.document,{parser:c.params.parse,props:B.fromObject({formatter:(r=c.params.format)!==null&&r!==void 0?r:p=>String(p)}),value:W(c.params.value),viewProps:c.viewProps});return new Gt(c.document,{blade:c.blade,props:B.fromObject({label:c.params.label}),valueController:a})},api(c){return!(c.controller instanceof Gt)||!(c.controller.valueController instanceof Jr)?null:new Ol(c.controller)}}}();function nf(c){const r=c.createElement("div");return r.classList.add(_("dfw")()),c.body&&c.body.appendChild(r),r}function zl(c,r,a){if(c.querySelector(`style[data-tp-style=${r}]`))return;const p=c.createElement("style");p.dataset.tpStyle=r,p.textContent=a,c.head.appendChild(p)}class rf extends Jp{constructor(r){var a;const p=r||{},y=(a=p.document)!==null&&a!==void 0?a:lt(),I=Yp(),V=new Qp(y,{expanded:p.expanded,blade:gt(),props:B.fromObject({title:p.title}),viewProps:ye.create()});super(V,I);this.pool_=I,this.containerElem_=p.container||nf(y),this.containerElem_.appendChild(this.element),this.doc_=y,this.usesDefaultWrapper_=!p.container,this.setUpDefaultPlugins_()}get document(){if(!this.doc_)throw v.alreadyDisposed();return this.doc_}dispose(){const r=this.containerElem_;if(!r)throw v.alreadyDisposed();if(this.usesDefaultWrapper_){const a=r.parentElement;a&&a.removeChild(r)}this.containerElem_=null,this.doc_=null,super.dispose()}registerPlugin(r){("plugin"in r?[r.plugin]:"plugins"in r?r.plugins:[]).forEach(p=>{this.pool_.register(p),this.embedPluginStyle_(p)})}embedPluginStyle_(r){r.css&&zl(this.document,`plugin-${r.id}`,r.css)}setUpDefaultPlugins_(){zl(this.document,"default",".tp-lstv_s,.tp-btnv_b,.tp-p2dv_b,.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i,.tp-grlv_g,.tp-sglv_i,.tp-mllv_i,.tp-fldv_b,.tp-rotv_b,.tp-ckbv_i,.tp-coltxtv_ms,.tp-tbiv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-lstv_s,.tp-btnv_b,.tp-p2dv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-lstv_s:hover,.tp-btnv_b:hover,.tp-p2dv_b:hover{background-color:var(--btn-bg-h)}.tp-lstv_s:focus,.tp-btnv_b:focus,.tp-p2dv_b:focus{background-color:var(--btn-bg-f)}.tp-lstv_s:active,.tp-btnv_b:active,.tp-p2dv_b:active{background-color:var(--btn-bg-a)}.tp-lstv_s:disabled,.tp-btnv_b:disabled,.tp-p2dv_b:disabled{opacity:0.5}.tp-colswv_sw,.tp-p2dpv_p,.tp-txtv_i{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-colswv_sw:hover,.tp-p2dpv_p:hover,.tp-txtv_i:hover{background-color:var(--in-bg-h)}.tp-colswv_sw:focus,.tp-p2dpv_p:focus,.tp-txtv_i:focus{background-color:var(--in-bg-f)}.tp-colswv_sw:active,.tp-p2dpv_p:active,.tp-txtv_i:active{background-color:var(--in-bg-a)}.tp-colswv_sw:disabled,.tp-p2dpv_p:disabled,.tp-txtv_i:disabled{opacity:0.5}.tp-grlv_g,.tp-sglv_i,.tp-mllv_i{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);width:100%}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono,Source Code Pro,Menlo,Courier,monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #2f3137);--bs-sh: var(--tp-base-shadow-color, rgba(0,0,0,0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #2f3137);--cnt-bg: var(--tp-container-background-color, rgba(187,188,196,0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187,188,196,0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187,188,196,0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187,188,196,0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(0,0,0,0.2));--in-bg-a: var(--tp-input-background-color-active, rgba(0,0,0,0.35));--in-bg-f: var(--tp-input-background-color-focus, rgba(0,0,0,0.3));--in-bg-h: var(--tp-input-background-color-hover, rgba(0,0,0,0.25));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187,188,196,0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0,0,0,0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187,188,196,0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(0,0,0,0.2))}.tp-fldv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-rotv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1 * var(--cnt-v-p))}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-rotv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-fldv_c>.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv{margin-left:4px}.tp-fldv_c>.tp-fldv>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-fldv_c .tp-fldv>.tp-fldv_c,.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_c>.tp-tabv>.tp-tabv_i,.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-fldv_c .tp-tabv>.tp-tabv_c,.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-fldv_b,.tp-rotv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:calc(var(--cnt-h-p) + 8px);padding-right:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-fldv_b:hover,.tp-rotv_b:hover{background-color:var(--cnt-bg-h)}.tp-fldv_b:focus,.tp-rotv_b:focus{background-color:var(--cnt-bg-f)}.tp-fldv_b:active,.tp-rotv_b:active{background-color:var(--cnt-bg-a)}.tp-fldv_b:disabled,.tp-rotv_b:disabled{opacity:0.5}.tp-fldv_m,.tp-rotv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:'';display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px) / 2 - 2px);margin:auto;opacity:0.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m,.tp-rotv.tp-rotv-expanded .tp-rotv_m{transform:none}.tp-fldv_c,.tp-rotv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c,.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c{display:none}.tp-fldv.tp-fldv-expanded>.tp-fldv_c,.tp-rotv.tp-rotv-expanded .tp-rotv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-coltxtv_m,.tp-lstv{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-coltxtv_mm,.tp-lstv_m{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-coltxtv_mm svg,.tp-lstv_m svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-coltxtv_mm svg path,.tp-lstv_m svg path{fill:currentColor}.tp-coltxtv_w,.tp-pndtxtv{display:flex}.tp-coltxtv_c,.tp-pndtxtv_a{width:100%}.tp-coltxtv_c+.tp-coltxtv_c,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-pndtxtv_a{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:0.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:'';height:2px;left:calc(-1 * var(--cnt-h-p));position:absolute;right:calc(-1 * var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us) * 4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0,0,0,0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,0.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,0.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,0.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br)}.tp-colswv.tp-v-disabled{opacity:0.5}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,0.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:'';display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us) * 3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left 0.05s, top 0.05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:0.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:0.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:0.5}.tp-mllv_i{display:block;height:calc(var(--bld-us) * 3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:0.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1 * var(--cnt-h-p));right:calc(-1 * var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:0.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:0.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:0.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:'';display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:0.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:'';height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:0.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:0.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:0.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:'';height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:0.1;position:absolute;top:0;transition:border-radius 0.1s, height 0.1s, transform 0.1s, width 0.1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:'';font-size:0.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(2px * 2 + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1 * var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}"),this.pool_.getAll().forEach(r=>{this.embedPluginStyle_(r)}),this.registerPlugin({plugins:[tf,Zp,il,ef]})}}const sf=new n("3.0.5");e.BladeApi=i,e.ButtonApi=w,e.FolderApi=Zn,e.InputBindingApi=ci,e.ListApi=Bl,e.MonitorBindingApi=Ze,e.Pane=rf,e.SeparatorApi=Ut,e.SliderApi=Vl,e.TabApi=De,e.TabPageApi=yn,e.TextApi=Ol,e.TpChangeEvent=l,e.VERSION=sf,Object.defineProperty(e,"__esModule",{value:!0})})})(fu,fu.exports);export{Yl as A,ae as B,Ct as C,ly as O,Be as P,bh as S,te as W,pe as a,Bh as b,R0 as c,fu as t};
